<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QPACK: Header Compression for HTTP/3</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Conventions and Definitions">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Notational Conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 Compression Process Overview">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Encoder">
<link href="#rfc.section.2.1.1" rel="Chapter" title="2.1.1 Reference Tracking">
<link href="#rfc.section.2.1.2" rel="Chapter" title="2.1.2 Blocked Dynamic Table Insertions">
<link href="#rfc.section.2.1.3" rel="Chapter" title="2.1.3 Blocked Streams">
<link href="#rfc.section.2.1.4" rel="Chapter" title="2.1.4 Known Received Count">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Decoder">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Blocked Decoding">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 State Synchronization">
<link href="#rfc.section.2.2.3" rel="Chapter" title="2.2.3 Invalid References">
<link href="#rfc.section.3" rel="Chapter" title="3 Header Tables">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Static Table">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Dynamic Table">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Dynamic Table Size">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Dynamic Table Capacity and Eviction">
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 Maximum Dynamic Table Capacity">
<link href="#rfc.section.3.2.4" rel="Chapter" title="3.2.4 Absolute Indexing">
<link href="#rfc.section.3.2.5" rel="Chapter" title="3.2.5 Relative Indexing">
<link href="#rfc.section.3.2.6" rel="Chapter" title="3.2.6 Post-Base Indexing">
<link href="#rfc.section.4" rel="Chapter" title="4 Wire Format">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Primitives">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Prefixed Integers">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 String Literals">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Encoder and Decoder Streams">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Encoder Instructions">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Set Dynamic Table Capacity">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Insert With Name Reference">
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 Insert Without Name Reference">
<link href="#rfc.section.4.3.4" rel="Chapter" title="4.3.4 Duplicate">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Decoder Instructions">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 Header Acknowledgement">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 Stream Cancellation">
<link href="#rfc.section.4.4.3" rel="Chapter" title="4.4.3 Insert Count Increment">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Header Block Representations">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 Header Block Prefix">
<link href="#rfc.section.4.5.2" rel="Chapter" title="4.5.2 Indexed Header Field">
<link href="#rfc.section.4.5.3" rel="Chapter" title="4.5.3 Indexed Header Field With Post-Base Index">
<link href="#rfc.section.4.5.4" rel="Chapter" title="4.5.4 Literal Header Field With Name Reference">
<link href="#rfc.section.4.5.5" rel="Chapter" title="4.5.5 Literal Header Field With Post-Base Name Reference">
<link href="#rfc.section.4.5.6" rel="Chapter" title="4.5.6 Literal Header Field Without Name Reference">
<link href="#rfc.section.5" rel="Chapter" title="5 Configuration">
<link href="#rfc.section.6" rel="Chapter" title="6 Error Handling">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Settings Registration">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Stream Type Registration">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Error Code Registration">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Static Table">
<link href="#rfc.appendix.B" rel="Chapter" title="B Sample One Pass Encoding Algorithm">
<link href="#rfc.appendix.C" rel="Chapter" title="C Change Log">
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Since draft-ietf-quic-qpack-08">
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Since draft-ietf-quic-qpack-06">
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Since draft-ietf-quic-qpack-05">
<link href="#rfc.appendix.C.4" rel="Chapter" title="C.4 Since draft-ietf-quic-qpack-04">
<link href="#rfc.appendix.C.5" rel="Chapter" title="C.5 Since draft-ietf-quic-qpack-03">
<link href="#rfc.appendix.C.6" rel="Chapter" title="C.6 Since draft-ietf-quic-qpack-02">
<link href="#rfc.appendix.C.7" rel="Chapter" title="C.7 Since draft-ietf-quic-qpack-01">
<link href="#rfc.appendix.C.8" rel="Chapter" title="C.8 Since draft-ietf-quic-qpack-00">
<link href="#rfc.appendix.C.9" rel="Chapter" title="C.9 Since draft-ietf-quic-qcram-00">
<link href="#rfc.acknowledgments" rel="Chapter">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Krasic, C., Bishop, M., and A. Frindell, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-qpack-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-07-17" />
  <meta name="dct.abstract" content="This specification defines QPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/3. This is a variation of HPACK header compression that seeks to reduce head-of-line blocking." />
  <meta name="description" content="This specification defines QPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/3. This is a variation of HPACK header compression that seeks to reduce head-of-line blocking." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">C. Krasic</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Netflix</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">M. Bishop</td>
</tr>
<tr>
<td class="left">Expires: January 18, 2020</td>
<td class="right">Akamai Technologies</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">A. Frindell, Ed.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Facebook</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">July 17, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QPACK: Header Compression for HTTP/3<br />
  <span class="filename">draft-ietf-quic-qpack-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This specification defines QPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/3. This is a variation of HPACK header compression that seeks to reduce head-of-line blocking.</p>
<h1><a>Note to Readers</a></h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/-qpack">https://github.com/quicwg/base-drafts/labels/-qpack</a>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 18, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Conventions and Definitions</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Notational Conventions</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Compression Process Overview</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Encoder</a>
</li>
<ul><li>2.1.1.   <a href="#rfc.section.2.1.1">Reference Tracking</a>
</li>
<li>2.1.2.   <a href="#rfc.section.2.1.2">Blocked Dynamic Table Insertions</a>
</li>
<li>2.1.3.   <a href="#rfc.section.2.1.3">Blocked Streams</a>
</li>
<li>2.1.4.   <a href="#rfc.section.2.1.4">Known Received Count</a>
</li>
</ul><li>2.2.   <a href="#rfc.section.2.2">Decoder</a>
</li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Blocked Decoding</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">State Synchronization</a>
</li>
<li>2.2.3.   <a href="#rfc.section.2.2.3">Invalid References</a>
</li>
</ul></ul><li>3.   <a href="#rfc.section.3">Header Tables</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Static Table</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Dynamic Table</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Dynamic Table Size</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Dynamic Table Capacity and Eviction</a>
</li>
<li>3.2.3.   <a href="#rfc.section.3.2.3">Maximum Dynamic Table Capacity</a>
</li>
<li>3.2.4.   <a href="#rfc.section.3.2.4">Absolute Indexing</a>
</li>
<li>3.2.5.   <a href="#rfc.section.3.2.5">Relative Indexing</a>
</li>
<li>3.2.6.   <a href="#rfc.section.3.2.6">Post-Base Indexing</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">Wire Format</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Primitives</a>
</li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">Prefixed Integers</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">String Literals</a>
</li>
</ul><li>4.2.   <a href="#rfc.section.4.2">Encoder and Decoder Streams</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Encoder Instructions</a>
</li>
<ul><li>4.3.1.   <a href="#rfc.section.4.3.1">Set Dynamic Table Capacity</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Insert With Name Reference</a>
</li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">Insert Without Name Reference</a>
</li>
<li>4.3.4.   <a href="#rfc.section.4.3.4">Duplicate</a>
</li>
</ul><li>4.4.   <a href="#rfc.section.4.4">Decoder Instructions</a>
</li>
<ul><li>4.4.1.   <a href="#rfc.section.4.4.1">Header Acknowledgement</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">Stream Cancellation</a>
</li>
<li>4.4.3.   <a href="#rfc.section.4.4.3">Insert Count Increment</a>
</li>
</ul><li>4.5.   <a href="#rfc.section.4.5">Header Block Representations</a>
</li>
<ul><li>4.5.1.   <a href="#rfc.section.4.5.1">Header Block Prefix</a>
</li>
<li>4.5.2.   <a href="#rfc.section.4.5.2">Indexed Header Field</a>
</li>
<li>4.5.3.   <a href="#rfc.section.4.5.3">Indexed Header Field With Post-Base Index</a>
</li>
<li>4.5.4.   <a href="#rfc.section.4.5.4">Literal Header Field With Name Reference</a>
</li>
<li>4.5.5.   <a href="#rfc.section.4.5.5">Literal Header Field With Post-Base Name Reference</a>
</li>
<li>4.5.6.   <a href="#rfc.section.4.5.6">Literal Header Field Without Name Reference</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">Configuration</a>
</li>
<li>6.   <a href="#rfc.section.6">Error Handling</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Settings Registration</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Stream Type Registration</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Error Code Registration</a>
</li>
</ul><li>9.   <a href="#rfc.references">References</a>
</li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Static Table</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Sample One Pass Encoding Algorithm</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Change Log</a>
</li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Since draft-ietf-quic-qpack-08</a>
</li>
<li>C.2.   <a href="#rfc.appendix.C.2">Since draft-ietf-quic-qpack-06</a>
</li>
<li>C.3.   <a href="#rfc.appendix.C.3">Since draft-ietf-quic-qpack-05</a>
</li>
<li>C.4.   <a href="#rfc.appendix.C.4">Since draft-ietf-quic-qpack-04</a>
</li>
<li>C.5.   <a href="#rfc.appendix.C.5">Since draft-ietf-quic-qpack-03</a>
</li>
<li>C.6.   <a href="#rfc.appendix.C.6">Since draft-ietf-quic-qpack-02</a>
</li>
<li>C.7.   <a href="#rfc.appendix.C.7">Since draft-ietf-quic-qpack-01</a>
</li>
<li>C.8.   <a href="#rfc.appendix.C.8">Since draft-ietf-quic-qpack-00</a>
</li>
<li>C.9.   <a href="#rfc.appendix.C.9">Since draft-ietf-quic-qcram-00</a>
</li>
</ul><li><a href="#rfc.acknowledgments">Acknowledgments</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The QUIC transport protocol <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a> is designed to support HTTP semantics, and its design subsumes many of the features of HTTP/2 <a href="#RFC7540" class="xref">[RFC7540]</a>.  HTTP/2 uses HPACK (<a href="#RFC7541" class="xref">[RFC7541]</a>) for header compression.  If HPACK were used for HTTP/3 <a href="#HTTP3" class="xref">[HTTP3]</a>, it would induce head-of-line blocking due to built-in assumptions of a total ordering across frames on all streams.</p>
<p id="rfc.section.1.p.2">QPACK reuses core concepts from HPACK, but is redesigned to allow correctness in the presence of out-of-order delivery, with flexibility for implementations to balance between resilience against head-of-line blocking and optimal compression ratio.  The design goals are to closely approach the compression ratio of HPACK with substantially less head-of-line blocking under the same loss conditions.</p>
<h2 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#conventions-and-definitions" id="conventions-and-definitions">Conventions and Definitions</a>
</h2>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.1.1.p.2">Definitions of terms that are used in this document:</p>
<p></p>

<dl>
<dt>Header field:</dt>
<dd style="margin-left: 8">A name-value pair sent as part of an HTTP message.</dd>
<dt>Header list:</dt>
<dd style="margin-left: 8">An ordered collection of header fields associated with an HTTP message.  A header list can contain multiple header fields with the same name.  It can also contain duplicate header fields.</dd>
<dt>Header block:</dt>
<dd style="margin-left: 8">The compressed representation of a header list.</dd>
<dt>Encoder:</dt>
<dd style="margin-left: 8">An implementation which transforms a header list into a header block.</dd>
<dt>Decoder:</dt>
<dd style="margin-left: 8">An implementation which transforms a header block into a header list.</dd>
<dt>Absolute Index:</dt>
<dd style="margin-left: 8">A unique index for each entry in the dynamic table.</dd>
<dt>Base:</dt>
<dd style="margin-left: 8">A reference point for relative indices.  Dynamic references are made relative to a Base in header blocks.</dd>
<dt>Insert Count:</dt>
<dd style="margin-left: 8">The total number of entries inserted in the dynamic table.</dd>
</dl>
<p id="rfc.section.1.1.p.4">QPACK is a name, not an acronym.</p>
<h2 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a>
</h2>
<p id="rfc.section.1.2.p.1">Diagrams use the format described in Section 3.1 of <a href="#RFC2360" class="xref">[RFC2360]</a>, with the following additional conventions:</p>
<p></p>

<dl>
<dt>x (A)</dt>
<dd style="margin-left: 8">Indicates that x is A bits long</dd>
<dt>x (A+)</dt>
<dd style="margin-left: 8">Indicates that x uses the prefixed integer encoding defined in Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>, beginning with an A-bit prefix.</dd>
<dt>x &#8230;</dt>
<dd style="margin-left: 8">Indicates that x is variable-length and extends to the end of the region.</dd>
</dl>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#compression-process-overview" id="compression-process-overview">Compression Process Overview</a>
</h1>
<p id="rfc.section.2.p.1">Like HPACK, QPACK uses two tables for associating header fields to indices.  The static table (see <a href="#table-static" class="xref">Section 3.1</a>) is predefined and contains common header fields (some of them with an empty value).  The dynamic table (see <a href="#table-dynamic" class="xref">Section 3.2</a>) is built up over the course of the connection and can be used by the encoder to index header fields in the encoded header lists.</p>
<p id="rfc.section.2.p.2">QPACK defines unidirectional streams for sending instructions from encoder to decoder and vice versa.</p>
<h2 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#encoder" id="encoder">Encoder</a>
</h2>
<p id="rfc.section.2.1.p.1">An encoder converts a header list into a header block by emitting either an indexed or a literal representation for each header field in the list (see <a href="#header-block-representations" class="xref">Section 4.5</a>).  Indexed representations achieve high compression by replacing the literal name and possibly the value with an index to either the static or dynamic table.  References to the static table and literal representations do not require any dynamic state and never risk head-of-line blocking.  References to the dynamic table risk head-of-line blocking if the encoder has not received an acknowledgement indicating the entry is available at the decoder.</p>
<p id="rfc.section.2.1.p.2">An encoder MAY insert any entry in the dynamic table it chooses; it is not limited to header fields it is compressing.</p>
<p id="rfc.section.2.1.p.3">QPACK preserves the ordering of header fields within each header list.  An encoder MUST emit header field representations in the order they appear in the input header list.</p>
<p id="rfc.section.2.1.p.4">QPACK is designed to contain the more complex state tracking to the encoder, while the decoder is relatively simple.</p>
<h3 id="rfc.section.2.1.1">
<a href="#rfc.section.2.1.1">2.1.1.</a> <a href="#reference-tracking" id="reference-tracking">Reference Tracking</a>
</h3>
<p id="rfc.section.2.1.1.p.1">An encoder MUST ensure that a header block which references a dynamic table entry is not processed by the decoder after the referenced entry has been evicted.  Hence the encoder needs to track information about each compressed header block that references the dynamic table until that header block is acknowledged by the decoder (see <a href="#header-acknowledgement" class="xref">Section 4.4.1</a>).</p>
<h3 id="rfc.section.2.1.2">
<a href="#rfc.section.2.1.2">2.1.2.</a> <a href="#blocked-insertion" id="blocked-insertion">Blocked Dynamic Table Insertions</a>
</h3>
<p id="rfc.section.2.1.2.p.1">A dynamic table entry is considered blocking and cannot be evicted until its insertion has been acknowledged and there are no outstanding unacknowledged references to the entry.  In particular, a dynamic table entry that has never been referenced can still be blocking.</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">A blocking entry is unrelated to a blocked stream, which is a stream that a decoder cannot decode as a result of references to entries that are not yet available.  An encoder that uses the dynamic table has to keep track of blocked entries.</dd>
</dl>
<p id="rfc.section.2.1.2.p.3">An encoder MUST NOT insert an entry into the dynamic table (or duplicate an existing entry) if doing so would evict a blocking entry.</p>
<h4 id="rfc.section.2.1.2.1">
<a href="#rfc.section.2.1.2.1">2.1.2.1.</a> <a href="#avoiding-blocked-insertions" id="avoiding-blocked-insertions">Avoiding Blocked Insertions</a>
</h4>
<p id="rfc.section.2.1.2.1.p.1">To ensure that the encoder is not prevented from adding new entries, the encoder can avoid referencing entries that are close to eviction.  Rather than reference such an entry, the encoder can emit a Duplicate instruction (see <a href="#duplicate" class="xref">Section 4.3.4</a>), and reference the duplicate instead.</p>
<p id="rfc.section.2.1.2.1.p.2">Determining which entries are too close to eviction to reference is an encoder preference.  One heuristic is to target a fixed amount of available space in the dynamic table: either unused space or space that can be reclaimed by evicting non-blocking entries.  To achieve this, the encoder can maintain a draining index, which is the smallest absolute index (see <a href="#indexing" class="xref">Section 3.2.4</a>) in the dynamic table that it will emit a reference for.  As new entries are inserted, the encoder increases the draining index to maintain the section of the table that it will not reference.  If the encoder does not create new references to entries with an absolute index lower than the draining index, the number of unacknowledged references to those entries will eventually become zero, allowing them to be evicted.</p>
<div id="rfc.figure.1"></div>
<div id="fig-draining-index"></div>
<pre>
   +----------+---------------------------------+--------+
   | Draining |          Referenceable          | Unused |
   | Entries  |             Entries             | Space  |
   +----------+---------------------------------+--------+
   ^          ^                                 ^
   |          |                                 |
 Dropping    Draining Index               Insertion Point
  Point
</pre>
<p class="figure">Figure 1: Draining Dynamic Table Entries</p>
<h3 id="rfc.section.2.1.3">
<a href="#rfc.section.2.1.3">2.1.3.</a> <a href="#blocked-streams" id="blocked-streams">Blocked Streams</a>
</h3>
<p id="rfc.section.2.1.3.p.1">Because QUIC does not guarantee order between data on different streams, a decoder might encounter a header block that references a dynamic table entry that it has not yet received.</p>
<p id="rfc.section.2.1.3.p.2">Each header block contains a Required Insert Count (see <a href="#header-prefix" class="xref">Section 4.5.1</a>), the lowest possible value for the Insert Count with which the header block can be decoded. For a header block with references to the dynamic table, the Required Insert Count is one larger than the largest absolute index of all referenced dynamic table entries. For a header block with no references to the dynamic table, the Required Insert Count is zero.</p>
<p id="rfc.section.2.1.3.p.3">When the decoder receives a header block with a Required Insert Count greater than its own Insert Count, the stream cannot be processed immediately, and is considered &#8220;blocked&#8221; (see {blocked-decoding}).</p>
<p id="rfc.section.2.1.3.p.4">The SETTINGS_QPACK_BLOCKED_STREAMS setting (see <a href="#configuration" class="xref">Section 5</a>) specifies an upper bound on the number of streams which can be blocked. An encoder MUST limit the number of streams which could become blocked to the value of SETTINGS_QPACK_BLOCKED_STREAMS at all times. Note that the decoder might not become blocked on every stream which risks becoming blocked.</p>
<p id="rfc.section.2.1.3.p.5">An encoder can decide whether to risk having a stream become blocked. If permitted by the value of SETTINGS_QPACK_BLOCKED_STREAMS, compression efficiency can often be improved by referencing dynamic table entries that are still in transit, but if there is loss or reordering the stream can become blocked at the decoder.  An encoder avoids the risk of blocking by only referencing dynamic table entries which have been acknowledged, but this could mean using literals. Since literals make the header block larger, this can result in the encoder becoming blocked on congestion or flow control limits.</p>
<h3 id="rfc.section.2.1.4">
<a href="#rfc.section.2.1.4">2.1.4.</a> <a href="#known-received-count" id="known-received-count">Known Received Count</a>
</h3>
<p id="rfc.section.2.1.4.p.1">In order to identify which dynamic table entries can be safely used without a stream becoming blocked, the encoder tracks the number of entries received by the decoder.  The Known Received Count tracks the total number of acknowledged insertions.</p>
<p id="rfc.section.2.1.4.p.2">When blocking references are permitted, the encoder uses Header Acknowledgement instructions (<a href="#header-acknowledgement" class="xref">Section 4.4.1</a>) to maintain the Known Received Count.  If a header block was potentially blocking, the acknowledgement implies that the decoder has received all dynamic table state necessary to process the header block.  If the Required Insert Count of an acknowledged header block was greater than the encoder&#8217;s current Known Received Count, the block&#8217;s Required Insert Count becomes the new Known Received Count.</p>
<p id="rfc.section.2.1.4.p.3">To acknowledge dynamic table entries which are not referenced by header blocks, for example because the encoder or the decoder have chosen not to risk blocked streams, the decoder sends an Insert Count Increment instruction (see <a href="#insert-count-increment" class="xref">Section 4.4.3</a>).</p>
<h2 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#decoder" id="decoder">Decoder</a>
</h2>
<p id="rfc.section.2.2.p.1">As in HPACK, the decoder processes header blocks and emits the corresponding header lists. It also processes dynamic table modifications from encoder instructions received on the encoder stream.</p>
<p id="rfc.section.2.2.p.2">The decoder MUST emit header fields in the order their representations appear in the input header block.</p>
<h3 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#blocked-decoding" id="blocked-decoding">Blocked Decoding</a>
</h3>
<p id="rfc.section.2.2.1.p.1">Upon receipt of a header block, the decoder examines the Required Insert Count.  When the Required Insert Count is less than or equal to the decoder&#8217;s Insert Count, the header block can be processed immediately.  Otherwise, the stream on which the header block was received becomes blocked.</p>
<p id="rfc.section.2.2.1.p.2">While blocked, header block data SHOULD remain in the blocked stream&#8217;s flow control window.  A stream becomes unblocked when the Insert Count becomes greater than or equal to the Required Insert Count for all header blocks the decoder has started reading from the stream.  </p>
<p id="rfc.section.2.2.1.p.3">When processing header blocks, the decoder expects the Required Insert Count to exactly match the value defined in <a href="#blocked-streams" class="xref">Section 2.1.3</a>. If it encounters a smaller value than expected, it MUST treat this as a connection error of type HTTP_QPACK_DECOMPRESSION_FAILED (see <a href="#invalid-references" class="xref">Section 2.2.3</a>). If it encounters a larger value than expected, it MAY treat this as a connection error of type HTTP_QPACK_DECOMPRESSION_FAILED.</p>
<p id="rfc.section.2.2.1.p.4">If the decoder encounters more blocked streams than it promised to support, it MUST treat this as a connection error of type HTTP_QPACK_DECOMPRESSION_FAILED.</p>
<h3 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#state-synchronization" id="state-synchronization">State Synchronization</a>
</h3>
<p id="rfc.section.2.2.2.p.1">The decoder signals the following events by emitting decoder instructions (<a href="#decoder-instructions" class="xref">Section 4.4</a>) on the decoder stream.</p>
<h4 id="rfc.section.2.2.2.1">
<a href="#rfc.section.2.2.2.1">2.2.2.1.</a> <a href="#completed-processing-of-a-header-block" id="completed-processing-of-a-header-block">Completed Processing of a Header Block</a>
</h4>
<p id="rfc.section.2.2.2.1.p.1">When the decoder finishes decoding a header block containing dynamic table references, it emits a Header Acknowledgement instruction (<a href="#header-acknowledgement" class="xref">Section 4.4.1</a>).  A stream may carry multiple header blocks in the case of intermediate responses, trailers, and pushed requests.  The encoder interprets each Header Acknowledgement instruction as acknowledging the earliest unacknowledged header block containing dynamic table references sent on the given stream.</p>
<h4 id="rfc.section.2.2.2.2">
<a href="#rfc.section.2.2.2.2">2.2.2.2.</a> <a href="#abandonment-of-a-stream" id="abandonment-of-a-stream">Abandonment of a Stream</a>
</h4>
<p id="rfc.section.2.2.2.2.p.1">When an endpoint receives a stream reset before the end of a stream or before all header blocks are processed on that stream, or when it abandons reading of a stream, it generates a Stream Cancellation instruction (see <a href="#stream-cancellation" class="xref">Section 4.4.2</a>).  This signals to the encoder that all references to the dynamic table on that stream are no longer outstanding.  A decoder with a maximum dynamic table capacity equal to zero (see <a href="#maximum-dynamic-table-capacity" class="xref">Section 3.2.3</a>) MAY omit sending Stream Cancellations, because the encoder cannot have any dynamic table references.  An encoder cannot infer from this instruction that any updates to the dynamic table have been received.</p>
<p id="rfc.section.2.2.2.2.p.2">The Header Acknowledgement and Stream Cancellation instructions permit the encoder to remove references to entries in the dynamic table.  When entries have zero references they are no longer considered blocking (see <a href="#blocked-insertion" class="xref">Section 2.1.2</a>).</p>
<h4 id="rfc.section.2.2.2.3">
<a href="#rfc.section.2.2.2.3">2.2.2.3.</a> <a href="#new-table-entries" id="new-table-entries">New Table Entries</a>
</h4>
<p id="rfc.section.2.2.2.3.p.1">After receiving new table entries on the encoder stream, the decoder chooses when to emit Insert Count Increment instructions (see <a href="#insert-count-increment" class="xref">Section 4.4.3</a>). Emitting this instruction after adding each new dynamic table entry will provide the timeliest feedback to the encoder, but could be redundant with other decoder feedback. By delaying an Insert Count Increment instruction, the decoder might be able to coalesce multiple Insert Count Increment instructions, or replace them entirely with Header Acknowledgements (see <a href="#header-acknowledgement" class="xref">Section 4.4.1</a>). However, delaying too long may lead to compression inefficiencies if the encoder waits for an entry to be acknowledged before using it.</p>
<h3 id="rfc.section.2.2.3">
<a href="#rfc.section.2.2.3">2.2.3.</a> <a href="#invalid-references" id="invalid-references">Invalid References</a>
</h3>
<p id="rfc.section.2.2.3.p.1">If the decoder encounters a reference in a header block representation to a dynamic table entry which has already been evicted or which has an absolute index greater than or equal to the declared Required Insert Count (see <a href="#header-prefix" class="xref">Section 4.5.1</a>), it MUST treat this as a connection error of type <samp>HTTP_QPACK_DECOMPRESSION_FAILED</samp>.</p>
<p id="rfc.section.2.2.3.p.2">If the decoder encounters a reference in an encoder instruction to a dynamic table entry which has already been evicted, it MUST treat this as a connection error of type <samp>HTTP_QPACK_ENCODER_STREAM_ERROR</samp>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#header-tables" id="header-tables">Header Tables</a>
</h1>
<p id="rfc.section.3.p.1">Unlike in HPACK, entries in the QPACK static and dynamic tables are addressed separately.  The following sections describe how entries in each table are addressed.</p>
<h2 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#table-static" id="table-static">Static Table</a>
</h2>
<p id="rfc.section.3.1.p.1">The static table consists of a predefined static list of header fields, each of which has a fixed index over time.  Its entries are defined in <a href="#static-table" class="xref">Appendix A</a>.</p>
<p id="rfc.section.3.1.p.2">All entries in the static table have a name and a value.  However, values can be empty (that is, have a length of 0).  Each entry is identified by a unique index.</p>
<p id="rfc.section.3.1.p.3">Note the QPACK static table is indexed from 0, whereas the HPACK static table is indexed from 1.</p>
<p id="rfc.section.3.1.p.4">When the decoder encounters an invalid static table index in a header block representation it MUST treat this as a connection error of type <samp>HTTP_QPACK_DECOMPRESSION_FAILED</samp>.  If this index is received on the encoder stream, this MUST be treated as a connection error of type <samp>HTTP_QPACK_ENCODER_STREAM_ERROR</samp>.</p>
<h2 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#table-dynamic" id="table-dynamic">Dynamic Table</a>
</h2>
<p id="rfc.section.3.2.p.1">The dynamic table consists of a list of header fields maintained in first-in, first-out order. Each HTTP/3 endpoint holds a dynamic table that is initially empty.  Entries are added by encoder instructions received on the encoder stream (see <a href="#encoder-instructions" class="xref">Section 4.3</a>).</p>
<p id="rfc.section.3.2.p.2">The dynamic table can contain duplicate entries (i.e., entries with the same name and same value).  Therefore, duplicate entries MUST NOT be treated as an error by the decoder.</p>
<p id="rfc.section.3.2.p.3">Dynamic table entries can have empty values.</p>
<h3 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#dynamic-table-size" id="dynamic-table-size">Dynamic Table Size</a>
</h3>
<p id="rfc.section.3.2.1.p.1">The size of the dynamic table is the sum of the size of its entries.</p>
<p id="rfc.section.3.2.1.p.2">The size of an entry is the sum of its name&#8217;s length in bytes (as defined in <a href="#string-literals" class="xref">Section 4.1.2</a>), its value&#8217;s length in bytes, and 32.</p>
<p id="rfc.section.3.2.1.p.3">The size of an entry is calculated using the length of its name and value without Huffman encoding applied.</p>
<h3 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#eviction" id="eviction">Dynamic Table Capacity and Eviction</a>
</h3>
<p id="rfc.section.3.2.2.p.1">The encoder sets the capacity of the dynamic table, which serves as the upper limit on its size.  The initial capacity of the dynamic table is zero.  The encoder sends a Set Dynamic Table Capacity instruction (<a href="#set-dynamic-capacity" class="xref">Section 4.3.1</a>) with a non-zero capacity to begin using the dynamic table.</p>
<p id="rfc.section.3.2.2.p.2">Before a new entry is added to the dynamic table, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to (table capacity - size of new entry). The encoder MUST NOT evict a blocking dynamic table entry (see <a href="#blocked-insertion" class="xref">Section 2.1.2</a>).  The entry is then added to the table.  It is an error if the encoder attempts to add an entry that is larger than the dynamic table capacity; the decoder MUST treat this as a connection error of type <samp>HTTP_QPACK_ENCODER_STREAM_ERROR</samp>.</p>
<p id="rfc.section.3.2.2.p.3">A new entry can reference an entry in the dynamic table that will be evicted when adding this new entry into the dynamic table.  Implementations are cautioned to avoid deleting the referenced name or value if the referenced entry is evicted from the dynamic table prior to inserting the new entry.</p>
<p id="rfc.section.3.2.2.p.4">Whenever the dynamic table capacity is reduced by the encoder (see <a href="#set-dynamic-capacity" class="xref">Section 4.3.1</a>), entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to the new table capacity.  This mechanism can be used to completely clear entries from the dynamic table by setting a capacity of 0, which can subsequently be restored.</p>
<h3 id="rfc.section.3.2.3">
<a href="#rfc.section.3.2.3">3.2.3.</a> <a href="#maximum-dynamic-table-capacity" id="maximum-dynamic-table-capacity">Maximum Dynamic Table Capacity</a>
</h3>
<p id="rfc.section.3.2.3.p.1">To bound the memory requirements of the decoder, the decoder limits the maximum value the encoder is permitted to set for the dynamic table capacity.  In HTTP/3, this limit is determined by the value of SETTINGS_QPACK_MAX_TABLE_CAPACITY sent by the decoder (see <a href="#configuration" class="xref">Section 5</a>).  The encoder MUST not set a dynamic table capacity that exceeds this maximum, but it can choose to use a lower dynamic table capacity (see <a href="#set-dynamic-capacity" class="xref">Section 4.3.1</a>).</p>
<p id="rfc.section.3.2.3.p.2">For clients using 0-RTT data in HTTP/3, the server&#8217;s maximum table capacity is the remembered value of the setting, or zero if the value was not previously sent.  When the client&#8217;s 0-RTT value of the SETTING is 0, the server MAY set it to a non-zero value in its SETTINGS frame. If the remembered value is non-zero, the server MUST send the same non-zero value in its SETTINGS frame.  If it specifies any other value, or omits SETTINGS_QPACK_MAX_TABLE_CAPACITY from SETTINGS, the encoder must treat this as a connection error of type <samp>HTTP_QPACK_DECODER_STREAM_ERROR</samp>.</p>
<p id="rfc.section.3.2.3.p.3">For HTTP/3 servers and HTTP/3 clients when 0-RTT is not attempted or is rejected, the maximum table capacity is 0 until the encoder processes a SETTINGS frame with a non-zero value of SETTINGS_QPACK_MAX_TABLE_CAPACITY.</p>
<p id="rfc.section.3.2.3.p.4">When the maximum table capacity is 0, the encoder MUST NOT insert entries into the dynamic table, and MUST NOT send any encoder instructions on the encoder stream.</p>
<h3 id="rfc.section.3.2.4">
<a href="#rfc.section.3.2.4">3.2.4.</a> <a href="#indexing" id="indexing">Absolute Indexing</a>
</h3>
<p id="rfc.section.3.2.4.p.1">Each entry possesses both an absolute index which is fixed for the lifetime of that entry and a relative index which changes based on the context of the reference. The first entry inserted has an absolute index of &#8220;0&#8221;; indices increase by one with each insertion.</p>
<h3 id="rfc.section.3.2.5">
<a href="#rfc.section.3.2.5">3.2.5.</a> <a href="#relative-indexing" id="relative-indexing">Relative Indexing</a>
</h3>
<p id="rfc.section.3.2.5.p.1">Relative indices begin at zero and increase in the opposite direction from the absolute index.  Determining which entry has a relative index of &#8220;0&#8221; depends on the context of the reference.</p>
<p id="rfc.section.3.2.5.p.2">In encoder instructions, a relative index of &#8220;0&#8221; always refers to the most recently inserted value in the dynamic table.  Note that this means the entry referenced by a given relative index will change while interpreting instructions on the encoder stream.</p>
<pre>
      +-----+---------------+-------+
      | n-1 |      ...      |   d   |  Absolute Index
      + - - +---------------+ - - - +
      |  0  |      ...      | n-d-1 |  Relative Index
      +-----+---------------+-------+
      ^                             |
      |                             V
Insertion Point               Dropping Point

n = count of entries inserted
d = count of entries dropped
</pre>
<p class="figure">Example Dynamic Table Indexing - Encoder Stream</p>
<p id="rfc.section.3.2.5.p.3">Unlike encoder instructions, relative indices in header block representations are relative to the Base at the beginning of the header block (see <a href="#header-prefix" class="xref">Section 4.5.1</a>). This ensures that references are stable even if header blocks and dynamic table updates are processed out of order.</p>
<p id="rfc.section.3.2.5.p.4">In a header block a relative index of &#8220;0&#8221; refers to the entry with absolute index equal to Base - 1.</p>
<pre>
 Required
  Insert
  Count        Base
    |           |
    V           V
    +-----+-----+-----+-----+-------+
    | n-1 | n-2 | n-3 | ... |   d   |  Absolute Index
    +-----+-----+  -  +-----+   -   +
                |  0  | ... | n-d-3 |  Relative Index
                +-----+-----+-------+

n = count of entries inserted
d = count of entries dropped
</pre>
<p class="figure">Example Dynamic Table Indexing - Relative Index in Header Block</p>
<h3 id="rfc.section.3.2.6">
<a href="#rfc.section.3.2.6">3.2.6.</a> <a href="#post-base" id="post-base">Post-Base Indexing</a>
</h3>
<p id="rfc.section.3.2.6.p.1">Post-Base indices are used for entries with absolute indexes greater than or equal to Base, starting at 0 for the entry with absolute index equal to Base, and increasing in the same direction as the absolute index.</p>
<p id="rfc.section.3.2.6.p.2">Post-Base indices allow an encoder to process a header block in a single pass and include references to entries added while processing this (or other) header blocks.</p>
<pre>
               Base
                |
                V
    +-----+-----+-----+-----+-----+
    | n-1 | n-2 | n-3 | ... |  d  |  Absolute Index
    +-----+-----+-----+-----+-----+
    |  1  |  0  |                    Post-Base Index
    +-----+-----+

n = count of entries inserted
d = count of entries dropped
</pre>
<p class="figure">Example Dynamic Table Indexing - Post-Base Index in Header Block</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#wire-format" id="wire-format">Wire Format</a>
</h1>
<h2 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#primitives" id="primitives">Primitives</a>
</h2>
<h3 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#prefixed-integers" id="prefixed-integers">Prefixed Integers</a>
</h3>
<p id="rfc.section.4.1.1.p.1">The prefixed integer from Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a> is used heavily throughout this document.  The format from <a href="#RFC7541" class="xref">[RFC7541]</a> is used unmodified.  QPACK implementations MUST be able to decode integers up to 62 bits long.</p>
<h3 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#string-literals" id="string-literals">String Literals</a>
</h3>
<p id="rfc.section.4.1.2.p.1">The string literal defined by Section 5.2 of <a href="#RFC7541" class="xref">[RFC7541]</a> is also used throughout.  This string format includes optional Huffman encoding.</p>
<p id="rfc.section.4.1.2.p.2">HPACK defines string literals to begin on a byte boundary.  They begin with a single flag (indicating whether the string is Huffman-coded), followed by the Length encoded as a 7-bit prefix integer, and finally Length bytes of data.  When Huffman encoding is enabled, the Huffman table from Appendix B of <a href="#RFC7541" class="xref">[RFC7541]</a> is used without modification.</p>
<p id="rfc.section.4.1.2.p.3">This document expands the definition of string literals and permits them to begin other than on a byte boundary.  An &#8220;N-bit prefix string literal&#8221; begins with the same Huffman flag, followed by the length encoded as an (N-1)-bit prefix integer.  The remainder of the string literal is unmodified.</p>
<p id="rfc.section.4.1.2.p.4">A string literal without a prefix length noted is an 8-bit prefix string literal and follows the definitions in <a href="#RFC7541" class="xref">[RFC7541]</a> without modification.</p>
<h2 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#enc-dec-stream-def" id="enc-dec-stream-def">Encoder and Decoder Streams</a>
</h2>
<p id="rfc.section.4.2.p.1">QPACK defines two unidirectional stream types:</p>
<p></p>

<ul>
<li>An encoder stream is a unidirectional stream of type <samp>0x02</samp>.  It carries an unframed sequence of encoder instructions from encoder to decoder.</li>
<li>A decoder stream is a unidirectional stream of type <samp>0x03</samp>.  It carries an unframed sequence of decoder instructions from decoder to encoder.</li>
</ul>
<p id="rfc.section.4.2.p.3">HTTP/3 endpoints contain a QPACK encoder and decoder. Each endpoint MUST initiate at most one encoder stream and at most one decoder stream. Receipt of a second instance of either stream type MUST be treated as a connection error of type HTTP_WRONG_STREAM_COUNT. These streams MUST NOT be closed. Closure of either unidirectional stream type MUST be treated as a connection error of type HTTP_CLOSED_CRITICAL_STREAM.</p>
<p id="rfc.section.4.2.p.4">An endpoint MAY avoid creating its own encoder stream if it&#8217;s not going to be used (for example if the endpoint doesn&#8217;t wish to use the dynamic table, or if the maximum size of the dynamic table permitted by the peer is zero).</p>
<p id="rfc.section.4.2.p.5">An endpoint MAY avoid creating its own decoder stream if the maximum size of its own dynamic table is zero.</p>
<p id="rfc.section.4.2.p.6">An endpoint MUST allow its peer to create both encoder and decoder streams even if the connection&#8217;s settings prevent their use.</p>
<h2 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#encoder-instructions" id="encoder-instructions">Encoder Instructions</a>
</h2>
<p id="rfc.section.4.3.p.1">An encoder sends encoder instructions on the encoder stream to set the capacity of the dynamic table and add dynamic table entries.  Instructions adding table entries can use existing entries to avoid transmitting redundant information.  The name can be transmitted as a reference to an existing entry in the static or the dynamic table or as a string literal.  For entries which already exist in the dynamic table, the full entry can also be used by reference, creating a duplicate entry.</p>
<p id="rfc.section.4.3.p.2">This section specifies the following encoder instructions.</p>
<h3 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#set-dynamic-capacity" id="set-dynamic-capacity">Set Dynamic Table Capacity</a>
</h3>
<p id="rfc.section.4.3.1.p.1">An encoder informs the decoder of a change to the dynamic table capacity using an instruction which begins with the &#8216;001&#8217; three-bit pattern.  The new dynamic table capacity is represented as an integer with a 5-bit prefix (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>).</p>
<div id="rfc.figure.2"></div>
<div id="fig-set-capacity"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |   Capacity (5+)   |
+---+---+---+-------------------+
</pre>
<p class="figure">Figure 2: Set Dynamic Table Capacity</p>
<p id="rfc.section.4.3.1.p.2">The new capacity MUST be lower than or equal to the limit described in <a href="#maximum-dynamic-table-capacity" class="xref">Section 3.2.3</a>.  In HTTP/3, this limit is the value of the SETTINGS_QPACK_MAX_TABLE_CAPACITY parameter (see <a href="#configuration" class="xref">Section 5</a>) received from the decoder.  The decoder MUST treat a new dynamic table capacity value that exceeds this limit as a connection error of type <samp>HTTP_QPACK_ENCODER_STREAM_ERROR</samp>.</p>
<p id="rfc.section.4.3.1.p.3">Reducing the dynamic table capacity can cause entries to be evicted (see <a href="#eviction" class="xref">Section 3.2.2</a>).  This MUST NOT cause the eviction of blocking entries (see <a href="#blocked-insertion" class="xref">Section 2.1.2</a>).  Changing the capacity of the dynamic table is not acknowledged as this instruction does not insert an entry.</p>
<h3 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> <a href="#insert-with-name-reference" id="insert-with-name-reference">Insert With Name Reference</a>
</h3>
<p id="rfc.section.4.3.2.p.1">An encoder adds an entry to the dynamic table where the header field name matches the header field name of an entry stored in the static or the dynamic table using an instruction that starts with the &#8216;1&#8217; one-bit pattern.  The second (<samp>S</samp>) bit indicates whether the reference is to the static or dynamic table. The 6-bit prefix integer (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>) that follows is used to locate the table entry for the header name.  When S=1, the number represents the static table index; when S=0, the number is the relative index of the entry in the dynamic table.</p>
<p id="rfc.section.4.3.2.p.2">The header name reference is followed by the header field value represented as a string literal (see Section 5.2 of <a href="#RFC7541" class="xref">[RFC7541]</a>).</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 | S |    Name Index (6+)    |
   +---+---+-----------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   |  Value String (Length bytes)  |
   +-------------------------------+
</pre>
<p class="figure">Insert Header Field -- Indexed Name</p>
<h3 id="rfc.section.4.3.3">
<a href="#rfc.section.4.3.3">4.3.3.</a> <a href="#insert-without-name-reference" id="insert-without-name-reference">Insert Without Name Reference</a>
</h3>
<p id="rfc.section.4.3.3.p.1">An encoder adds an entry to the dynamic table where both the header field name and the header field value are represented as string literals (see <a href="#primitives" class="xref">Section 4.1</a>) using an instruction that starts with the &#8216;01&#8217; two-bit pattern.</p>
<p id="rfc.section.4.3.3.p.2">The name is represented as a 6-bit prefix string literal, while the value is represented as an 8-bit prefix string literal.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | H | Name Length (5+)  |
   +---+---+---+-------------------+
   |  Name String (Length bytes)   |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   |  Value String (Length bytes)  |
   +-------------------------------+
</pre>
<p class="figure">Insert Header Field -- New Name</p>
<h3 id="rfc.section.4.3.4">
<a href="#rfc.section.4.3.4">4.3.4.</a> <a href="#duplicate" id="duplicate">Duplicate</a>
</h3>
<p id="rfc.section.4.3.4.p.1">An encoder duplicates an existing entry in the dynamic table using an instruction that starts with the &#8216;000&#8217; three-bit pattern.  The relative index of the existing entry is represented as an integer with a 5-bit prefix.</p>
<div id="rfc.figure.3"></div>
<div id="fig-index-with-duplication"></div>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 0 |    Index (5+)     |
   +---+---+---+-------------------+
</pre>
<p class="figure">Figure 3: Duplicate</p>
<p id="rfc.section.4.3.4.p.2">The existing entry is re-inserted into the dynamic table without resending either the name or the value. This is useful to mitigate the eviction of older entries which are frequently referenced, both to avoid the need to resend the header and to avoid the entry in the table blocking the ability to insert new headers.</p>
<h2 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#decoder-instructions" id="decoder-instructions">Decoder Instructions</a>
</h2>
<p id="rfc.section.4.4.p.1">Decoder instructions provide information used to ensure consistency of the dynamic table. They are sent from the decoder to the encoder on a decoder stream; that is, the server informs the client about the processing of the client&#8217;s header blocks and table updates, and the client informs the server about the processing of the server&#8217;s header blocks and table updates.</p>
<p id="rfc.section.4.4.p.2">This section specifies the following decoder instructions.</p>
<h3 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#header-acknowledgement" id="header-acknowledgement">Header Acknowledgement</a>
</h3>
<p id="rfc.section.4.4.1.p.1">After processing a header block whose declared Required Insert Count is not zero, the decoder emits a Header Acknowledgement instruction.  The instruction begins with the &#8216;1&#8217; one-bit pattern and includes the header block&#8217;s associated stream ID, encoded as a 7-bit prefix integer.  It is used by the peer&#8217;s encoder to know when it is safe to evict an entry (<a href="#blocked-insertion" class="xref">Section 2.1.2</a>), and possibly update the Known Received Count (<a href="#known-received-count" class="xref">Section 2.1.4</a>).</p>
<div id="rfc.figure.4"></div>
<div id="fig-header-ack"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |      Stream ID (7+)       |
+---+---------------------------+
</pre>
<p class="figure">Figure 4: Header Acknowledgement</p>
<p id="rfc.section.4.4.1.p.2">If an encoder receives a Header Acknowledgement instruction referring to a stream on which every header block with a non-zero Required Insert Count has already been acknowledged, that MUST be treated as a connection error of type <samp>HTTP_QPACK_DECODER_STREAM_ERROR</samp>.</p>
<h3 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> <a href="#stream-cancellation" id="stream-cancellation">Stream Cancellation</a>
</h3>
<p id="rfc.section.4.4.2.p.1">When a stream is reset or reading is abandoned, the decoder emits a Stream Cancellation instruction. The instruction begins with the &#8216;01&#8217; two-bit pattern. The instruction includes the stream ID of the affected stream encoded as a 6-bit prefix integer.  See <a href="#state-synchronization" class="xref">Section 2.2.2</a>.</p>
<div id="rfc.figure.5"></div>
<div id="fig-stream-cancel"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |     Stream ID (6+)    |
+---+---+-----------------------+
</pre>
<p class="figure">Figure 5: Stream Cancellation</p>
<h3 id="rfc.section.4.4.3">
<a href="#rfc.section.4.4.3">4.4.3.</a> <a href="#insert-count-increment" id="insert-count-increment">Insert Count Increment</a>
</h3>
<p id="rfc.section.4.4.3.p.1">The Insert Count Increment instruction begins with the &#8216;00&#8217; two-bit pattern.  The instruction specifies the total number of dynamic table inserts and duplications since the last Insert Count Increment or Header Acknowledgement that increased the Known Received Count for the dynamic table (see <a href="#known-received-count" class="xref">Section 2.1.4</a>).  The Increment field is encoded as a 6-bit prefix integer. The encoder uses this value to determine which table entries might cause a stream to become blocked, as described in <a href="#state-synchronization" class="xref">Section 2.2.2</a>.</p>
<div id="rfc.figure.6"></div>
<div id="fig-size-sync"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |     Increment (6+)    |
+---+---+-----------------------+
</pre>
<p class="figure">Figure 6: Insert Count Increment</p>
<p id="rfc.section.4.4.3.p.2">An encoder that receives an Increment field equal to zero or one that increases the Known Received Count beyond what the encoder has sent MUST treat this as a connection error of type <samp>HTTP_QPACK_DECODER_STREAM_ERROR</samp>.</p>
<h2 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#header-block-representations" id="header-block-representations">Header Block Representations</a>
</h2>
<p id="rfc.section.4.5.p.1">Header blocks contain compressed representations of header lists and are carried in frames on streams defined by the enclosing protocol.  These representations reference the static table, or dynamic table in a particular state without modifying it.</p>
<h3 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> <a href="#header-prefix" id="header-prefix">Header Block Prefix</a>
</h3>
<p id="rfc.section.4.5.1.p.1">Each header block is prefixed with two integers.  The Required Insert Count is encoded as an integer with an 8-bit prefix after the encoding described in <a href="#ric" class="xref">Section 4.5.1.1</a>).  The Base is encoded as sign-and-modulus integer, using a single sign bit and a value with a 7-bit prefix (see <a href="#base" class="xref">Section 4.5.1.2</a>).</p>
<p id="rfc.section.4.5.1.p.2">These two values are followed by representations for compressed headers.</p>
<div id="rfc.figure.7"></div>
<div id="fig-base-index"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|   Required Insert Count (8+)  |
+---+---------------------------+
| S |      Delta Base (7+)      |
+---+---------------------------+
|      Compressed Headers     ...
+-------------------------------+
</pre>
<p class="figure">Figure 7: Header Block</p>
<h4 id="rfc.section.4.5.1.1">
<a href="#rfc.section.4.5.1.1">4.5.1.1.</a> <a href="#ric" id="ric">Required Insert Count</a>
</h4>
<p id="rfc.section.4.5.1.1.p.1">Required Insert Count identifies the state of the dynamic table needed to process the header block.  Blocking decoders use the Required Insert Count to determine when it is safe to process the rest of the block.</p>
<p id="rfc.section.4.5.1.1.p.2">The encoder transforms the Required Insert Count as follows before encoding:</p>
<pre>
   if ReqInsertCount == 0:
      EncInsertCount = 0
   else:
      EncInsertCount = (ReqInsertCount mod (2 * MaxEntries)) + 1
</pre>
<p id="rfc.section.4.5.1.1.p.3">Here <samp>MaxEntries</samp> is the maximum number of entries that the dynamic table can have.  The smallest entry has empty name and value strings and has the size of 32.  Hence <samp>MaxEntries</samp> is calculated as</p>
<pre>
   MaxEntries = floor( MaxTableCapacity / 32 )
</pre>
<p><samp>MaxTableCapacity</samp> is the maximum capacity of the dynamic table as specified by the decoder (see <a href="#maximum-dynamic-table-capacity" class="xref">Section 3.2.3</a>).</p>
<p id="rfc.section.4.5.1.1.p.5">This encoding limits the length of the prefix on long-lived connections.</p>
<p id="rfc.section.4.5.1.1.p.6">The decoder can reconstruct the Required Insert Count using an algorithm such as the following.  If the decoder encounters a value of EncodedInsertCount that could not have been produced by a conformant encoder, it MUST treat this as a connection error of type <samp>HTTP_QPACK_DECOMPRESSION_FAILED</samp>.</p>
<p id="rfc.section.4.5.1.1.p.7">TotalNumberOfInserts is the total number of inserts into the decoder&#8217;s dynamic table.</p>
<pre>
   FullRange = 2 * MaxEntries
   if EncodedInsertCount == 0:
      ReqInsertCount = 0
   else:
      if EncodedInsertCount &gt; FullRange:
         Error
      MaxValue = TotalNumberOfInserts + MaxEntries

      # MaxWrapped is the largest possible value of
      # ReqInsertCount that is 0 mod 2*MaxEntries
      MaxWrapped = floor(MaxValue / FullRange) * FullRange
      ReqInsertCount = MaxWrapped + EncodedInsertCount - 1

      # If ReqInsertCount exceeds MaxValue, the Encoder's value
      # must have wrapped one fewer time
      if ReqInsertCount &gt; MaxValue:
         if ReqInsertCount &lt; FullRange:
            Error
         ReqInsertCount -= FullRange
</pre>
<p id="rfc.section.4.5.1.1.p.8">For example, if the dynamic table is 100 bytes, then the Required Insert Count will be encoded modulo 6.  If a decoder has received 10 inserts, then an encoded value of 3 indicates that the Required Insert Count is 9 for the header block.</p>
<h4 id="rfc.section.4.5.1.2">
<a href="#rfc.section.4.5.1.2">4.5.1.2.</a> <a href="#base" id="base">Base</a>
</h4>
<p id="rfc.section.4.5.1.2.p.1">The <samp>Base</samp> is used to resolve references in the dynamic table as described in <a href="#relative-indexing" class="xref">Section 3.2.5</a>.</p>
<p id="rfc.section.4.5.1.2.p.2">To save space, the Base is encoded relative to the Insert Count using a one-bit sign and the <samp>Delta Base</samp> value.  A sign bit of 0 indicates that the Base is greater than or equal to the value of the Insert Count; the value of Delta Base is added to the Insert Count to determine the value of the Base.  A sign bit of 1 indicates that the Base is less than the Insert Count.  That is:</p>
<pre>
   if S == 0:
      Base = ReqInsertCount + DeltaBase
   else:
      Base = ReqInsertCount - DeltaBase - 1
</pre>
<p id="rfc.section.4.5.1.2.p.3">A single-pass encoder determines the Base before encoding a header block.  If the encoder inserted entries in the dynamic table while encoding the header block, Required Insert Count will be greater than the Base, so the encoded difference is negative and the sign bit is set to 1.  If the header block did not reference the most recent entry in the table and did not insert any new entries, the Base will be greater than the Required Insert Count, so the delta will be positive and the sign bit is set to 0.</p>
<p id="rfc.section.4.5.1.2.p.4">An encoder that produces table updates before encoding a header block might set Required Insert Count and the Base to the same value.  In such case, both the sign bit and the Delta Base will be set to zero.</p>
<p id="rfc.section.4.5.1.2.p.5">A header block that does not reference the dynamic table can use any value for the Base; setting Delta Base to zero is the most efficient encoding.</p>
<p id="rfc.section.4.5.1.2.p.6">For example, with a Required Insert Count of 9, a decoder receives a S bit of 1 and a Delta Base of 2.  This sets the Base to 6 and enables post-base indexing for three entries.  In this example, a regular index of 1 refers to the 5th entry that was added to the table; a post-base index of 1 refers to the 8th entry.</p>
<h3 id="rfc.section.4.5.2">
<a href="#rfc.section.4.5.2">4.5.2.</a> <a href="#indexed-header-field" id="indexed-header-field">Indexed Header Field</a>
</h3>
<p id="rfc.section.4.5.2.p.1">An indexed header field representation identifies an entry in either the static table or the dynamic table and causes that header field to be added to the decoded header list, as described in Section 3.2 of <a href="#RFC7541" class="xref">[RFC7541]</a>.  </p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 | S |      Index (6+)       |
+---+---+-----------------------+
</pre>
<p class="figure">Indexed Header Field</p>
<p id="rfc.section.4.5.2.p.2">If the entry is in the static table, or in the dynamic table with an absolute index less than the Base, this representation starts with the &#8216;1&#8217; 1-bit pattern, followed by the <samp>S</samp> bit indicating whether the reference is into the static or dynamic table.  The 6-bit prefix integer (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>) that follows is used to locate the table entry for the header name.  When S=1, the number represents the static table index; when S=0, the number is the relative index of the entry in the dynamic table.</p>
<h3 id="rfc.section.4.5.3">
<a href="#rfc.section.4.5.3">4.5.3.</a> <a href="#indexed-header-field-with-post-base-index" id="indexed-header-field-with-post-base-index">Indexed Header Field With Post-Base Index</a>
</h3>
<p id="rfc.section.4.5.3.p.1">If the entry is in the dynamic table with an absolute index greater than or equal to the Base, the representation starts with the &#8216;0001&#8217; 4-bit pattern, followed by the post-base index (see <a href="#post-base" class="xref">Section 3.2.6</a>) of the matching header field, represented as an integer with a 4-bit prefix (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>).</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |  Index (4+)   |
+---+---+---+---+---------------+
</pre>
<p class="figure">Indexed Header Field with Post-Base Index</p>
<h3 id="rfc.section.4.5.4">
<a href="#rfc.section.4.5.4">4.5.4.</a> <a href="#literal-name-reference" id="literal-name-reference">Literal Header Field With Name Reference</a>
</h3>
<p id="rfc.section.4.5.4.p.1">A literal header field with a name reference represents a header where the header field name matches the header field name of an entry stored in the static table or the dynamic table.</p>
<p id="rfc.section.4.5.4.p.2">If the entry is in the static table, or in the dynamic table with an absolute index less than the Base, this representation starts with the &#8216;01&#8217; two-bit pattern.</p>
<p id="rfc.section.4.5.4.p.3">Only the header field name stored in the static or dynamic table is used. Any header field value MUST be ignored.</p>
<p id="rfc.section.4.5.4.p.4">The following bit, &#8216;N&#8217;, indicates whether an intermediary is permitted to add this header to the dynamic header table on subsequent hops. When the &#8216;N&#8217; bit is set, the encoded header MUST always be encoded with a literal representation. In particular, when a peer sends a header field that it received represented as a literal header field with the &#8216;N&#8217; bit set, it MUST use a literal representation to forward this header field.  This bit is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1 of <a href="#RFC7541" class="xref">[RFC7541]</a> for more details).</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | N | S |Name Index (4+)|
   +---+---+---+---+---------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   |  Value String (Length bytes)  |
   +-------------------------------+
</pre>
<p class="figure">Literal Header Field With Name Reference</p>
<p id="rfc.section.4.5.4.p.5">The fourth (<samp>S</samp>) bit indicates whether the reference is to the static or dynamic table.  The 4-bit prefix integer (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>) that follows is used to locate the table entry for the header name.  When S=1, the number represents the static table index; when S=0, the number is the relative index of the entry in the dynamic table.</p>
<h3 id="rfc.section.4.5.5">
<a href="#rfc.section.4.5.5">4.5.5.</a> <a href="#literal-header-field-with-post-base-name-reference" id="literal-header-field-with-post-base-name-reference">Literal Header Field With Post-Base Name Reference</a>
</h3>
<p id="rfc.section.4.5.5.p.1">If the name entry is in the dynamic table with an absolute index greater than or equal to the Base, the representation starts with the &#8216;0000&#8217; four-bit pattern. The fifth bit is the &#8216;N&#8217; bit as described in <a href="#literal-name-reference" class="xref">Section 4.5.4</a>.  Finally, the header field name is represented using the post-base index of that entry (see <a href="#post-base" class="xref">Section 3.2.6</a>) encoded as an integer with a 3-bit prefix.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 0 | 0 | N |NameIdx(3+)|
   +---+---+---+---+---+-----------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   |  Value String (Length bytes)  |
   +-------------------------------+
</pre>
<p class="figure">Literal Header Field With Post-Base Name Reference</p>
<h3 id="rfc.section.4.5.6">
<a href="#rfc.section.4.5.6">4.5.6.</a> <a href="#literal-header-field-without-name-reference" id="literal-header-field-without-name-reference">Literal Header Field Without Name Reference</a>
</h3>
<p id="rfc.section.4.5.6.p.1">An addition to the header table where both the header field name and the header field value are represented as string literals (see <a href="#primitives" class="xref">Section 4.1</a>) starts with the &#8216;001&#8217; three-bit pattern.</p>
<p id="rfc.section.4.5.6.p.2">The fourth bit, &#8216;N&#8217;, indicates whether an intermediary is permitted to add this header to the dynamic header table on subsequent hops. When the &#8216;N&#8217; bit is set, the encoded header MUST always be encoded with a literal representation. In particular, when a peer sends a header field that it received represented as a literal header field with the &#8216;N&#8217; bit set, it MUST use a literal representation to forward this header field.  This bit is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1 of <a href="#RFC7541" class="xref">[RFC7541]</a> for more details).</p>
<p id="rfc.section.4.5.6.p.3">The name is represented as a 4-bit prefix string literal, while the value is represented as an 8-bit prefix string literal.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 1 | N | H |NameLen(3+)|
   +---+---+---+---+---+-----------+
   |  Name String (Length bytes)   |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   |  Value String (Length bytes)  |
   +-------------------------------+
</pre>
<p class="figure">Literal Header Field Without Name Reference</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#configuration" id="configuration">Configuration</a>
</h1>
<p id="rfc.section.5.p.1">QPACK defines two settings which are included in the HTTP/3 SETTINGS frame.</p>
<p></p>

<dl>
<dt>SETTINGS_QPACK_MAX_TABLE_CAPACITY (0x1):</dt>
<dd style="margin-left: 8">The default value is zero.  See <a href="#table-dynamic" class="xref">Section 3.2</a> for usage.  This is the equivalent of the SETTINGS_HEADER_TABLE_SIZE from HTTP/2.</dd>
<dt>SETTINGS_QPACK_BLOCKED_STREAMS (0x7):</dt>
<dd style="margin-left: 8">The default value is zero.  See <a href="#blocked-streams" class="xref">Section 2.1.3</a>.</dd>
</dl>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#error-handling" id="error-handling">Error Handling</a>
</h1>
<p id="rfc.section.6.p.1">The following error codes are defined for HTTP/3 to indicate failures of QPACK which prevent the connection from continuing:</p>
<p></p>

<dl>
<dt>HTTP_QPACK_DECOMPRESSION_FAILED (0x200):</dt>
<dd style="margin-left: 8">The decoder failed to interpret a header block and is not able to continue decoding that header block.</dd>
<dt>HTTP_QPACK_ENCODER_STREAM_ERROR (0x201):</dt>
<dd style="margin-left: 8">The decoder failed to interpret an encoder instruction received on the encoder stream.</dd>
<dt>HTTP_QPACK_DECODER_STREAM_ERROR (0x202):</dt>
<dd style="margin-left: 8">The encoder failed to interpret a decoder instruction received on the decoder stream.</dd>
</dl>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.7.p.1">TBD.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<h2 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#settings-registration" id="settings-registration">Settings Registration</a>
</h2>
<p id="rfc.section.8.1.p.1">This document specifies two settings. The entries in the following table are registered in the &#8220;HTTP/3 Settings&#8221; registry established in <a href="#HTTP3" class="xref">[HTTP3]</a>.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Setting Name</th>
<th class="center">Code</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">QPACK_MAX_TABLE_CAPACITY</td>
<td class="center">0x1</td>
<td class="left"><a href="#configuration" class="xref">Section 5</a></td>
</tr>
<tr>
<td class="left">QPACK_BLOCKED_STREAMS</td>
<td class="center">0x7</td>
<td class="left"><a href="#configuration" class="xref">Section 5</a></td>
</tr>
</tbody>
</table>
<h2 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#stream-type-registration" id="stream-type-registration">Stream Type Registration</a>
</h2>
<p id="rfc.section.8.2.p.1">This document specifies two stream types. The entries in the following table are registered in the &#8220;HTTP/3 Stream Type&#8221; registry established in <a href="#HTTP3" class="xref">[HTTP3]</a>.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Stream Type</th>
<th class="center">Code</th>
<th class="left">Specification</th>
<th class="left">Sender</th>
</tr></thead>
<tbody>
<tr>
<td class="left">QPACK Encoder Stream</td>
<td class="center">0x02</td>
<td class="left"><a href="#enc-dec-stream-def" class="xref">Section 4.2</a></td>
<td class="left">Both</td>
</tr>
<tr>
<td class="left">QPACK Decoder Stream</td>
<td class="center">0x03</td>
<td class="left"><a href="#enc-dec-stream-def" class="xref">Section 4.2</a></td>
<td class="left">Both</td>
</tr>
</tbody>
</table>
<h2 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#error-code-registration" id="error-code-registration">Error Code Registration</a>
</h2>
<p id="rfc.section.8.3.p.1">This document specifies three error codes. The entries in the following table are registered in the &#8220;HTTP/3 Error Code&#8221; registry established in <a href="#HTTP3" class="xref">[HTTP3]</a>.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Name</th>
<th class="left">Code</th>
<th class="left">Description</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">HTTP_QPACK_DECOMPRESSION_FAILED</td>
<td class="left">0x200</td>
<td class="left">Decompression of a header block failed</td>
<td class="left"><a href="#error-handling" class="xref">Section 6</a></td>
</tr>
<tr>
<td class="left">HTTP_QPACK_ENCODER_STREAM_ERROR</td>
<td class="left">0x201</td>
<td class="left">Error on the encoder stream</td>
<td class="left"><a href="#error-handling" class="xref">Section 6</a></td>
</tr>
<tr>
<td class="left">HTTP_QPACK_DECODER_STREAM_ERROR</td>
<td class="left">0x202</td>
<td class="left">Error on the decoder stream</td>
<td class="left"><a href="#error-handling" class="xref">Section 6</a></td>
</tr>
</tbody>
</table>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h2 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Normative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="HTTP3">[HTTP3]</b></td>
<td class="top">
<a title="Akamai Technologies">Bishop, M.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-http">Hypertext Transfer Protocol Version 3 (HTTP/3)</a>", Internet-Draft draft-ietf-quic-http, July 2019.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</b></td>
<td class="top">
<a title="Fastly">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport, July 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7541">[RFC7541]</b></td>
<td class="top">
<a>Peon, R.</a> and <a>H. Ruellan</a>, "<a href="https://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>", RFC 7541, DOI 10.17487/RFC7541, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h2 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Informative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2360">[RFC2360]</b></td>
<td class="top">
<a>Scott, G.</a>, "<a href="https://tools.ietf.org/html/rfc2360">Guide for Internet Standards Writers</a>", BCP 22, RFC 2360, DOI 10.17487/RFC2360, June 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7540">[RFC7540]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#static-table" id="static-table">Static Table</a>
</h1>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Index</th>
<th class="left">Name</th>
<th class="left">Value</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0</td>
<td class="left">:authority</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">1</td>
<td class="left">:path</td>
<td class="left">/</td>
</tr>
<tr>
<td class="left">2</td>
<td class="left">age</td>
<td class="left">0</td>
</tr>
<tr>
<td class="left">3</td>
<td class="left">content-disposition</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">4</td>
<td class="left">content-length</td>
<td class="left">0</td>
</tr>
<tr>
<td class="left">5</td>
<td class="left">cookie</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">6</td>
<td class="left">date</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">7</td>
<td class="left">etag</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">8</td>
<td class="left">if-modified-since</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">9</td>
<td class="left">if-none-match</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">10</td>
<td class="left">last-modified</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">11</td>
<td class="left">link</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">12</td>
<td class="left">location</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">13</td>
<td class="left">referer</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">14</td>
<td class="left">set-cookie</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">15</td>
<td class="left">:method</td>
<td class="left">CONNECT</td>
</tr>
<tr>
<td class="left">16</td>
<td class="left">:method</td>
<td class="left">DELETE</td>
</tr>
<tr>
<td class="left">17</td>
<td class="left">:method</td>
<td class="left">GET</td>
</tr>
<tr>
<td class="left">18</td>
<td class="left">:method</td>
<td class="left">HEAD</td>
</tr>
<tr>
<td class="left">19</td>
<td class="left">:method</td>
<td class="left">OPTIONS</td>
</tr>
<tr>
<td class="left">20</td>
<td class="left">:method</td>
<td class="left">POST</td>
</tr>
<tr>
<td class="left">21</td>
<td class="left">:method</td>
<td class="left">PUT</td>
</tr>
<tr>
<td class="left">22</td>
<td class="left">:scheme</td>
<td class="left">http</td>
</tr>
<tr>
<td class="left">23</td>
<td class="left">:scheme</td>
<td class="left">https</td>
</tr>
<tr>
<td class="left">24</td>
<td class="left">:status</td>
<td class="left">103</td>
</tr>
<tr>
<td class="left">25</td>
<td class="left">:status</td>
<td class="left">200</td>
</tr>
<tr>
<td class="left">26</td>
<td class="left">:status</td>
<td class="left">304</td>
</tr>
<tr>
<td class="left">27</td>
<td class="left">:status</td>
<td class="left">404</td>
</tr>
<tr>
<td class="left">28</td>
<td class="left">:status</td>
<td class="left">503</td>
</tr>
<tr>
<td class="left">29</td>
<td class="left">accept</td>
<td class="left">*/*</td>
</tr>
<tr>
<td class="left">30</td>
<td class="left">accept</td>
<td class="left">application/dns-message</td>
</tr>
<tr>
<td class="left">31</td>
<td class="left">accept-encoding</td>
<td class="left">gzip, deflate, br</td>
</tr>
<tr>
<td class="left">32</td>
<td class="left">accept-ranges</td>
<td class="left">bytes</td>
</tr>
<tr>
<td class="left">33</td>
<td class="left">access-control-allow-headers</td>
<td class="left">cache-control</td>
</tr>
<tr>
<td class="left">34</td>
<td class="left">access-control-allow-headers</td>
<td class="left">content-type</td>
</tr>
<tr>
<td class="left">35</td>
<td class="left">access-control-allow-origin</td>
<td class="left">*</td>
</tr>
<tr>
<td class="left">36</td>
<td class="left">cache-control</td>
<td class="left">max-age=0</td>
</tr>
<tr>
<td class="left">37</td>
<td class="left">cache-control</td>
<td class="left">max-age=2592000</td>
</tr>
<tr>
<td class="left">38</td>
<td class="left">cache-control</td>
<td class="left">max-age=604800</td>
</tr>
<tr>
<td class="left">39</td>
<td class="left">cache-control</td>
<td class="left">no-cache</td>
</tr>
<tr>
<td class="left">40</td>
<td class="left">cache-control</td>
<td class="left">no-store</td>
</tr>
<tr>
<td class="left">41</td>
<td class="left">cache-control</td>
<td class="left">public, max-age=31536000</td>
</tr>
<tr>
<td class="left">42</td>
<td class="left">content-encoding</td>
<td class="left">br</td>
</tr>
<tr>
<td class="left">43</td>
<td class="left">content-encoding</td>
<td class="left">gzip</td>
</tr>
<tr>
<td class="left">44</td>
<td class="left">content-type</td>
<td class="left">application/dns-message</td>
</tr>
<tr>
<td class="left">45</td>
<td class="left">content-type</td>
<td class="left">application/javascript</td>
</tr>
<tr>
<td class="left">46</td>
<td class="left">content-type</td>
<td class="left">application/json</td>
</tr>
<tr>
<td class="left">47</td>
<td class="left">content-type</td>
<td class="left">application/x-www-form-urlencoded</td>
</tr>
<tr>
<td class="left">48</td>
<td class="left">content-type</td>
<td class="left">image/gif</td>
</tr>
<tr>
<td class="left">49</td>
<td class="left">content-type</td>
<td class="left">image/jpeg</td>
</tr>
<tr>
<td class="left">50</td>
<td class="left">content-type</td>
<td class="left">image/png</td>
</tr>
<tr>
<td class="left">51</td>
<td class="left">content-type</td>
<td class="left">text/css</td>
</tr>
<tr>
<td class="left">52</td>
<td class="left">content-type</td>
<td class="left">text/html; charset=utf-8</td>
</tr>
<tr>
<td class="left">53</td>
<td class="left">content-type</td>
<td class="left">text/plain</td>
</tr>
<tr>
<td class="left">54</td>
<td class="left">content-type</td>
<td class="left">text/plain;charset=utf-8</td>
</tr>
<tr>
<td class="left">55</td>
<td class="left">range</td>
<td class="left">bytes=0-</td>
</tr>
<tr>
<td class="left">56</td>
<td class="left">strict-transport-security</td>
<td class="left">max-age=31536000</td>
</tr>
<tr>
<td class="left">57</td>
<td class="left">strict-transport-security</td>
<td class="left">max-age=31536000; includesubdomains</td>
</tr>
<tr>
<td class="left">58</td>
<td class="left">strict-transport-security</td>
<td class="left">max-age=31536000; includesubdomains; preload</td>
</tr>
<tr>
<td class="left">59</td>
<td class="left">vary</td>
<td class="left">accept-encoding</td>
</tr>
<tr>
<td class="left">60</td>
<td class="left">vary</td>
<td class="left">origin</td>
</tr>
<tr>
<td class="left">61</td>
<td class="left">x-content-type-options</td>
<td class="left">nosniff</td>
</tr>
<tr>
<td class="left">62</td>
<td class="left">x-xss-protection</td>
<td class="left">1; mode=block</td>
</tr>
<tr>
<td class="left">63</td>
<td class="left">:status</td>
<td class="left">100</td>
</tr>
<tr>
<td class="left">64</td>
<td class="left">:status</td>
<td class="left">204</td>
</tr>
<tr>
<td class="left">65</td>
<td class="left">:status</td>
<td class="left">206</td>
</tr>
<tr>
<td class="left">66</td>
<td class="left">:status</td>
<td class="left">302</td>
</tr>
<tr>
<td class="left">67</td>
<td class="left">:status</td>
<td class="left">400</td>
</tr>
<tr>
<td class="left">68</td>
<td class="left">:status</td>
<td class="left">403</td>
</tr>
<tr>
<td class="left">69</td>
<td class="left">:status</td>
<td class="left">421</td>
</tr>
<tr>
<td class="left">70</td>
<td class="left">:status</td>
<td class="left">425</td>
</tr>
<tr>
<td class="left">71</td>
<td class="left">:status</td>
<td class="left">500</td>
</tr>
<tr>
<td class="left">72</td>
<td class="left">accept-language</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">73</td>
<td class="left">access-control-allow-credentials</td>
<td class="left">FALSE</td>
</tr>
<tr>
<td class="left">74</td>
<td class="left">access-control-allow-credentials</td>
<td class="left">TRUE</td>
</tr>
<tr>
<td class="left">75</td>
<td class="left">access-control-allow-headers</td>
<td class="left">*</td>
</tr>
<tr>
<td class="left">76</td>
<td class="left">access-control-allow-methods</td>
<td class="left">get</td>
</tr>
<tr>
<td class="left">77</td>
<td class="left">access-control-allow-methods</td>
<td class="left">get, post, options</td>
</tr>
<tr>
<td class="left">78</td>
<td class="left">access-control-allow-methods</td>
<td class="left">options</td>
</tr>
<tr>
<td class="left">79</td>
<td class="left">access-control-expose-headers</td>
<td class="left">content-length</td>
</tr>
<tr>
<td class="left">80</td>
<td class="left">access-control-request-headers</td>
<td class="left">content-type</td>
</tr>
<tr>
<td class="left">81</td>
<td class="left">access-control-request-method</td>
<td class="left">get</td>
</tr>
<tr>
<td class="left">82</td>
<td class="left">access-control-request-method</td>
<td class="left">post</td>
</tr>
<tr>
<td class="left">83</td>
<td class="left">alt-svc</td>
<td class="left">clear</td>
</tr>
<tr>
<td class="left">84</td>
<td class="left">authorization</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">85</td>
<td class="left">content-security-policy</td>
<td class="left">script-src 'none'; object-src 'none'; base-uri 'none'</td>
</tr>
<tr>
<td class="left">86</td>
<td class="left">early-data</td>
<td class="left">1</td>
</tr>
<tr>
<td class="left">87</td>
<td class="left">expect-ct</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">88</td>
<td class="left">forwarded</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">89</td>
<td class="left">if-range</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">90</td>
<td class="left">origin</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">91</td>
<td class="left">purpose</td>
<td class="left">prefetch</td>
</tr>
<tr>
<td class="left">92</td>
<td class="left">server</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">93</td>
<td class="left">timing-allow-origin</td>
<td class="left">*</td>
</tr>
<tr>
<td class="left">94</td>
<td class="left">upgrade-insecure-requests</td>
<td class="left">1</td>
</tr>
<tr>
<td class="left">95</td>
<td class="left">user-agent</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">96</td>
<td class="left">x-forwarded-for</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">97</td>
<td class="left">x-frame-options</td>
<td class="left">deny</td>
</tr>
<tr>
<td class="left">98</td>
<td class="left">x-frame-options</td>
<td class="left">sameorigin</td>
</tr>
</tbody>
</table>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#sample-one-pass-encoding-algorithm" id="sample-one-pass-encoding-algorithm">Sample One Pass Encoding Algorithm</a>
</h1>
<p id="rfc.section.B.p.1">Pseudo-code for single pass encoding, excluding handling of duplicates, non-blocking mode, and reference tracking.</p>
<pre>
baseIndex = dynamicTable.baseIndex
largestReference = 0
for header in headers:
  staticIdx = staticTable.getIndex(header)
  if staticIdx:
    encodeIndexReference(streamBuffer, staticIdx)
    continue

  dynamicIdx = dynamicTable.getIndex(header)
  if !dynamicIdx:
    # No matching entry.  Either insert+index or encode literal
    nameIdx = getNameIndex(header)
    if shouldIndex(header) and dynamicTable.canIndex(header):
      encodeLiteralWithIncrementalIndex(controlBuffer, nameIdx,
                                        header)
      dynamicTable.add(header)
      dynamicIdx = dynamicTable.baseIndex

  if !dynamicIdx:
    # Couldn't index it, literal
    if nameIdx &lt;= staticTable.size:
      encodeLiteral(streamBuffer, nameIndex, header)
    else:
      # encode literal, possibly with nameIdx above baseIndex
      encodeDynamicLiteral(streamBuffer, nameIndex, baseIndex,
                           header)
      largestReference = max(largestReference,
                             dynamicTable.toAbsolute(nameIdx))
  else:
    # Dynamic index reference
    assert(dynamicIdx)
    largestReference = max(largestReference, dynamicIdx)
    # Encode dynamicIdx, possibly with dynamicIdx above baseIndex
    encodeDynamicIndexReference(streamBuffer, dynamicIdx,
                                baseIndex)

# encode the prefix
encodeInteger(prefixBuffer, 0x00, largestReference, 8)
if baseIndex &gt;= largestReference:
  encodeInteger(prefixBuffer, 0, baseIndex - largestReference, 7)
else:
  encodeInteger(prefixBuffer, 0x80,
                largestReference  - baseIndex, 7)

return controlBuffer, prefixBuffer + streamBuffer
</pre>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#change-log" id="change-log">Change Log</a>
</h1>
<p></p>

<ul class="empty"><li>
<strong>RFC Editor&#8217;s Note:</strong> Please remove this section prior to publication of a final version of this document.</li></ul>
<h2 id="rfc.appendix.C.1">
<a href="#rfc.appendix.C.1">C.1.</a> <a href="#since-draft-ietf-quic-qpack-08" id="since-draft-ietf-quic-qpack-08">Since draft-ietf-quic-qpack-08</a>
</h2>
<p></p>

<ul>
<li>Endpoints are permitted to create encoder and decoder streams even if they can&#8217;t use them (#2100, #2529)</li>
<li>Maximum values for settings removed (#2766, #2767)</li>
</ul>
<h2 id="rfc.appendix.C.2">
<a href="#rfc.appendix.C.2">C.2.</a> <a href="#since-draft-ietf-quic-qpack-06" id="since-draft-ietf-quic-qpack-06">Since draft-ietf-quic-qpack-06</a>
</h2>
<p></p>

<ul><li>Clarify initial dynamic table capacity maximums (#2276, #2330, #2330)</li></ul>
<h2 id="rfc.appendix.C.3">
<a href="#rfc.appendix.C.3">C.3.</a> <a href="#since-draft-ietf-quic-qpack-05" id="since-draft-ietf-quic-qpack-05">Since draft-ietf-quic-qpack-05</a>
</h2>
<p></p>

<ul>
<li>Introduced the terms dynamic table capacity and maximum dynamic table capacity.</li>
<li>Renamed SETTINGS_HEADER_TABLE_SIZE to SETTINGS_QPACK_MAX_TABLE_CAPACITY.</li>
</ul>
<h2 id="rfc.appendix.C.4">
<a href="#rfc.appendix.C.4">C.4.</a> <a href="#since-draft-ietf-quic-qpack-04" id="since-draft-ietf-quic-qpack-04">Since draft-ietf-quic-qpack-04</a>
</h2>
<p></p>

<ul><li>Changed calculation of Delta Base Index to avoid an illegal value (#2002, #2005)</li></ul>
<h2 id="rfc.appendix.C.5">
<a href="#rfc.appendix.C.5">C.5.</a> <a href="#since-draft-ietf-quic-qpack-03" id="since-draft-ietf-quic-qpack-03">Since draft-ietf-quic-qpack-03</a>
</h2>
<p></p>

<ul>
<li>Change HTTP settings defaults (#2038)</li>
<li>Substantial editorial reorganization</li>
</ul>
<h2 id="rfc.appendix.C.6">
<a href="#rfc.appendix.C.6">C.6.</a> <a href="#since-draft-ietf-quic-qpack-02" id="since-draft-ietf-quic-qpack-02">Since draft-ietf-quic-qpack-02</a>
</h2>
<p></p>

<ul>
<li>Largest Reference encoded modulo MaxEntries (#1763)</li>
<li>New Static Table (#1355)</li>
<li>Table Size Update with Insert Count=0 is a connection error (#1762)</li>
<li>Stream Cancellations are optional when SETTINGS_HEADER_TABLE_SIZE=0 (#1761)</li>
<li>Implementations must handle 62 bit integers (#1760)</li>
<li>Different error types for each QPACK stream, other changes to error handling (#1726)</li>
<li>Preserve header field order (#1725)</li>
<li>Initial table size is the maximum permitted when table is first usable (#1642)</li>
</ul>
<h2 id="rfc.appendix.C.7">
<a href="#rfc.appendix.C.7">C.7.</a> <a href="#since-draft-ietf-quic-qpack-01" id="since-draft-ietf-quic-qpack-01">Since draft-ietf-quic-qpack-01</a>
</h2>
<p></p>

<ul><li>Only header blocks that reference the dynamic table are acknowledged (#1603, #1605)</li></ul>
<h2 id="rfc.appendix.C.8">
<a href="#rfc.appendix.C.8">C.8.</a> <a href="#since-draft-ietf-quic-qpack-00" id="since-draft-ietf-quic-qpack-00">Since draft-ietf-quic-qpack-00</a>
</h2>
<p></p>

<ul>
<li>Renumbered instructions for consistency (#1471, #1472)</li>
<li>Decoder is allowed to validate largest reference (#1404, #1469)</li>
<li>Header block acknowledgments also acknowledge the associated largest reference (#1370, #1400)</li>
<li>Added an acknowledgment for unread streams (#1371, #1400)</li>
<li>Removed framing from encoder stream (#1361,#1467)</li>
<li>Control streams use typed unidirectional streams rather than fixed stream IDs (#910,#1359)</li>
</ul>
<h2 id="rfc.appendix.C.9">
<a href="#rfc.appendix.C.9">C.9.</a> <a href="#since-draft-ietf-quic-qcram-00" id="since-draft-ietf-quic-qcram-00">Since draft-ietf-quic-qcram-00</a>
</h2>
<p></p>

<ul>
<li>Separate instruction sets for table updates and header blocks (#1235, #1142, #1141)</li>
<li>Reworked indexing scheme (#1176, #1145, #1136, #1130, #1125, #1314)</li>
<li>Added mechanisms that support one-pass encoding (#1138, #1320)</li>
<li>Added a setting to control the number of blocked decoders (#238, #1140, #1143)</li>
<li>Moved table updates and acknowledgments to dedicated streams (#1121, #1122, #1238)</li>
</ul>
<h1 id="rfc.acknowledgments"><a href="#rfc.acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.D.p.1">This draft draws heavily on the text of <a href="#RFC7541" class="xref">[RFC7541]</a>.  The indirect input of those authors is gratefully acknowledged, as well as ideas from:</p>
<p></p>

<ul>
<li>Ryan Hamilton</li>
<li>Patrick McManus</li>
<li>Kazuho Oku</li>
<li>Biren Roy</li>
<li>Ian Swett</li>
<li>Dmitri Tikhonov</li>
</ul>
<p id="rfc.section.D.p.3">Buck&#8217;s contribution was supported by Google during his employment there.</p>
<p id="rfc.section.D.p.4">A substantial portion of Mike&#8217;s contribution was supported by Microsoft during his employment there.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Charles 'Buck' Krasic</span> 
	  <span class="n hidden">
		<span class="family-name">Krasic</span>
	  </span>
	</span>
	<span class="org vcardline">Netflix</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ckrasic@netflix.com">ckrasic@netflix.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Akamai Technologies</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mbishop@evequefou.be">mbishop@evequefou.be</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Alan Frindell</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Frindell</span>
	  </span>
	</span>
	<span class="org vcardline">Facebook</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:afrind@fb.com">afrind@fb.com</a></span>

  </address>
</div>

</body>
</html>

