<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QUIC Loss Detection and Congestion Control</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Definitions">
<link href="#rfc.section.3" rel="Chapter" title="3 Design of the QUIC Transmission Machinery">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Relevant Differences Between QUIC and TCP">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Separate Packet Number Spaces">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Monotonically Increasing Packet Numbers">
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 Clearer Loss Epoch">
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 No Reneging">
<link href="#rfc.section.3.1.5" rel="Chapter" title="3.1.5 More ACK Ranges">
<link href="#rfc.section.3.1.6" rel="Chapter" title="3.1.6 Explicit Correction For Delayed Acknowledgements">
<link href="#rfc.section.4" rel="Chapter" title="4 Estimating the Round-Trip Time">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Generating RTT samples">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Estimating min_rtt">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Estimating smoothed_rtt and rttvar">
<link href="#rfc.section.5" rel="Chapter" title="5 Loss Detection">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Acknowledgement-based Detection">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Packet Threshold">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Time Threshold">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Probe Timeout">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Computing PTO">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Handshakes and New Paths">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Sending Probe Packets">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Loss Detection">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Retry and Version Negotiation">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Discarding Keys and Packet State">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Discussion">
<link href="#rfc.section.6" rel="Chapter" title="6 Congestion Control">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Explicit Congestion Notification">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Slow Start">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Congestion Avoidance">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Recovery Period">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Ignoring Loss of Undecryptable Packets">
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Probe Timeout">
<link href="#rfc.section.6.7" rel="Chapter" title="6.7 Persistent Congestion">
<link href="#rfc.section.6.8" rel="Chapter" title="6.8 Pacing">
<link href="#rfc.section.6.9" rel="Chapter" title="6.9 Under-utilizing the Congestion Window">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Congestion Signals">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Traffic Analysis">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Misreporting ECN Markings">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Loss Recovery Pseudocode">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Tracking Sent Packets">
<link href="#rfc.appendix.A.1.1" rel="Chapter" title="A.1.1 Sent Packet Fields">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Constants of interest">
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Variables of interest">
<link href="#rfc.appendix.A.4" rel="Chapter" title="A.4 Initialization">
<link href="#rfc.appendix.A.5" rel="Chapter" title="A.5 On Sending a Packet">
<link href="#rfc.appendix.A.6" rel="Chapter" title="A.6 On Receiving an Acknowledgment">
<link href="#rfc.appendix.A.7" rel="Chapter" title="A.7 On Packet Acknowledgment">
<link href="#rfc.appendix.A.8" rel="Chapter" title="A.8 Setting the Loss Detection Timer">
<link href="#rfc.appendix.A.9" rel="Chapter" title="A.9 On Timeout">
<link href="#rfc.appendix.A.10" rel="Chapter" title="A.10 Detecting Lost Packets">
<link href="#rfc.appendix.B" rel="Chapter" title="B Congestion Control Pseudocode">
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Constants of interest">
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Variables of interest">
<link href="#rfc.appendix.B.3" rel="Chapter" title="B.3 Initialization">
<link href="#rfc.appendix.B.4" rel="Chapter" title="B.4 On Packet Sent">
<link href="#rfc.appendix.B.5" rel="Chapter" title="B.5 On Packet Acknowledgement">
<link href="#rfc.appendix.B.6" rel="Chapter" title="B.6 On New Congestion Event">
<link href="#rfc.appendix.B.7" rel="Chapter" title="B.7 Process ECN Information">
<link href="#rfc.appendix.B.8" rel="Chapter" title="B.8 On Packets Lost">
<link href="#rfc.appendix.C" rel="Chapter" title="C Change Log">
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Since draft-ietf-quic-recovery-22">
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Since draft-ietf-quic-recovery-21">
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Since draft-ietf-quic-recovery-20">
<link href="#rfc.appendix.C.4" rel="Chapter" title="C.4 Since draft-ietf-quic-recovery-19">
<link href="#rfc.appendix.C.5" rel="Chapter" title="C.5 Since draft-ietf-quic-recovery-18">
<link href="#rfc.appendix.C.6" rel="Chapter" title="C.6 Since draft-ietf-quic-recovery-17">
<link href="#rfc.appendix.C.7" rel="Chapter" title="C.7 Since draft-ietf-quic-recovery-16">
<link href="#rfc.appendix.C.8" rel="Chapter" title="C.8 Since draft-ietf-quic-recovery-14">
<link href="#rfc.appendix.C.9" rel="Chapter" title="C.9 Since draft-ietf-quic-recovery-13">
<link href="#rfc.appendix.C.10" rel="Chapter" title="C.10 Since draft-ietf-quic-recovery-12">
<link href="#rfc.appendix.C.11" rel="Chapter" title="C.11 Since draft-ietf-quic-recovery-11">
<link href="#rfc.appendix.C.12" rel="Chapter" title="C.12 Since draft-ietf-quic-recovery-10">
<link href="#rfc.appendix.C.13" rel="Chapter" title="C.13 Since draft-ietf-quic-recovery-09">
<link href="#rfc.appendix.C.14" rel="Chapter" title="C.14 Since draft-ietf-quic-recovery-08">
<link href="#rfc.appendix.C.15" rel="Chapter" title="C.15 Since draft-ietf-quic-recovery-07">
<link href="#rfc.appendix.C.16" rel="Chapter" title="C.16 Since draft-ietf-quic-recovery-06">
<link href="#rfc.appendix.C.17" rel="Chapter" title="C.17 Since draft-ietf-quic-recovery-05">
<link href="#rfc.appendix.C.18" rel="Chapter" title="C.18 Since draft-ietf-quic-recovery-04">
<link href="#rfc.appendix.C.19" rel="Chapter" title="C.19 Since draft-ietf-quic-recovery-03">
<link href="#rfc.appendix.C.20" rel="Chapter" title="C.20 Since draft-ietf-quic-recovery-02">
<link href="#rfc.appendix.C.21" rel="Chapter" title="C.21 Since draft-ietf-quic-recovery-01">
<link href="#rfc.appendix.C.22" rel="Chapter" title="C.22 Since draft-ietf-quic-recovery-00">
<link href="#rfc.appendix.C.23" rel="Chapter" title="C.23 Since draft-iyengar-quic-loss-recovery-01">
<link href="#rfc.acknowledgments" rel="Chapter">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.30.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Iyengar, J., Ed. and I. Swett, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-recovery-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-09-24" />
  <meta name="dct.abstract" content="This document describes loss detection and congestion control mechanisms for QUIC." />
  <meta name="description" content="This document describes loss detection and congestion control mechanisms for QUIC." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">J. Iyengar, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Fastly</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">I. Swett, Ed.</td>
</tr>
<tr>
<td class="left">Expires: March 27, 2020</td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">September 24, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QUIC Loss Detection and Congestion Control<br />
  <span class="filename">draft-ietf-quic-recovery-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes loss detection and congestion control mechanisms for QUIC.</p>
<h1><a>Note to Readers</a></h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/-recovery">https://github.com/quicwg/base-drafts/labels/-recovery</a>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 27, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Conventions and Definitions</a>
</li>
<li>3.   <a href="#rfc.section.3">Design of the QUIC Transmission Machinery</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Relevant Differences Between QUIC and TCP</a>
</li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">Separate Packet Number Spaces</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Monotonically Increasing Packet Numbers</a>
</li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">Clearer Loss Epoch</a>
</li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">No Reneging</a>
</li>
<li>3.1.5.   <a href="#rfc.section.3.1.5">More ACK Ranges</a>
</li>
<li>3.1.6.   <a href="#rfc.section.3.1.6">Explicit Correction For Delayed Acknowledgements</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">Estimating the Round-Trip Time</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Generating RTT samples</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Estimating min_rtt</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Estimating smoothed_rtt and rttvar</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Loss Detection</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Acknowledgement-based Detection</a>
</li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Packet Threshold</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Time Threshold</a>
</li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Probe Timeout</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Computing PTO</a>
</li>
</ul><li>5.3.   <a href="#rfc.section.5.3">Handshakes and New Paths</a>
</li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">Sending Probe Packets</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Loss Detection</a>
</li>
</ul><li>5.4.   <a href="#rfc.section.5.4">Retry and Version Negotiation</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Discarding Keys and Packet State</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">Discussion</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Congestion Control</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Explicit Congestion Notification</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Slow Start</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Congestion Avoidance</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Recovery Period</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Ignoring Loss of Undecryptable Packets</a>
</li>
<li>6.6.   <a href="#rfc.section.6.6">Probe Timeout</a>
</li>
<li>6.7.   <a href="#rfc.section.6.7">Persistent Congestion</a>
</li>
<li>6.8.   <a href="#rfc.section.6.8">Pacing</a>
</li>
<li>6.9.   <a href="#rfc.section.6.9">Under-utilizing the Congestion Window</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Congestion Signals</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Traffic Analysis</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Misreporting ECN Markings</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Loss Recovery Pseudocode</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Tracking Sent Packets</a>
</li>
<ul><li>A.1.1.   <a href="#rfc.appendix.A.1.1">Sent Packet Fields</a>
</li>
</ul><li>A.2.   <a href="#rfc.appendix.A.2">Constants of interest</a>
</li>
<li>A.3.   <a href="#rfc.appendix.A.3">Variables of interest</a>
</li>
<li>A.4.   <a href="#rfc.appendix.A.4">Initialization</a>
</li>
<li>A.5.   <a href="#rfc.appendix.A.5">On Sending a Packet</a>
</li>
<li>A.6.   <a href="#rfc.appendix.A.6">On Receiving an Acknowledgment</a>
</li>
<li>A.7.   <a href="#rfc.appendix.A.7">On Packet Acknowledgment</a>
</li>
<li>A.8.   <a href="#rfc.appendix.A.8">Setting the Loss Detection Timer</a>
</li>
<li>A.9.   <a href="#rfc.appendix.A.9">On Timeout</a>
</li>
<li>A.10.   <a href="#rfc.appendix.A.10">Detecting Lost Packets</a>
</li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">Congestion Control Pseudocode</a>
</li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Constants of interest</a>
</li>
<li>B.2.   <a href="#rfc.appendix.B.2">Variables of interest</a>
</li>
<li>B.3.   <a href="#rfc.appendix.B.3">Initialization</a>
</li>
<li>B.4.   <a href="#rfc.appendix.B.4">On Packet Sent</a>
</li>
<li>B.5.   <a href="#rfc.appendix.B.5">On Packet Acknowledgement</a>
</li>
<li>B.6.   <a href="#rfc.appendix.B.6">On New Congestion Event</a>
</li>
<li>B.7.   <a href="#rfc.appendix.B.7">Process ECN Information</a>
</li>
<li>B.8.   <a href="#rfc.appendix.B.8">On Packets Lost</a>
</li>
</ul><li>Appendix C.   <a href="#rfc.appendix.C">Change Log</a>
</li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Since draft-ietf-quic-recovery-22</a>
</li>
<li>C.2.   <a href="#rfc.appendix.C.2">Since draft-ietf-quic-recovery-21</a>
</li>
<li>C.3.   <a href="#rfc.appendix.C.3">Since draft-ietf-quic-recovery-20</a>
</li>
<li>C.4.   <a href="#rfc.appendix.C.4">Since draft-ietf-quic-recovery-19</a>
</li>
<li>C.5.   <a href="#rfc.appendix.C.5">Since draft-ietf-quic-recovery-18</a>
</li>
<li>C.6.   <a href="#rfc.appendix.C.6">Since draft-ietf-quic-recovery-17</a>
</li>
<li>C.7.   <a href="#rfc.appendix.C.7">Since draft-ietf-quic-recovery-16</a>
</li>
<li>C.8.   <a href="#rfc.appendix.C.8">Since draft-ietf-quic-recovery-14</a>
</li>
<li>C.9.   <a href="#rfc.appendix.C.9">Since draft-ietf-quic-recovery-13</a>
</li>
<li>C.10.   <a href="#rfc.appendix.C.10">Since draft-ietf-quic-recovery-12</a>
</li>
<li>C.11.   <a href="#rfc.appendix.C.11">Since draft-ietf-quic-recovery-11</a>
</li>
<li>C.12.   <a href="#rfc.appendix.C.12">Since draft-ietf-quic-recovery-10</a>
</li>
<li>C.13.   <a href="#rfc.appendix.C.13">Since draft-ietf-quic-recovery-09</a>
</li>
<li>C.14.   <a href="#rfc.appendix.C.14">Since draft-ietf-quic-recovery-08</a>
</li>
<li>C.15.   <a href="#rfc.appendix.C.15">Since draft-ietf-quic-recovery-07</a>
</li>
<li>C.16.   <a href="#rfc.appendix.C.16">Since draft-ietf-quic-recovery-06</a>
</li>
<li>C.17.   <a href="#rfc.appendix.C.17">Since draft-ietf-quic-recovery-05</a>
</li>
<li>C.18.   <a href="#rfc.appendix.C.18">Since draft-ietf-quic-recovery-04</a>
</li>
<li>C.19.   <a href="#rfc.appendix.C.19">Since draft-ietf-quic-recovery-03</a>
</li>
<li>C.20.   <a href="#rfc.appendix.C.20">Since draft-ietf-quic-recovery-02</a>
</li>
<li>C.21.   <a href="#rfc.appendix.C.21">Since draft-ietf-quic-recovery-01</a>
</li>
<li>C.22.   <a href="#rfc.appendix.C.22">Since draft-ietf-quic-recovery-00</a>
</li>
<li>C.23.   <a href="#rfc.appendix.C.23">Since draft-iyengar-quic-loss-recovery-01</a>
</li>
</ul><li><a href="#rfc.acknowledgments">Acknowledgments</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">QUIC is a new multiplexed and secure transport atop UDP.  QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport.  The QUIC protocol is described in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.</p>
<p id="rfc.section.1.p.2">QUIC implements the spirit of existing TCP loss recovery mechanisms, described in RFCs, various Internet-drafts, and also those prevalent in the Linux TCP implementation.  This document describes QUIC congestion control and loss recovery, and where applicable, attributes the TCP equivalent in RFCs, Internet-drafts, academic papers, and/or TCP implementations.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#conventions-and-definitions" id="conventions-and-definitions">Conventions and Definitions</a>
</h1>
<p id="rfc.section.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.2.p.2">Definitions of terms that are used in this document:</p>
<p></p>

<dl>
<dt>ACK-only:</dt>
<dd style="margin-left: 8">Any packet containing only one or more ACK frame(s).</dd>
<dt>In-flight:</dt>
<dd style="margin-left: 8">Packets are considered in-flight when they have been sent and are not ACK-only, and they are not acknowledged, declared lost, or abandoned along with old keys.</dd>
<dt>Ack-eliciting Frames:</dt>
<dd style="margin-left: 8">All frames besides ACK or PADDING are considered ack-eliciting.</dd>
<dt>Ack-eliciting Packets:</dt>
<dd style="margin-left: 8">Packets that contain ack-eliciting frames elicit an ACK from the receiver within the maximum ack delay and are called ack-eliciting packets.</dd>
<dt>Crypto Packets:</dt>
<dd style="margin-left: 8">Packets containing CRYPTO data sent in Initial or Handshake packets.</dd>
<dt>Out-of-order Packets:</dt>
<dd style="margin-left: 8">Packets that do not increase the largest received packet number for its packet number space by exactly one. Packets arrive out of order when earlier packets are lost or delayed.</dd>
</dl>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#design-of-the-quic-transmission-machinery" id="design-of-the-quic-transmission-machinery">Design of the QUIC Transmission Machinery</a>
</h1>
<p id="rfc.section.3.p.1">All transmissions in QUIC are sent with a packet-level header, which indicates the encryption level and includes a packet sequence number (referred to below as a packet number).  The encryption level indicates the packet number space, as described in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.  Packet numbers never repeat within a packet number space for the lifetime of a connection.  Packet numbers monotonically increase within a space, preventing ambiguity.</p>
<p id="rfc.section.3.p.2">This design obviates the need for disambiguating between transmissions and retransmissions and eliminates significant complexity from QUIC&#8217;s interpretation of TCP loss detection mechanisms.</p>
<p id="rfc.section.3.p.3">QUIC packets can contain multiple frames of different types. The recovery mechanisms ensure that data and frames that need reliable delivery are acknowledged or declared lost and sent in new packets as necessary. The types of frames contained in a packet affect recovery and congestion control logic:</p>
<p></p>

<ul>
<li>All packets are acknowledged, though packets that contain no ack-eliciting frames are only acknowledged along with ack-eliciting packets.</li>
<li>Long header packets that contain CRYPTO frames are critical to the performance of the QUIC handshake and use shorter timers for acknowledgement.</li>
<li>Packets that contain only ACK frames do not count toward congestion control limits and are not considered in-flight.</li>
<li>PADDING frames cause packets to contribute toward bytes in flight without directly causing an acknowledgment to be sent.</li>
</ul>
<h2 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#relevant-differences-between-quic-and-tcp" id="relevant-differences-between-quic-and-tcp">Relevant Differences Between QUIC and TCP</a>
</h2>
<p id="rfc.section.3.1.p.1">Readers familiar with TCP&#8217;s loss detection and congestion control will find algorithms here that parallel well-known TCP ones. Protocol differences between QUIC and TCP however contribute to algorithmic differences. We briefly describe these protocol differences below.</p>
<h3 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#separate-packet-number-spaces" id="separate-packet-number-spaces">Separate Packet Number Spaces</a>
</h3>
<p id="rfc.section.3.1.1.p.1">QUIC uses separate packet number spaces for each encryption level, except 0-RTT and all generations of 1-RTT keys use the same packet number space.  Separate packet number spaces ensures acknowledgement of packets sent with one level of encryption will not cause spurious retransmission of packets sent with a different encryption level.  Congestion control and round-trip time (RTT) measurement are unified across packet number spaces.</p>
<h3 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#monotonically-increasing-packet-numbers" id="monotonically-increasing-packet-numbers">Monotonically Increasing Packet Numbers</a>
</h3>
<p id="rfc.section.3.1.2.p.1">TCP conflates transmission order at the sender with delivery order at the receiver, which results in retransmissions of the same data carrying the same sequence number, and consequently leads to &#8220;retransmission ambiguity&#8221;.  QUIC separates the two: QUIC uses a packet number to indicate transmission order, and any application data is sent in one or more streams, with delivery order determined by stream offsets encoded within STREAM frames.</p>
<p id="rfc.section.3.1.2.p.2">QUIC&#8217;s packet number is strictly increasing within a packet number space, and directly encodes transmission order.  A higher packet number signifies that the packet was sent later, and a lower packet number signifies that the packet was sent earlier.  When a packet containing ack-eliciting frames is detected lost, QUIC rebundles necessary frames in a new packet with a new packet number, removing ambiguity about which packet is acknowledged when an ACK is received.  Consequently, more accurate RTT measurements can be made, spurious retransmissions are trivially detected, and mechanisms such as Fast Retransmit can be applied universally, based only on packet number.</p>
<p id="rfc.section.3.1.2.p.3">This design point significantly simplifies loss detection mechanisms for QUIC.  Most TCP mechanisms implicitly attempt to infer transmission ordering based on TCP sequence numbers - a non-trivial task, especially when TCP timestamps are not available.</p>
<h3 id="rfc.section.3.1.3">
<a href="#rfc.section.3.1.3">3.1.3.</a> <a href="#clearer-loss-epoch" id="clearer-loss-epoch">Clearer Loss Epoch</a>
</h3>
<p id="rfc.section.3.1.3.p.1">QUIC ends a loss epoch when a packet sent after loss is declared is acknowledged. TCP waits for the gap in the sequence number space to be filled, and so if a segment is lost multiple times in a row, the loss epoch may not end for several round trips. Because both should reduce their congestion windows only once per epoch, QUIC will do it correctly once for every round trip that experiences loss, while TCP may only do it once across multiple round trips.</p>
<h3 id="rfc.section.3.1.4">
<a href="#rfc.section.3.1.4">3.1.4.</a> <a href="#no-reneging" id="no-reneging">No Reneging</a>
</h3>
<p id="rfc.section.3.1.4.p.1">QUIC ACKs contain information that is similar to TCP SACK, but QUIC does not allow any acked packet to be reneged, greatly simplifying implementations on both sides and reducing memory pressure on the sender.</p>
<h3 id="rfc.section.3.1.5">
<a href="#rfc.section.3.1.5">3.1.5.</a> <a href="#more-ack-ranges" id="more-ack-ranges">More ACK Ranges</a>
</h3>
<p id="rfc.section.3.1.5.p.1">QUIC supports many ACK ranges, opposed to TCP&#8217;s 3 SACK ranges.  In high loss environments, this speeds recovery, reduces spurious retransmits, and ensures forward progress without relying on timeouts.</p>
<h3 id="rfc.section.3.1.6">
<a href="#rfc.section.3.1.6">3.1.6.</a> <a href="#explicit-correction-for-delayed-acknowledgements" id="explicit-correction-for-delayed-acknowledgements">Explicit Correction For Delayed Acknowledgements</a>
</h3>
<p id="rfc.section.3.1.6.p.1">QUIC endpoints measure the delay incurred between when a packet is received and when the corresponding acknowledgment is sent, allowing a peer to maintain a more accurate round-trip time estimate (see Section 13.2 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>).</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#compute-rtt" id="compute-rtt">Estimating the Round-Trip Time</a>
</h1>
<p id="rfc.section.4.p.1">At a high level, an endpoint measures the time from when a packet was sent to when it is acknowledged as a round-trip time (RTT) sample.  The endpoint uses RTT samples and peer-reported host delays (see Section 13.2 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>) to generate a statistical description of the connection&#8217;s RTT. An endpoint computes the following three values: the minimum value observed over the lifetime of the connection (min_rtt), an exponentially-weighted moving average (smoothed_rtt), and the variance in the observed RTT samples (rttvar).</p>
<h2 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#latest-rtt" id="latest-rtt">Generating RTT samples</a>
</h2>
<p id="rfc.section.4.1.p.1">An endpoint generates an RTT sample on receiving an ACK frame that meets the following two conditions:</p>
<p></p>

<ul>
<li>the largest acknowledged packet number is newly acknowledged, and</li>
<li>at least one of the newly acknowledged packets was ack-eliciting.</li>
</ul>
<p id="rfc.section.4.1.p.3">The RTT sample, latest_rtt, is generated as the time elapsed since the largest acknowledged packet was sent:</p>
<pre>
latest_rtt = ack_time - send_time_of_largest_acked
</pre>
<p id="rfc.section.4.1.p.4">An RTT sample is generated using only the largest acknowledged packet in the received ACK frame.  This is because a peer reports host delays for only the largest acknowledged packet in an ACK frame.  While the reported host delay is not used by the RTT sample measurement, it is used to adjust the RTT sample in subsequent computations of smoothed_rtt and rttvar <a href="#smoothed-rtt" class="xref">Section 4.3</a>.</p>
<p id="rfc.section.4.1.p.5">To avoid generating multiple RTT samples using the same packet, an ACK frame SHOULD NOT be used to update RTT estimates if it does not newly acknowledge the largest acknowledged packet.</p>
<p id="rfc.section.4.1.p.6">An RTT sample MUST NOT be generated on receiving an ACK frame that does not newly acknowledge at least one ack-eliciting packet.  A peer does not send an ACK frame on receiving only non-ack-eliciting packets, so an ACK frame that is subsequently sent can include an arbitrarily large Ack Delay field.  Ignoring such ACK frames avoids complications in subsequent smoothed_rtt and rttvar computations.</p>
<p id="rfc.section.4.1.p.7">A sender might generate multiple RTT samples per RTT when multiple ACK frames are received within an RTT.  As suggested in <a href="#RFC6298" class="xref">[RFC6298]</a>, doing so might result in inadequate history in smoothed_rtt and rttvar.  Ensuring that RTT estimates retain sufficient history is an open research question.</p>
<h2 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#min-rtt" id="min-rtt">Estimating min_rtt</a>
</h2>
<p id="rfc.section.4.2.p.1">min_rtt is the minimum RTT observed over the lifetime of the connection.  min_rtt is set to the latest_rtt on the first sample in a connection, and to the lesser of min_rtt and latest_rtt on subsequent samples.</p>
<p id="rfc.section.4.2.p.2">An endpoint uses only locally observed times in computing the min_rtt and does not adjust for host delays reported by the peer.  Doing so allows the endpoint to set a lower bound for the smoothed_rtt based entirely on what it observes (see <a href="#smoothed-rtt" class="xref">Section 4.3</a>), and limits potential underestimation due to erroneously-reported delays by the peer.</p>
<h2 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#smoothed-rtt" id="smoothed-rtt">Estimating smoothed_rtt and rttvar</a>
</h2>
<p id="rfc.section.4.3.p.1">smoothed_rtt is an exponentially-weighted moving average of an endpoint&#8217;s RTT samples, and rttvar is the endpoint&#8217;s estimated variance in the RTT samples.</p>
<p id="rfc.section.4.3.p.2">The calculation of smoothed_rtt uses path latency after adjusting RTT samples for host delays.  For packets sent in the ApplicationData packet number space, a peer limits any delay in sending an acknowledgement for an ack-eliciting packet to no greater than the value it advertised in the max_ack_delay transport parameter.  Consequently, when a peer reports an Ack Delay that is greater than its max_ack_delay, the delay is attributed to reasons out of the peer&#8217;s control, such as scheduler latency at the peer or loss of previous ACK frames.  Any delays beyond the peer&#8217;s max_ack_delay are therefore considered effectively part of path delay and incorporated into the smoothed_rtt estimate.</p>
<p id="rfc.section.4.3.p.3">When adjusting an RTT sample using peer-reported acknowledgement delays, an endpoint:</p>
<p></p>

<ul>
<li>MUST ignore the Ack Delay field of the ACK frame for packets sent in the Initial and Handshake packet number space.</li>
<li>MUST use the lesser of the value reported in Ack Delay field of the ACK frame and the peer&#8217;s max_ack_delay transport parameter.</li>
<li>MUST NOT apply the adjustment if the resulting RTT sample is smaller than the min_rtt.  This limits the underestimation that a misreporting peer can cause to the smoothed_rtt.</li>
</ul>
<p id="rfc.section.4.3.p.5">On the first RTT sample in a connection, the smoothed_rtt is set to the latest_rtt.</p>
<p id="rfc.section.4.3.p.6">smoothed_rtt and rttvar are computed as follows, similar to <a href="#RFC6298" class="xref">[RFC6298]</a>.  On the first RTT sample in a connection:</p>
<pre>
smoothed_rtt = latest_rtt
rttvar = latest_rtt / 2
</pre>
<p id="rfc.section.4.3.p.7">On subsequent RTT samples, smoothed_rtt and rttvar evolve as follows:</p>
<pre>
ack_delay = min(Ack Delay in ACK Frame, max_ack_delay)
adjusted_rtt = latest_rtt
if (min_rtt + ack_delay &lt; latest_rtt):
  adjusted_rtt = latest_rtt - ack_delay
smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
rttvar_sample = abs(smoothed_rtt - adjusted_rtt)
rttvar = 3/4 * rttvar + 1/4 * rttvar_sample
</pre>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#loss-detection" id="loss-detection">Loss Detection</a>
</h1>
<p id="rfc.section.5.p.1">QUIC senders use both ack information and timeouts to detect lost packets, and this section provides a description of these algorithms.</p>
<p id="rfc.section.5.p.2">If a packet is lost, the QUIC transport needs to recover from that loss, such as by retransmitting the data, sending an updated frame, or abandoning the frame.  For more information, see Section 13.3 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.</p>
<h2 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#ack-loss-detection" id="ack-loss-detection">Acknowledgement-based Detection</a>
</h2>
<p id="rfc.section.5.1.p.1">Acknowledgement-based loss detection implements the spirit of TCP&#8217;s Fast Retransmit <a href="#RFC5681" class="xref">[RFC5681]</a>, Early Retransmit <a href="#RFC5827" class="xref">[RFC5827]</a>, FACK <a href="#FACK" class="xref">[FACK]</a>, SACK loss recovery <a href="#RFC6675" class="xref">[RFC6675]</a>, and RACK <a href="#RACK" class="xref">[RACK]</a>. This section provides an overview of how these algorithms are implemented in QUIC.</p>
<p id="rfc.section.5.1.p.2">A packet is declared lost if it meets all the following conditions:</p>
<p></p>

<ul>
<li>The packet is unacknowledged, in-flight, and was sent prior to an acknowledged packet.</li>
<li>Either its packet number is kPacketThreshold smaller than an acknowledged packet (<a href="#packet-threshold" class="xref">Section 5.1.1</a>), or it was sent long enough in the past (<a href="#time-threshold" class="xref">Section 5.1.2</a>).</li>
</ul>
<p id="rfc.section.5.1.p.4">The acknowledgement indicates that a packet sent later was delivered, while the packet and time thresholds provide some tolerance for packet reordering.</p>
<p id="rfc.section.5.1.p.5">Spuriously declaring packets as lost may lead to unnecessary retransmissions and can result in degraded performance due to the actions of the congestion controller upon detecting loss.</p>
<p id="rfc.section.5.1.p.6">Implementations can detect spurious retransmissions by tracking packets for a period of time after they&#8217;ve been declared lost.  For example, implementations can wait for at least one RTT by waiting for a packet sent after the packet was declared lost to be acknowledged.</p>
<p id="rfc.section.5.1.p.7">Implementations that detect spurious retransmissions can increase the reordering threshold in packets or time and MAY choose to start with smaller initial reordering thresholds to minimize recovery latency.</p>
<h3 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#packet-threshold" id="packet-threshold">Packet Threshold</a>
</h3>
<p id="rfc.section.5.1.1.p.1">The RECOMMENDED initial value for the packet reordering threshold (kPacketThreshold) is 3, based on best practices for TCP loss detection <a href="#RFC5681" class="xref">[RFC5681]</a> <a href="#RFC6675" class="xref">[RFC6675]</a>.</p>
<p id="rfc.section.5.1.1.p.2">Some networks may exhibit higher degrees of reordering, causing a sender to detect spurious losses.  Implementers MAY use algorithms developed for TCP, such as TCP-NCR <a href="#RFC4653" class="xref">[RFC4653]</a>, to improve QUIC&#8217;s reordering resilience.</p>
<h3 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#time-threshold" id="time-threshold">Time Threshold</a>
</h3>
<p id="rfc.section.5.1.2.p.1">Once a later packet packet within the same packet number space has been acknowledged, an endpoint SHOULD declare an earlier packet lost if it was sent a threshold amount of time in the past. To avoid declaring packets as lost too early, this time threshold MUST be set to at least kGranularity.  The time threshold is:</p>
<pre>
kTimeThreshold * max(SRTT, latest_RTT, kGranularity)
</pre>
<p id="rfc.section.5.1.2.p.2">If packets sent prior to the largest acknowledged packet cannot yet be declared lost, then a timer SHOULD be set for the remaining time.</p>
<p id="rfc.section.5.1.2.p.3">Using max(SRTT, latest_RTT) protects from the two following cases:</p>
<p></p>

<ul>
<li>the latest RTT sample is lower than the SRTT, perhaps due to reordering where the acknowledgement encountered a shorter path;</li>
<li>the latest RTT sample is higher than the SRTT, perhaps due to a sustained increase in the actual RTT, but the smoothed SRTT has not yet caught up.</li>
</ul>
<p id="rfc.section.5.1.2.p.5">The RECOMMENDED time threshold (kTimeThreshold), expressed as a round-trip time multiplier, is 9/8.</p>
<p id="rfc.section.5.1.2.p.6">Implementations MAY experiment with absolute thresholds, thresholds from previous connections, adaptive thresholds, or including RTT variance.  Smaller thresholds reduce reordering resilience and increase spurious retransmissions, and larger thresholds increase loss detection delay.</p>
<h2 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#pto" id="pto">Probe Timeout</a>
</h2>
<p id="rfc.section.5.2.p.1">A Probe Timeout (PTO) triggers sending one or two probe datagrams when ack-eliciting packets are not acknowledged within the expected period of time or the handshake has not been completed.  A PTO enables a connection to recover from loss of tail packets or acknowledgements. The PTO algorithm used in QUIC implements the reliability functions of Tail Loss Probe <a href="#TLP" class="xref">[TLP]</a> <a href="#RACK" class="xref">[RACK]</a>, RTO <a href="#RFC5681" class="xref">[RFC5681]</a> and F-RTO algorithms for TCP <a href="#RFC5682" class="xref">[RFC5682]</a>, and the timeout computation is based on TCP&#8217;s retransmission timeout period <a href="#RFC6298" class="xref">[RFC6298]</a>.</p>
<h3 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#computing-pto" id="computing-pto">Computing PTO</a>
</h3>
<p id="rfc.section.5.2.1.p.1">When an ack-eliciting packet is transmitted, the sender schedules a timer for the PTO period as follows:</p>
<pre>
PTO = smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay
</pre>
<p id="rfc.section.5.2.1.p.2">kGranularity, smoothed_rtt, rttvar, and max_ack_delay are defined in <a href="#ld-consts-of-interest" class="xref">Appendix A.2</a> and <a href="#ld-vars-of-interest" class="xref">Appendix A.3</a>.</p>
<p id="rfc.section.5.2.1.p.3">The PTO period is the amount of time that a sender ought to wait for an acknowledgement of a sent packet.  This time period includes the estimated network roundtrip-time (smoothed_rtt), the variance in the estimate (4*rttvar), and max_ack_delay, to account for the maximum time by which a receiver might delay sending an acknowledgement.</p>
<p id="rfc.section.5.2.1.p.4">The PTO value MUST be set to at least kGranularity, to avoid the timer expiring immediately.</p>
<p id="rfc.section.5.2.1.p.5">When a PTO timer expires, the PTO period MUST be set to twice its current value. This exponential reduction in the sender&#8217;s rate is important because the PTOs might be caused by loss of packets or acknowledgements due to severe congestion.  The life of a connection that is experiencing consecutive PTOs is limited by the endpoint&#8217;s idle timeout.</p>
<p id="rfc.section.5.2.1.p.6">A sender computes its PTO timer every time an ack-eliciting packet is sent. A sender might choose to optimize this by setting the timer fewer times if it knows that more ack-eliciting packets will be sent within a short period of time.</p>
<p id="rfc.section.5.2.1.p.7">The probe timer is not set if the time threshold <a href="#time-threshold" class="xref">Section 5.1.2</a> loss detection timer is set.  The time threshold loss detection timer is expected to both expire earlier than the PTO and be less likely to spuriously retransmit data.</p>
<h2 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#handshakes-and-new-paths" id="handshakes-and-new-paths">Handshakes and New Paths</a>
</h2>
<p id="rfc.section.5.3.p.1">The initial probe timeout for a new connection or new path SHOULD be set to twice the initial RTT.  Resumed connections over the same network SHOULD use the previous connection&#8217;s final smoothed RTT value as the resumed connection&#8217;s initial RTT.  If no previous RTT is available, the initial RTT SHOULD be set to 500ms, resulting in a 1 second initial timeout as recommended in <a href="#RFC6298" class="xref">[RFC6298]</a>.</p>
<p id="rfc.section.5.3.p.2">A connection MAY use the delay between sending a PATH_CHALLENGE and receiving a PATH_RESPONSE to seed initial_rtt for a new path, but the delay SHOULD NOT be considered an RTT sample.</p>
<p id="rfc.section.5.3.p.3">Until the server has validated the client&#8217;s address on the path, the amount of data it can send is limited, as specified in Section 8.1 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.  Data at Initial encryption MUST be retransmitted before Handshake data and data at Handshake encryption MUST be retransmitted before any ApplicationData data.  If no data can be sent, then the PTO alarm MUST NOT be armed until data has been received from the client.</p>
<p id="rfc.section.5.3.p.4">Since the server could be blocked until more packets are received from the client, it is the client&#8217;s responsibility to send packets to unblock the server until it is certain that the server has finished its address validation (see Section 8 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>).  That is, the client MUST set the probe timer if the client has not received an acknowledgement for one of its Handshake or 1-RTT packets.</p>
<p id="rfc.section.5.3.p.5">Prior to handshake completion, when few to none RTT samples have been generated, it is possible that the probe timer expiration is due to an incorrect RTT estimate at the client. To allow the client to improve its RTT estimate, the new packet that it sends MUST be ack-eliciting.  If Handshake keys are available to the client, it MUST send a Handshake packet, and otherwise it MUST send an Initial packet in a UDP datagram of at least 1200 bytes.</p>
<p id="rfc.section.5.3.p.6">Initial packets and Handshake packets may never be acknowledged, but they are removed from bytes in flight when the Initial and Handshake keys are discarded.</p>
<h3 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#sending-probe-packets" id="sending-probe-packets">Sending Probe Packets</a>
</h3>
<p id="rfc.section.5.3.1.p.1">When a PTO timer expires, a sender MUST send at least one ack-eliciting packet as a probe, unless there is no data available to send.  An endpoint MAY send up to two full-sized datagrams containing ack-eliciting packets, to avoid an expensive consecutive PTO expiration due to a single lost datagram.</p>
<p id="rfc.section.5.3.1.p.2">It is possible that the sender has no new or previously-sent data to send.  As an example, consider the following sequence of events: new application data is sent in a STREAM frame, deemed lost, then retransmitted in a new packet, and then the original transmission is acknowledged.  In the absence of any new application data, a PTO timer expiration now would find the sender with no new or previously-sent data to send.</p>
<p id="rfc.section.5.3.1.p.3">When there is no data to send, the sender SHOULD send a PING or other ack-eliciting frame in a single packet, re-arming the PTO timer.</p>
<p id="rfc.section.5.3.1.p.4">Alternatively, instead of sending an ack-eliciting packet, the sender MAY mark any packets still in flight as lost.  Doing so avoids sending an additional packet, but increases the risk that loss is declared too aggressively, resulting in an unnecessary rate reduction by the congestion controller.</p>
<p id="rfc.section.5.3.1.p.5">Consecutive PTO periods increase exponentially, and as a result, connection recovery latency increases exponentially as packets continue to be dropped in the network.  Sending two packets on PTO expiration increases resilience to packet drops, thus reducing the probability of consecutive PTO events.</p>
<p id="rfc.section.5.3.1.p.6">Probe packets sent on a PTO MUST be ack-eliciting.  A probe packet SHOULD carry new data when possible.  A probe packet MAY carry retransmitted unacknowledged data when new data is unavailable, when flow control does not permit new data to be sent, or to opportunistically reduce loss recovery delay.  Implementations MAY use alternate strategies for determining the content of probe packets, including sending new or retransmitted data based on the application&#8217;s priorities.</p>
<p id="rfc.section.5.3.1.p.7">When the PTO timer expires multiple times and new data cannot be sent, implementations must choose between sending the same payload every time or sending different payloads.  Sending the same payload may be simpler and ensures the highest priority frames arrive first.  Sending different payloads each time reduces the chances of spurious retransmission.</p>
<h3 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#pto-loss" id="pto-loss">Loss Detection</a>
</h3>
<p id="rfc.section.5.3.2.p.1">Delivery or loss of packets in flight is established when an ACK frame is received that newly acknowledges one or more packets.</p>
<p id="rfc.section.5.3.2.p.2">A PTO timer expiration event does not indicate packet loss and MUST NOT cause prior unacknowledged packets to be marked as lost. When an acknowledgement is received that newly acknowledges packets, loss detection proceeds as dictated by packet and time threshold mechanisms; see <a href="#ack-loss-detection" class="xref">Section 5.1</a>.</p>
<h2 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#retry-and-version-negotiation" id="retry-and-version-negotiation">Retry and Version Negotiation</a>
</h2>
<p id="rfc.section.5.4.p.1">A Retry or Version Negotiation packet causes a client to send another Initial packet, effectively restarting the connection process and resetting congestion control and loss recovery state, including resetting any pending timers.  Either packet indicates that the Initial was received but not processed.  Neither packet can be treated as an acknowledgment for the Initial.</p>
<p id="rfc.section.5.4.p.2">The client MAY however compute an RTT estimate to the server as the time period from when the first Initial was sent to when a Retry or a Version Negotiation packet is received.  The client MAY use this value to seed the RTT estimator for a subsequent connection attempt to the server.</p>
<h2 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#discarding-packets" id="discarding-packets">Discarding Keys and Packet State</a>
</h2>
<p id="rfc.section.5.5.p.1">When packet protection keys are discarded (see Section 4.9 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>), all packets that were sent with those keys can no longer be acknowledged because their acknowledgements cannot be processed anymore. The sender MUST discard all recovery state associated with those packets and MUST remove them from the count of bytes in flight.</p>
<p id="rfc.section.5.5.p.2">Endpoints stop sending and receiving Initial packets once they start exchanging Handshake packets (see Section 17.2.2.1 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>). At this point, recovery state for all in-flight Initial packets is discarded.</p>
<p id="rfc.section.5.5.p.3">When 0-RTT is rejected, recovery state for all in-flight 0-RTT packets is discarded.</p>
<p id="rfc.section.5.5.p.4">If a server accepts 0-RTT, but does not buffer 0-RTT packets that arrive before Initial packets, early 0-RTT packets will be declared lost, but that is expected to be infrequent.</p>
<p id="rfc.section.5.5.p.5">It is expected that keys are discarded after packets encrypted with them would be acknowledged or declared lost.  Initial secrets however might be destroyed sooner, as soon as handshake keys are available (see Section 4.9.1 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>).</p>
<h2 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#discussion" id="discussion">Discussion</a>
</h2>
<p id="rfc.section.5.6.p.1">The majority of constants were derived from best common practices among widely deployed TCP implementations on the internet.  Exceptions follow.</p>
<p id="rfc.section.5.6.p.2">A shorter delayed ack time of 25ms was chosen because longer delayed acks can delay loss recovery and for the small number of connections where less than packet per 25ms is delivered, acking every packet is beneficial to congestion control and loss recovery.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#congestion-control" id="congestion-control">Congestion Control</a>
</h1>
<p id="rfc.section.6.p.1">QUIC&#8217;s congestion control is based on TCP NewReno <a href="#RFC6582" class="xref">[RFC6582]</a>.  NewReno is a congestion window based congestion control.  QUIC specifies the congestion window in bytes rather than packets due to finer control and the ease of appropriate byte counting <a href="#RFC3465" class="xref">[RFC3465]</a>.</p>
<p id="rfc.section.6.p.2">QUIC hosts MUST NOT send packets if they would increase bytes_in_flight (defined in <a href="#vars-of-interest" class="xref">Appendix B.2</a>) beyond the available congestion window, unless the packet is a probe packet sent after a PTO timer expires, as described in <a href="#pto" class="xref">Section 5.2</a>.</p>
<p id="rfc.section.6.p.3">Implementations MAY use other congestion control algorithms, such as Cubic <a href="#RFC8312" class="xref">[RFC8312]</a>, and endpoints MAY use different algorithms from one another.  The signals QUIC provides for congestion control are generic and are designed to support different algorithms.</p>
<h2 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#congestion-ecn" id="congestion-ecn">Explicit Congestion Notification</a>
</h2>
<p id="rfc.section.6.1.p.1">If a path has been verified to support ECN, QUIC treats a Congestion Experienced codepoint in the IP header as a signal of congestion. This document specifies an endpoint&#8217;s response when its peer receives packets with the Congestion Experienced codepoint.  As discussed in <a href="#RFC8311" class="xref">[RFC8311]</a>, endpoints are permitted to experiment with other response functions.</p>
<h2 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#slow-start" id="slow-start">Slow Start</a>
</h2>
<p id="rfc.section.6.2.p.1">QUIC begins every connection in slow start and exits slow start upon loss or upon increase in the ECN-CE counter. QUIC re-enters slow start anytime the congestion window is less than ssthresh, which only occurs after persistent congestion is declared. While in slow start, QUIC increases the congestion window by the number of bytes acknowledged when each acknowledgment is processed.</p>
<h2 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#congestion-avoidance" id="congestion-avoidance">Congestion Avoidance</a>
</h2>
<p id="rfc.section.6.3.p.1">Slow start exits to congestion avoidance.  Congestion avoidance in NewReno uses an additive increase multiplicative decrease (AIMD) approach that increases the congestion window by one maximum packet size per congestion window acknowledged.  When a loss is detected, NewReno halves the congestion window and sets the slow start threshold to the new congestion window.</p>
<h2 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#recovery-period" id="recovery-period">Recovery Period</a>
</h2>
<p id="rfc.section.6.4.p.1">Recovery is a period of time beginning with detection of a lost packet or an increase in the ECN-CE counter. Because QUIC does not retransmit packets, it defines the end of recovery as a packet sent after the start of recovery being acknowledged. This is slightly different from TCP&#8217;s definition of recovery, which ends when the lost packet that started recovery is acknowledged.</p>
<p id="rfc.section.6.4.p.2">The recovery period limits congestion window reduction to once per round trip.  During recovery, the congestion window remains unchanged irrespective of new losses or increases in the ECN-CE counter.</p>
<h2 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> <a href="#ignoring-loss-of-undecryptable-packets" id="ignoring-loss-of-undecryptable-packets">Ignoring Loss of Undecryptable Packets</a>
</h2>
<p id="rfc.section.6.5.p.1">During the handshake, some packet protection keys might not be available when a packet arrives. In particular, Handshake and 0-RTT packets cannot be processed until the Initial packets arrive, and 1-RTT packets cannot be processed until the handshake completes.  Endpoints MAY ignore the loss of Handshake, 0-RTT, and 1-RTT packets that might arrive before the peer has packet protection keys to process those packets.</p>
<h2 id="rfc.section.6.6">
<a href="#rfc.section.6.6">6.6.</a> <a href="#probe-timeout" id="probe-timeout">Probe Timeout</a>
</h2>
<p id="rfc.section.6.6.p.1">Probe packets MUST NOT be blocked by the congestion controller.  A sender MUST however count these packets as being additionally in flight, since these packets add network load without establishing packet loss.  Note that sending probe packets might cause the sender&#8217;s bytes in flight to exceed the congestion window until an acknowledgement is received that establishes loss or delivery of packets.</p>
<h2 id="rfc.section.6.7">
<a href="#rfc.section.6.7">6.7.</a> <a href="#persistent-congestion" id="persistent-congestion">Persistent Congestion</a>
</h2>
<p id="rfc.section.6.7.p.1">When an ACK frame is received that establishes loss of all in-flight packets sent over a long enough period of time, the network is considered to be experiencing persistent congestion.  Commonly, this can be established by consecutive PTOs, but since the PTO timer is reset when a new ack-eliciting packet is sent, an explicit duration must be used to account for those cases where PTOs do not occur or are substantially delayed.  This duration is computed as follows:</p>
<pre>
(smoothed_rtt + 4 * rttvar + max_ack_delay) *
    kPersistentCongestionThreshold
</pre>
<p id="rfc.section.6.7.p.2">For example, assume:</p>
<p id="rfc.section.6.7.p.3">smoothed_rtt = 1 rttvar = 0 max_ack_delay = 0 kPersistentCongestionThreshold = 3</p>
<p id="rfc.section.6.7.p.4">If an ack-eliciting packet is sent at time = 0, the following scenario would illustrate persistent congestion:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">t=0</th>
<th class="left">Send Pkt #1 (App Data)</th>
</tr></thead>
<tbody>
<tr>
<td class="left">t=1</td>
<td class="left">Send Pkt #2 (PTO 1)</td>
</tr>
<tr>
<td class="left">t=3</td>
<td class="left">Send Pkt #3 (PTO 2)</td>
</tr>
<tr>
<td class="left">t=7</td>
<td class="left">Send Pkt #4 (PTO 3)</td>
</tr>
<tr>
<td class="left">t=8</td>
<td class="left">Recv ACK of Pkt #4</td>
</tr>
</tbody>
</table>
<p id="rfc.section.6.7.p.5">The first three packets are determined to be lost when the ACK of packet 4 is received at t=8.  The congestion period is calculated as the time between the oldest and newest lost packets: (3 - 0) = 3.  The duration for persistent congestion is equal to: (1 * kPersistentCongestionThreshold) = 3.  Because the threshold was reached and because none of the packets between the oldest and the newest packets are acknowledged, the network is considered to have experienced persistent congestion.</p>
<p id="rfc.section.6.7.p.6">When persistent congestion is established, the sender&#8217;s congestion window MUST be reduced to the minimum congestion window (kMinimumWindow).  This response of collapsing the congestion window on persistent congestion is functionally similar to a sender&#8217;s response on a Retransmission Timeout (RTO) in TCP <a href="#RFC5681" class="xref">[RFC5681]</a> after Tail Loss Probes (TLP) <a href="#TLP" class="xref">[TLP]</a>.</p>
<h2 id="rfc.section.6.8">
<a href="#rfc.section.6.8">6.8.</a> <a href="#pacing" id="pacing">Pacing</a>
</h2>
<p id="rfc.section.6.8.p.1">This document does not specify a pacer, but it is RECOMMENDED that a sender pace sending of all in-flight packets based on input from the congestion controller. For example, a pacer might distribute the congestion window over the SRTT when used with a window-based controller, and a pacer might use the rate estimate of a rate-based controller.</p>
<p id="rfc.section.6.8.p.2">An implementation should take care to architect its congestion controller to work well with a pacer.  For instance, a pacer might wrap the congestion controller and control the availability of the congestion window, or a pacer might pace out packets handed to it by the congestion controller. Timely delivery of ACK frames is important for efficient loss recovery. Packets containing only ACK frames should therefore not be paced, to avoid delaying their delivery to the peer.</p>
<p id="rfc.section.6.8.p.3">As an example of a well-known and publicly available implementation of a flow pacer, implementers are referred to the Fair Queue packet scheduler (fq qdisc) in Linux (3.11 onwards).</p>
<h2 id="rfc.section.6.9">
<a href="#rfc.section.6.9">6.9.</a> <a href="#under-utilizing-the-congestion-window" id="under-utilizing-the-congestion-window">Under-utilizing the Congestion Window</a>
</h2>
<p id="rfc.section.6.9.p.1">A congestion window that is under-utilized SHOULD NOT be increased in either slow start or congestion avoidance. This can happen due to insufficient application data or flow control credit.</p>
<p id="rfc.section.6.9.p.2">A sender MAY use the pipeACK method described in section 4.3 of <a href="#RFC7661" class="xref">[RFC7661]</a> to determine if the congestion window is sufficiently utilized.</p>
<p id="rfc.section.6.9.p.3">A sender that paces packets (see <a href="#pacing" class="xref">Section 6.8</a>) might delay sending packets and not fully utilize the congestion window due to this delay. A sender should not consider itself application limited if it would have fully utilized the congestion window without pacing delay.</p>
<p id="rfc.section.6.9.p.4">Bursting more than an initial window&#8217;s worth of data into the network might cause short-term congestion and losses. Implemementations SHOULD either use pacing or reduce their congestion window to limit such bursts.</p>
<p id="rfc.section.6.9.p.5">A sender MAY implement alternate mechanisms to update its congestion window after periods of under-utilization, such as those proposed for TCP in <a href="#RFC7661" class="xref">[RFC7661]</a>.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<h2 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#congestion-signals" id="congestion-signals">Congestion Signals</a>
</h2>
<p id="rfc.section.7.1.p.1">Congestion control fundamentally involves the consumption of signals &#8211; both loss and ECN codepoints &#8211; from unauthenticated entities.  On-path attackers can spoof or alter these signals.  An attacker can cause endpoints to reduce their sending rate by dropping packets, or alter send rate by changing ECN codepoints.</p>
<h2 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#traffic-analysis" id="traffic-analysis">Traffic Analysis</a>
</h2>
<p id="rfc.section.7.2.p.1">Packets that carry only ACK frames can be heuristically identified by observing packet size.  Acknowledgement patterns may expose information about link characteristics or application behavior.  Endpoints can use PADDING frames or bundle acknowledgments with other frames to reduce leaked information.</p>
<h2 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#misreporting-ecn-markings" id="misreporting-ecn-markings">Misreporting ECN Markings</a>
</h2>
<p id="rfc.section.7.3.p.1">A receiver can misreport ECN markings to alter the congestion response of a sender.  Suppressing reports of ECN-CE markings could cause a sender to increase their send rate.  This increase could result in congestion and loss.</p>
<p id="rfc.section.7.3.p.2">A sender MAY attempt to detect suppression of reports by marking occasional packets that they send with ECN-CE.  If a packet marked with ECN-CE is not reported as having been marked when the packet is acknowledged, the sender SHOULD then disable ECN for that path.</p>
<p id="rfc.section.7.3.p.3">Reporting additional ECN-CE markings will cause a sender to reduce their sending rate, which is similar in effect to advertising reduced connection flow control limits and so no advantage is gained by doing so.</p>
<p id="rfc.section.7.3.p.4">Endpoints choose the congestion controller that they use.  Though congestion controllers generally treat reports of ECN-CE markings as equivalent to loss <a href="#RFC8311" class="xref">[RFC8311]</a>, the exact response for each controller could be different.  Failure to correctly respond to information about ECN markings is therefore difficult to detect.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This document has no IANA actions.  Yet.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h2 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Normative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="QUIC-TLS">[QUIC-TLS]</b></td>
<td class="top">
<a title="Mozilla">Thomson, M.</a> and <a title="sn3rd">S. Turner</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-tls">Using TLS to Secure QUIC</a>", Internet-Draft draft-ietf-quic-tls, September 2019.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</b></td>
<td class="top">
<a title="Fastly">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport, September 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8311">[RFC8311]</b></td>
<td class="top">
<a>Black, D.</a>, "<a href="https://tools.ietf.org/html/rfc8311">Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation</a>", RFC 8311, DOI 10.17487/RFC8311, January 2018.</td>
</tr>
</tbody></table>
<h2 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Informative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="FACK">[FACK]</b></td>
<td class="top">
<a>Mathis, M.</a> and <a>J. Mahdavi</a>, "<a>Forward Acknowledgement: Refining TCP Congestion Control</a>", ACM SIGCOMM , August 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RACK">[RACK]</b></td>
<td class="top">
<a>Cheng, Y.</a>, <a>Cardwell, N.</a>, <a>Dukkipati, N.</a> and <a>P. Jha</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tcpm-rack-05">RACK: a time-based fast loss detection algorithm for TCP</a>", Internet-Draft draft-ietf-tcpm-rack-05, April 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3465">[RFC3465]</b></td>
<td class="top">
<a>Allman, M.</a>, "<a href="https://tools.ietf.org/html/rfc3465">TCP Congestion Control with Appropriate Byte Counting (ABC)</a>", RFC 3465, DOI 10.17487/RFC3465, February 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4653">[RFC4653]</b></td>
<td class="top">
<a>Bhandarkar, S.</a>, <a>Reddy, A.</a>, <a>Allman, M.</a> and <a>E. Blanton</a>, "<a href="https://tools.ietf.org/html/rfc4653">Improving the Robustness of TCP to Non-Congestion Events</a>", RFC 4653, DOI 10.17487/RFC4653, August 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5681">[RFC5681]</b></td>
<td class="top">
<a>Allman, M.</a>, <a>Paxson, V.</a> and <a>E. Blanton</a>, "<a href="https://tools.ietf.org/html/rfc5681">TCP Congestion Control</a>", RFC 5681, DOI 10.17487/RFC5681, September 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5682">[RFC5682]</b></td>
<td class="top">
<a>Sarolahti, P.</a>, <a>Kojo, M.</a>, <a>Yamamoto, K.</a> and <a>M. Hata</a>, "<a href="https://tools.ietf.org/html/rfc5682">Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP</a>", RFC 5682, DOI 10.17487/RFC5682, September 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5827">[RFC5827]</b></td>
<td class="top">
<a>Allman, M.</a>, <a>Avrachenkov, K.</a>, <a>Ayesta, U.</a>, <a>Blanton, J.</a> and <a>P. Hurtig</a>, "<a href="https://tools.ietf.org/html/rfc5827">Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP)</a>", RFC 5827, DOI 10.17487/RFC5827, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6298">[RFC6298]</b></td>
<td class="top">
<a>Paxson, V.</a>, <a>Allman, M.</a>, <a>Chu, J.</a> and <a>M. Sargent</a>, "<a href="https://tools.ietf.org/html/rfc6298">Computing TCP's Retransmission Timer</a>", RFC 6298, DOI 10.17487/RFC6298, June 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6582">[RFC6582]</b></td>
<td class="top">
<a>Henderson, T.</a>, <a>Floyd, S.</a>, <a>Gurtov, A.</a> and <a>Y. Nishida</a>, "<a href="https://tools.ietf.org/html/rfc6582">The NewReno Modification to TCP's Fast Recovery Algorithm</a>", RFC 6582, DOI 10.17487/RFC6582, April 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6675">[RFC6675]</b></td>
<td class="top">
<a>Blanton, E.</a>, <a>Allman, M.</a>, <a>Wang, L.</a>, <a>Jarvinen, I.</a>, <a>Kojo, M.</a> and <a>Y. Nishida</a>, "<a href="https://tools.ietf.org/html/rfc6675">A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP</a>", RFC 6675, DOI 10.17487/RFC6675, August 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6928">[RFC6928]</b></td>
<td class="top">
<a>Chu, J.</a>, <a>Dukkipati, N.</a>, <a>Cheng, Y.</a> and <a>M. Mathis</a>, "<a href="https://tools.ietf.org/html/rfc6928">Increasing TCP's Initial Window</a>", RFC 6928, DOI 10.17487/RFC6928, April 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7661">[RFC7661]</b></td>
<td class="top">
<a>Fairhurst, G.</a>, <a>Sathiaseelan, A.</a> and <a>R. Secchi</a>, "<a href="https://tools.ietf.org/html/rfc7661">Updating TCP to Support Rate-Limited Traffic</a>", RFC 7661, DOI 10.17487/RFC7661, October 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8312">[RFC8312]</b></td>
<td class="top">
<a>Rhee, I.</a>, <a>Xu, L.</a>, <a>Ha, S.</a>, <a>Zimmermann, A.</a>, <a>Eggert, L.</a> and <a>R. Scheffenegger</a>, "<a href="https://tools.ietf.org/html/rfc8312">CUBIC for Fast Long-Distance Networks</a>", RFC 8312, DOI 10.17487/RFC8312, February 2018.</td>
</tr>
<tr>
<td class="reference"><b id="TLP">[TLP]</b></td>
<td class="top">
<a>Dukkipati, N.</a>, <a>Cardwell, N.</a>, <a>Cheng, Y.</a> and <a>M. Mathis</a>, "<a href="https://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01">Tail Loss Probe (TLP): An Algorithm for Fast Recovery of Tail Losses</a>", Internet-Draft draft-dukkipati-tcpm-tcp-loss-probe-01, February 2013.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#loss-recovery-pseudocode" id="loss-recovery-pseudocode">Loss Recovery Pseudocode</a>
</h1>
<p id="rfc.section.A.p.1">We now describe an example implementation of the loss detection mechanisms described in <a href="#loss-detection" class="xref">Section 5</a>.</p>
<h2 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#tracking-sent-packets" id="tracking-sent-packets">Tracking Sent Packets</a>
</h2>
<p id="rfc.section.A.1.p.1">To correctly implement congestion control, a QUIC sender tracks every ack-eliciting packet until the packet is acknowledged or lost.  It is expected that implementations will be able to access this information by packet number and crypto context and store the per-packet fields (<a href="#sent-packets-fields" class="xref">Appendix A.1.1</a>) for loss recovery and congestion control.</p>
<p id="rfc.section.A.1.p.2">After a packet is declared lost, the endpoint can track it for an amount of time comparable to the maximum expected packet reordering, such as 1 RTT.  This allows for detection of spurious retransmissions.</p>
<p id="rfc.section.A.1.p.3">Sent packets are tracked for each packet number space, and ACK processing only applies to a single space.</p>
<h3 id="rfc.appendix.A.1.1">
<a href="#rfc.appendix.A.1.1">A.1.1.</a> <a href="#sent-packets-fields" id="sent-packets-fields">Sent Packet Fields</a>
</h3>
<p></p>

<dl>
<dt>packet_number:</dt>
<dd style="margin-left: 8">The packet number of the sent packet.</dd>
<dt>ack_eliciting:</dt>
<dd style="margin-left: 8">A boolean that indicates whether a packet is ack-eliciting.  If true, it is expected that an acknowledgement will be received, though the peer could delay sending the ACK frame containing it by up to the MaxAckDelay.</dd>
<dt>in_flight:</dt>
<dd style="margin-left: 8">A boolean that indicates whether the packet counts towards bytes in flight.</dd>
<dt>sent_bytes:</dt>
<dd style="margin-left: 8">The number of bytes sent in the packet, not including UDP or IP overhead, but including QUIC framing overhead.</dd>
<dt>time_sent:</dt>
<dd style="margin-left: 8">The time the packet was sent.</dd>
</dl>
<h2 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#ld-consts-of-interest" id="ld-consts-of-interest">Constants of interest</a>
</h2>
<p id="rfc.section.A.2.p.1">Constants used in loss recovery are based on a combination of RFCs, papers, and common practice.  Some may need to be changed or negotiated in order to better suit a variety of environments.</p>
<p></p>

<dl>
<dt>kPacketThreshold:</dt>
<dd style="margin-left: 8">Maximum reordering in packets before packet threshold loss detection considers a packet lost. The RECOMMENDED value is 3.</dd>
<dt>kTimeThreshold:</dt>
<dd style="margin-left: 8">Maximum reordering in time before time threshold loss detection considers a packet lost. Specified as an RTT multiplier. The RECOMMENDED value is 9/8.</dd>
<dt>kGranularity:</dt>
<dd style="margin-left: 8">Timer granularity. This is a system-dependent value.  However, implementations SHOULD use a value no smaller than 1ms.</dd>
<dt>kInitialRtt:</dt>
<dd style="margin-left: 8">The RTT used before an RTT sample is taken. The RECOMMENDED value is 500ms.</dd>
<dt>kPacketNumberSpace:</dt>
<dd style="margin-left: 8">An enum to enumerate the three packet number spaces.</dd>
</dl>
<pre>
  enum kPacketNumberSpace {
    Initial,
    Handshake,
    ApplicationData,
  }
</pre>
<h2 id="rfc.appendix.A.3">
<a href="#rfc.appendix.A.3">A.3.</a> <a href="#ld-vars-of-interest" id="ld-vars-of-interest">Variables of interest</a>
</h2>
<p id="rfc.section.A.3.p.1">Variables required to implement the congestion control mechanisms are described in this section.</p>
<p></p>

<dl>
<dt>latest_rtt:</dt>
<dd style="margin-left: 8">The most recent RTT measurement made when receiving an ack for a previously unacked packet.</dd>
<dt>smoothed_rtt:</dt>
<dd style="margin-left: 8">The smoothed RTT of the connection, computed as described in <a href="#RFC6298" class="xref">[RFC6298]</a>
</dd>
<dt>rttvar:</dt>
<dd style="margin-left: 8">The RTT variance, computed as described in <a href="#RFC6298" class="xref">[RFC6298]</a>
</dd>
<dt>min_rtt:</dt>
<dd style="margin-left: 8">The minimum RTT seen in the connection, ignoring ack delay.</dd>
<dt>max_ack_delay:</dt>
<dd style="margin-left: 8">The maximum amount of time by which the receiver intends to delay acknowledgments for packets in the ApplicationData packet number space. The actual ack_delay in a received ACK frame may be larger due to late timers, reordering, or lost ACKs.</dd>
<dt>loss_detection_timer:</dt>
<dd style="margin-left: 8">Multi-modal timer used for loss detection.</dd>
<dt>pto_count:</dt>
<dd style="margin-left: 8">The number of times a PTO has been sent without receiving an ack.</dd>
<dt>time_of_last_sent_ack_eliciting_packet:</dt>
<dd style="margin-left: 8">The time the most recent ack-eliciting packet was sent.</dd>
<dt>largest_acked_packet[kPacketNumberSpace]:</dt>
<dd style="margin-left: 8">The largest packet number acknowledged in the packet number space so far.</dd>
<dt>loss_time[kPacketNumberSpace]:</dt>
<dd style="margin-left: 8">The time at which the next packet in that packet number space will be considered lost based on exceeding the reordering window in time.</dd>
<dt>sent_packets[kPacketNumberSpace]:</dt>
<dd style="margin-left: 8">An association of packet numbers in a packet number space to information about them.  Described in detail above in <a href="#tracking-sent-packets" class="xref">Appendix A.1</a>.</dd>
</dl>
<h2 id="rfc.appendix.A.4">
<a href="#rfc.appendix.A.4">A.4.</a> <a href="#initialization" id="initialization">Initialization</a>
</h2>
<p id="rfc.section.A.4.p.1">At the beginning of the connection, initialize the loss detection variables as follows:</p>
<pre>
   loss_detection_timer.reset()
   pto_count = 0
   latest_rtt = 0
   smoothed_rtt = 0
   rttvar = 0
   min_rtt = 0
   max_ack_delay = 0
   time_of_last_sent_ack_eliciting_packet = 0
   for pn_space in [ Initial, Handshake, ApplicationData ]:
     largest_acked_packet[pn_space] = infinite
     loss_time[pn_space] = 0
</pre>
<h2 id="rfc.appendix.A.5">
<a href="#rfc.appendix.A.5">A.5.</a> <a href="#on-sending-a-packet" id="on-sending-a-packet">On Sending a Packet</a>
</h2>
<p id="rfc.section.A.5.p.1">After a packet is sent, information about the packet is stored.  The parameters to OnPacketSent are described in detail above in <a href="#sent-packets-fields" class="xref">Appendix A.1.1</a>.</p>
<p id="rfc.section.A.5.p.2">Pseudocode for OnPacketSent follows:</p>
<pre>
 OnPacketSent(packet_number, pn_space, ack_eliciting,
              in_flight, sent_bytes):
   sent_packets[pn_space][packet_number].packet_number =
                                            packet_number
   sent_packets[pn_space][packet_number].time_sent = now
   sent_packets[pn_space][packet_number].ack_eliciting =
                                            ack_eliciting
   sent_packets[pn_space][packet_number].in_flight = in_flight
   if (in_flight):
     if (ack_eliciting):
       time_of_last_sent_ack_eliciting_packet = now
     OnPacketSentCC(sent_bytes)
     sent_packets[pn_space][packet_number].size = sent_bytes
     SetLossDetectionTimer()
</pre>
<h2 id="rfc.appendix.A.6">
<a href="#rfc.appendix.A.6">A.6.</a> <a href="#on-receiving-an-acknowledgment" id="on-receiving-an-acknowledgment">On Receiving an Acknowledgment</a>
</h2>
<p id="rfc.section.A.6.p.1">When an ACK frame is received, it may newly acknowledge any number of packets.</p>
<p id="rfc.section.A.6.p.2">Pseudocode for OnAckReceived and UpdateRtt follow:</p>
<pre>
OnAckReceived(ack, pn_space):
  if (largest_acked_packet[pn_space] == infinite):
    largest_acked_packet[pn_space] = ack.largest_acked
  else:
    largest_acked_packet[pn_space] =
        max(largest_acked_packet[pn_space], ack.largest_acked)

  // Nothing to do if there are no newly acked packets.
  newly_acked_packets = DetermineNewlyAckedPackets(ack, pn_space)
  if (newly_acked_packets.empty()):
    return

  // If the largest acknowledged is newly acked and
  // at least one ack-eliciting was newly acked, update the RTT.
  if (sent_packets[pn_space].contains(ack.largest_acked) &amp;&amp;
      IncludesAckEliciting(newly_acked_packets)):
    latest_rtt =
      now - sent_packets[pn_space][ack.largest_acked].time_sent
    ack_delay = 0
    if (pn_space == ApplicationData):
      ack_delay = ack.ack_delay
    UpdateRtt(ack_delay)

  // Process ECN information if present.
  if (ACK frame contains ECN information):
      ProcessECN(ack, pn_space)

  for acked_packet in newly_acked_packets:
    OnPacketAcked(acked_packet.packet_number, pn_space)

  DetectLostPackets(pn_space)

  pto_count = 0

  SetLossDetectionTimer()


UpdateRtt(ack_delay):
  // First RTT sample.
  if (smoothed_rtt == 0):
    min_rtt = latest_rtt
    smoothed_rtt = latest_rtt
    rttvar = latest_rtt / 2
    return

  // min_rtt ignores ack delay.
  min_rtt = min(min_rtt, latest_rtt)
  // Limit ack_delay by max_ack_delay
  ack_delay = min(ack_delay, max_ack_delay)
  // Adjust for ack delay if plausible.
  adjusted_rtt = latest_rtt
  if (latest_rtt &gt; min_rtt + ack_delay):
    adjusted_rtt = latest_rtt - ack_delay

  rttvar = 3/4 * rttvar + 1/4 * abs(smoothed_rtt - adjusted_rtt)
  smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
</pre>
<h2 id="rfc.appendix.A.7">
<a href="#rfc.appendix.A.7">A.7.</a> <a href="#on-packet-acknowledgment" id="on-packet-acknowledgment">On Packet Acknowledgment</a>
</h2>
<p id="rfc.section.A.7.p.1">When a packet is acknowledged for the first time, the following OnPacketAcked function is called.  Note that a single ACK frame may newly acknowledge several packets. OnPacketAcked must be called once for each of these newly acknowledged packets.</p>
<p id="rfc.section.A.7.p.2">OnPacketAcked takes two parameters: acked_packet, which is the struct detailed in <a href="#sent-packets-fields" class="xref">Appendix A.1.1</a>, and the packet number space that this ACK frame was sent for.</p>
<p id="rfc.section.A.7.p.3">Pseudocode for OnPacketAcked follows:</p>
<pre>
   OnPacketAcked(acked_packet, pn_space):
     if (acked_packet.in_flight):
       OnPacketAckedCC(acked_packet)
     sent_packets[pn_space].remove(acked_packet.packet_number)
</pre>
<h2 id="rfc.appendix.A.8">
<a href="#rfc.appendix.A.8">A.8.</a> <a href="#setting-the-loss-detection-timer" id="setting-the-loss-detection-timer">Setting the Loss Detection Timer</a>
</h2>
<p id="rfc.section.A.8.p.1">QUIC loss detection uses a single timer for all timeout loss detection.  The duration of the timer is based on the timer&#8217;s mode, which is set in the packet and timer events further below.  The function SetLossDetectionTimer defined below shows how the single timer is set.</p>
<p id="rfc.section.A.8.p.2">This algorithm may result in the timer being set in the past, particularly if timers wake up late. Timers set in the past SHOULD fire immediately.</p>
<p id="rfc.section.A.8.p.3">Pseudocode for SetLossDetectionTimer follows:</p>
<pre>
// Returns the earliest loss_time and the packet number
// space it's from.  Returns 0 if all times are 0.
GetEarliestLossTime():
  time = loss_time[Initial]
  space = Initial
  for pn_space in [ Handshake, ApplicationData ]:
    if (loss_time[pn_space] != 0 &amp;&amp;
        (time == 0 || loss_time[pn_space] &lt; time)):
      time = loss_time[pn_space];
      space = pn_space
  return time, space

PeerNotAwaitingAddressValidation():
  # Assume clients validate the server's address implicitly.
  if (endpoint is server):
    return true
  # Servers complete address validation when a
  # protected packet is received.
  return has received Handshake ACK ||
         has received 1-RTT ACK

SetLossDetectionTimer():
  loss_time, _ = GetEarliestLossTime()
  if (loss_time != 0):
    // Time threshold loss detection.
    loss_detection_timer.update(loss_time)
    return

  if (no ack-eliciting packets in flight &amp;&amp;
      PeerNotAwaitingAddressValidation()):
    loss_detection_timer.cancel()
    return

  // Use a default timeout if there are no RTT measurements
  if (smoothed_rtt == 0):
    timeout = 2 * kInitialRtt
  else:
    // Calculate PTO duration
    timeout = smoothed_rtt + max(4 * rttvar, kGranularity) +
      max_ack_delay
  timeout = timeout * (2 ^ pto_count)

  loss_detection_timer.update(
    time_of_last_sent_ack_eliciting_packet + timeout)
</pre>
<h2 id="rfc.appendix.A.9">
<a href="#rfc.appendix.A.9">A.9.</a> <a href="#on-timeout" id="on-timeout">On Timeout</a>
</h2>
<p id="rfc.section.A.9.p.1">When the loss detection timer expires, the timer&#8217;s mode determines the action to be performed.</p>
<p id="rfc.section.A.9.p.2">Pseudocode for OnLossDetectionTimeout follows:</p>
<pre>
OnLossDetectionTimeout():
  loss_time, pn_space = GetEarliestLossTime()
  if (loss_time != 0):
    // Time threshold loss Detection
    DetectLostPackets(pn_space)
    SetLossDetectionTimer()
    return

  if (endpoint is client without 1-RTT keys):
    // Client sends an anti-deadlock packet: Initial is padded
    // to earn more anti-amplification credit,
    // a Handshake packet proves address ownership.
    if (has Handshake keys):
      SendOneAckElicitingHandshakePacket()
    else:
      SendOneAckElicitingPaddedInitialPacket()
  else:
    // PTO. Send new data if available, else retransmit old data.
    // If neither is available, send a single PING frame.
    SendOneOrTwoAckElicitingPackets()

  pto_count++
  SetLossDetectionTimer()
</pre>
<h2 id="rfc.appendix.A.10">
<a href="#rfc.appendix.A.10">A.10.</a> <a href="#detecting-lost-packets" id="detecting-lost-packets">Detecting Lost Packets</a>
</h2>
<p id="rfc.section.A.10.p.1">DetectLostPackets is called every time an ACK is received and operates on the sent_packets for that packet number space.</p>
<p id="rfc.section.A.10.p.2">Pseudocode for DetectLostPackets follows:</p>
<pre>
DetectLostPackets(pn_space):
  assert(largest_acked_packet[pn_space] != infinite)
  loss_time[pn_space] = 0
  lost_packets = {}
  loss_delay = kTimeThreshold * max(latest_rtt, smoothed_rtt)

  // Minimum time of kGranularity before packets are deemed lost.
  loss_delay = max(loss_delay, kGranularity)

  // Packets sent before this time are deemed lost.
  lost_send_time = now() - loss_delay

  foreach unacked in sent_packets[pn_space]:
    if (unacked.packet_number &gt; largest_acked_packet[pn_space]):
      continue

    // Mark packet as lost, or set time when it should be marked.
    if (unacked.time_sent &lt;= lost_send_time ||
        largest_acked_packet[pn_space] &gt;=
          unacked.packet_number + kPacketThreshold):
      sent_packets[pn_space].remove(unacked.packet_number)
      if (unacked.in_flight):
        lost_packets.insert(unacked)
    else:
      if (loss_time[pn_space] == 0):
        loss_time[pn_space] = unacked.time_sent + loss_delay
      else:
        loss_time[pn_space] = min(loss_time[pn_space],
                                  unacked.time_sent + loss_delay)

  // Inform the congestion controller of lost packets and
  // let it decide whether to retransmit immediately.
  if (!lost_packets.empty()):
    OnPacketsLost(lost_packets)
</pre>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#congestion-control-pseudocode" id="congestion-control-pseudocode">Congestion Control Pseudocode</a>
</h1>
<p id="rfc.section.B.p.1">We now describe an example implementation of the congestion controller described in <a href="#congestion-control" class="xref">Section 6</a>.</p>
<h2 id="rfc.appendix.B.1">
<a href="#rfc.appendix.B.1">B.1.</a> <a href="#cc-consts-of-interest" id="cc-consts-of-interest">Constants of interest</a>
</h2>
<p id="rfc.section.B.1.p.1">Constants used in congestion control are based on a combination of RFCs, papers, and common practice.  Some may need to be changed or negotiated in order to better suit a variety of environments.</p>
<p></p>

<dl>
<dt>kMaxDatagramSize:</dt>
<dd style="margin-left: 8">The sender&#8217;s maximum payload size. Does not include UDP or IP overhead.  The max packet size is used for calculating initial and minimum congestion windows. The RECOMMENDED value is 1200 bytes.</dd>
<dt>kInitialWindow:</dt>
<dd style="margin-left: 8">Default limit on the initial amount of data in flight, in bytes.  Taken from <a href="#RFC6928" class="xref">[RFC6928]</a>, but increased slightly to account for the smaller 8 byte overhead of UDP vs 20 bytes for TCP.  The RECOMMENDED value is the minimum of 10 * kMaxDatagramSize and max(2* kMaxDatagramSize, 14720)).</dd>
<dt>kMinimumWindow:</dt>
<dd style="margin-left: 8">Minimum congestion window in bytes. The RECOMMENDED value is 2 * kMaxDatagramSize.</dd>
<dt>kLossReductionFactor:</dt>
<dd style="margin-left: 8">Reduction in congestion window when a new loss event is detected.  The RECOMMENDED value is 0.5.</dd>
<dt>kPersistentCongestionThreshold:</dt>
<dd style="margin-left: 8">Period of time for persistent congestion to be established, specified as a PTO multiplier.  The rationale for this threshold is to enable a sender to use initial PTOs for aggressive probing, as TCP does with Tail Loss Probe (TLP) <a href="#TLP" class="xref">[TLP]</a> <a href="#RACK" class="xref">[RACK]</a>, before establishing persistent congestion, as TCP does with a Retransmission Timeout (RTO) <a href="#RFC5681" class="xref">[RFC5681]</a>.  The RECOMMENDED value for kPersistentCongestionThreshold is 3, which is approximately equivalent to having two TLPs before an RTO in TCP.</dd>
</dl>
<h2 id="rfc.appendix.B.2">
<a href="#rfc.appendix.B.2">B.2.</a> <a href="#vars-of-interest" id="vars-of-interest">Variables of interest</a>
</h2>
<p id="rfc.section.B.2.p.1">Variables required to implement the congestion control mechanisms are described in this section.</p>
<p></p>

<dl>
<dt>ecn_ce_counters[kPacketNumberSpace]:</dt>
<dd style="margin-left: 8">The highest value reported for the ECN-CE counter in the packet number space by the peer in an ACK frame. This value is used to detect increases in the reported ECN-CE counter.</dd>
<dt>bytes_in_flight:</dt>
<dd style="margin-left: 8">The sum of the size in bytes of all sent packets that contain at least one ack-eliciting or PADDING frame, and have not been acked or declared lost. The size does not include IP or UDP overhead, but does include the QUIC header and AEAD overhead.  Packets only containing ACK frames do not count towards bytes_in_flight to ensure congestion control does not impede congestion feedback.</dd>
<dt>congestion_window:</dt>
<dd style="margin-left: 8">Maximum number of bytes-in-flight that may be sent.</dd>
<dt>congestion_recovery_start_time:</dt>
<dd style="margin-left: 8">The time when QUIC first detects congestion due to loss or ECN, causing it to enter congestion recovery. When a packet sent after this time is acknowledged, QUIC exits congestion recovery.</dd>
<dt>ssthresh:</dt>
<dd style="margin-left: 8">Slow start threshold in bytes.  When the congestion window is below ssthresh, the mode is slow start and the window grows by the number of bytes acknowledged.</dd>
</dl>
<h2 id="rfc.appendix.B.3">
<a href="#rfc.appendix.B.3">B.3.</a> <a href="#initialization-1" id="initialization-1">Initialization</a>
</h2>
<p id="rfc.section.B.3.p.1">At the beginning of the connection, initialize the congestion control variables as follows:</p>
<pre>
   congestion_window = kInitialWindow
   bytes_in_flight = 0
   congestion_recovery_start_time = 0
   ssthresh = infinite
   for pn_space in [ Initial, Handshake, ApplicationData ]:
     ecn_ce_counters[pn_space] = 0
</pre>
<h2 id="rfc.appendix.B.4">
<a href="#rfc.appendix.B.4">B.4.</a> <a href="#on-packet-sent" id="on-packet-sent">On Packet Sent</a>
</h2>
<p id="rfc.section.B.4.p.1">Whenever a packet is sent, and it contains non-ACK frames, the packet increases bytes_in_flight.</p>
<pre>
   OnPacketSentCC(bytes_sent):
     bytes_in_flight += bytes_sent
</pre>
<h2 id="rfc.appendix.B.5">
<a href="#rfc.appendix.B.5">B.5.</a> <a href="#on-packet-acknowledgement" id="on-packet-acknowledgement">On Packet Acknowledgement</a>
</h2>
<p id="rfc.section.B.5.p.1">Invoked from loss detection&#8217;s OnPacketAcked and is supplied with the acked_packet from sent_packets.</p>
<pre>
   InCongestionRecovery(sent_time):
     return sent_time &lt;= congestion_recovery_start_time

   OnPacketAckedCC(acked_packet):
     // Remove from bytes_in_flight.
     bytes_in_flight -= acked_packet.size
     if (InCongestionRecovery(acked_packet.time_sent)):
       // Do not increase congestion window in recovery period.
       return
     if (IsAppLimited()):
       // Do not increase congestion_window if application
       // limited.
       return
     if (congestion_window &lt; ssthresh):
       // Slow start.
       congestion_window += acked_packet.size
     else:
       // Congestion avoidance.
       congestion_window += kMaxDatagramSize * acked_packet.size
           / congestion_window
</pre>
<h2 id="rfc.appendix.B.6">
<a href="#rfc.appendix.B.6">B.6.</a> <a href="#on-new-congestion-event" id="on-new-congestion-event">On New Congestion Event</a>
</h2>
<p id="rfc.section.B.6.p.1">Invoked from ProcessECN and OnPacketsLost when a new congestion event is detected. May start a new recovery period and reduces the congestion window.</p>
<pre>
   CongestionEvent(sent_time):
     // Start a new congestion event if packet was sent after the
     // start of the previous congestion recovery period.
     if (!InCongestionRecovery(sent_time)):
       congestion_recovery_start_time = Now()
       congestion_window *= kLossReductionFactor
       congestion_window = max(congestion_window, kMinimumWindow)
       ssthresh = congestion_window
</pre>
<h2 id="rfc.appendix.B.7">
<a href="#rfc.appendix.B.7">B.7.</a> <a href="#process-ecn-information" id="process-ecn-information">Process ECN Information</a>
</h2>
<p id="rfc.section.B.7.p.1">Invoked when an ACK frame with an ECN section is received from the peer.</p>
<pre>
   ProcessECN(ack, pn_space):
     // If the ECN-CE counter reported by the peer has increased,
     // this could be a new congestion event.
     if (ack.ce_counter &gt; ecn_ce_counters[pn_space]):
       ecn_ce_counters[pn_space] = ack.ce_counter
       CongestionEvent(sent_packets[ack.largest_acked].time_sent)
</pre>
<h2 id="rfc.appendix.B.8">
<a href="#rfc.appendix.B.8">B.8.</a> <a href="#on-packets-lost" id="on-packets-lost">On Packets Lost</a>
</h2>
<p id="rfc.section.B.8.p.1">Invoked from DetectLostPackets when packets are deemed lost.</p>
<pre>
   InPersistentCongestion(largest_lost_packet):
     pto = smoothed_rtt + max(4 * rttvar, kGranularity) +
       max_ack_delay
     congestion_period = pto * kPersistentCongestionThreshold
     // Determine if all packets in the time period before the
     // newest lost packet, including the edges, are marked
     // lost
     return AreAllPacketsLost(largest_lost_packet,
                              congestion_period)

   OnPacketsLost(lost_packets):
     // Remove lost packets from bytes_in_flight.
     for (lost_packet : lost_packets):
       bytes_in_flight -= lost_packet.size
     largest_lost_packet = lost_packets.last()
     CongestionEvent(largest_lost_packet.time_sent)

     // Collapse congestion window if persistent congestion
     if (InPersistentCongestion(largest_lost_packet)):
       congestion_window = kMinimumWindow
</pre>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#change-log" id="change-log">Change Log</a>
</h1>
<p></p>

<ul class="empty"><li>
<strong>RFC Editor&#8217;s Note:</strong>  Please remove this section prior to publication of a final version of this document.</li></ul>
<p id="rfc.section.C.p.2">Issue and pull request numbers are listed with a leading octothorp.</p>
<h2 id="rfc.appendix.C.1">
<a href="#rfc.appendix.C.1">C.1.</a> <a href="#since-draft-ietf-quic-recovery-22" id="since-draft-ietf-quic-recovery-22">Since draft-ietf-quic-recovery-22</a>
</h2>
<p></p>

<ul>
<li>PTO should always send an ack-eliciting packet (#2895)</li>
<li>Unify the Handshake Timer with the PTO timer (#2648, #2658, #2886)</li>
<li>Move ACK generation text to transport draft (#1860, #2916)</li>
</ul>
<h2 id="rfc.appendix.C.2">
<a href="#rfc.appendix.C.2">C.2.</a> <a href="#since-draft-ietf-quic-recovery-21" id="since-draft-ietf-quic-recovery-21">Since draft-ietf-quic-recovery-21</a>
</h2>
<p></p>

<ul><li>No changes</li></ul>
<h2 id="rfc.appendix.C.3">
<a href="#rfc.appendix.C.3">C.3.</a> <a href="#since-draft-ietf-quic-recovery-20" id="since-draft-ietf-quic-recovery-20">Since draft-ietf-quic-recovery-20</a>
</h2>
<p></p>

<ul>
<li>Path validation can be used as initial RTT value (#2644, #2687)</li>
<li>max_ack_delay transport parameter defaults to 0 (#2638, #2646)</li>
<li>Ack Delay only measures intentional delays induced by the implementation (#2596, #2786)</li>
</ul>
<h2 id="rfc.appendix.C.4">
<a href="#rfc.appendix.C.4">C.4.</a> <a href="#since-draft-ietf-quic-recovery-19" id="since-draft-ietf-quic-recovery-19">Since draft-ietf-quic-recovery-19</a>
</h2>
<p></p>

<ul>
<li>Change kPersistentThreshold from an exponent to a multiplier (#2557)</li>
<li>Send a PING if the PTO timer fires and there&#8217;s nothing to send (#2624)</li>
<li>Set loss delay to at least kGranularity (#2617)</li>
<li>Merge application limited and sending after idle sections. Always limit burst size instead of requiring resetting CWND to initial CWND after idle (#2605)</li>
<li>Rewrite RTT estimation, allow RTT samples where a newly acked packet is ack-eliciting but the largest_acked is not (#2592)</li>
<li>Don&#8217;t arm the handshake timer if there is no handshake data (#2590)</li>
<li>Clarify that the time threshold loss alarm takes precedence over the crypto handshake timer (#2590, #2620)</li>
<li>Change initial RTT to 500ms to align with RFC6298 (#2184)</li>
</ul>
<h2 id="rfc.appendix.C.5">
<a href="#rfc.appendix.C.5">C.5.</a> <a href="#since-draft-ietf-quic-recovery-18" id="since-draft-ietf-quic-recovery-18">Since draft-ietf-quic-recovery-18</a>
</h2>
<p></p>

<ul>
<li>Change IW byte limit to 14720 from 14600 (#2494)</li>
<li>Update PTO calculation to match RFC6298 (#2480, #2489, #2490)</li>
<li>Improve loss detection&#8217;s description of multiple packet number spaces and pseudocode (#2485, #2451, #2417)</li>
<li>Declare persistent congestion even if non-probe packets are sent and don&#8217;t make persistent congestion more aggressive than RTO verified was (#2365, #2244)</li>
<li>Move pseudocode to the appendices (#2408)</li>
<li>What to send on multiple PTOs (#2380)</li>
</ul>
<h2 id="rfc.appendix.C.6">
<a href="#rfc.appendix.C.6">C.6.</a> <a href="#since-draft-ietf-quic-recovery-17" id="since-draft-ietf-quic-recovery-17">Since draft-ietf-quic-recovery-17</a>
</h2>
<p></p>

<ul>
<li>After Probe Timeout discard in-flight packets or send another (#2212, #1965)</li>
<li>Endpoints discard initial keys as soon as handshake keys are available (#1951, #2045)</li>
<li>0-RTT state is discarded when 0-RTT is rejected (#2300)</li>
<li>Loss detection timer is cancelled when ack-eliciting frames are in flight (#2117, #2093)</li>
<li>Packets are declared lost if they are in flight (#2104)</li>
<li>After becoming idle, either pace packets or reset the congestion controller (#2138, 2187)</li>
<li>Process ECN counts before marking packets lost (#2142)</li>
<li>Mark packets lost before resetting crypto_count and pto_count (#2208, #2209)</li>
<li>Congestion and loss recovery state are discarded when keys are discarded (#2327)</li>
</ul>
<h2 id="rfc.appendix.C.7">
<a href="#rfc.appendix.C.7">C.7.</a> <a href="#since-draft-ietf-quic-recovery-16" id="since-draft-ietf-quic-recovery-16">Since draft-ietf-quic-recovery-16</a>
</h2>
<p></p>

<ul>
<li>Unify TLP and RTO into a single PTO; eliminate min RTO, min TLP and min crypto timeouts; eliminate timeout validation (#2114, #2166, #2168, #1017)</li>
<li>Redefine how congestion avoidance in terms of when the period starts (#1928, #1930)</li>
<li>Document what needs to be tracked for packets that are in flight (#765, #1724, #1939)</li>
<li>Integrate both time and packet thresholds into loss detection (#1969, #1212, #934, #1974)</li>
<li>Reduce congestion window after idle, unless pacing is used (#2007, #2023)</li>
<li>Disable RTT calculation for packets that don&#8217;t elicit acknowledgment (#2060, #2078)</li>
<li>Limit ack_delay by max_ack_delay (#2060, #2099)</li>
<li>Initial keys are discarded once Handshake are avaialble (#1951, #2045)</li>
<li>Reorder ECN and loss detection in pseudocode (#2142)</li>
<li>Only cancel loss detection timer if ack-eliciting packets are in flight (#2093, #2117)</li>
</ul>
<h2 id="rfc.appendix.C.8">
<a href="#rfc.appendix.C.8">C.8.</a> <a href="#since-draft-ietf-quic-recovery-14" id="since-draft-ietf-quic-recovery-14">Since draft-ietf-quic-recovery-14</a>
</h2>
<p></p>

<ul>
<li>Used max_ack_delay from transport params (#1796, #1782)</li>
<li>Merge ACK and ACK_ECN (#1783)</li>
</ul>
<h2 id="rfc.appendix.C.9">
<a href="#rfc.appendix.C.9">C.9.</a> <a href="#since-draft-ietf-quic-recovery-13" id="since-draft-ietf-quic-recovery-13">Since draft-ietf-quic-recovery-13</a>
</h2>
<p></p>

<ul>
<li>Corrected the lack of ssthresh reduction in CongestionEvent pseudocode (#1598)</li>
<li>Considerations for ECN spoofing (#1426, #1626)</li>
<li>Clarifications for PADDING and congestion control (#837, #838, #1517, #1531, #1540)</li>
<li>Reduce early retransmission timer to RTT/8 (#945, #1581)</li>
<li>Packets are declared lost after an RTO is verified (#935, #1582)</li>
</ul>
<h2 id="rfc.appendix.C.10">
<a href="#rfc.appendix.C.10">C.10.</a> <a href="#since-draft-ietf-quic-recovery-12" id="since-draft-ietf-quic-recovery-12">Since draft-ietf-quic-recovery-12</a>
</h2>
<p></p>

<ul>
<li>Changes to manage separate packet number spaces and encryption levels (#1190, #1242, #1413, #1450)</li>
<li>Added ECN feedback mechanisms and handling; new ACK_ECN frame (#804, #805, #1372)</li>
</ul>
<h2 id="rfc.appendix.C.11">
<a href="#rfc.appendix.C.11">C.11.</a> <a href="#since-draft-ietf-quic-recovery-11" id="since-draft-ietf-quic-recovery-11">Since draft-ietf-quic-recovery-11</a>
</h2>
<p id="rfc.section.C.11.p.1">No significant changes.</p>
<h2 id="rfc.appendix.C.12">
<a href="#rfc.appendix.C.12">C.12.</a> <a href="#since-draft-ietf-quic-recovery-10" id="since-draft-ietf-quic-recovery-10">Since draft-ietf-quic-recovery-10</a>
</h2>
<p></p>

<ul>
<li>Improved text on ack generation (#1139, #1159)</li>
<li>Make references to TCP recovery mechanisms informational (#1195)</li>
<li>Define time_of_last_sent_handshake_packet (#1171)</li>
<li>Added signal from TLS the data it includes needs to be sent in a Retry packet (#1061, #1199)</li>
<li>Minimum RTT (min_rtt) is initialized with an infinite value (#1169)</li>
</ul>
<h2 id="rfc.appendix.C.13">
<a href="#rfc.appendix.C.13">C.13.</a> <a href="#since-draft-ietf-quic-recovery-09" id="since-draft-ietf-quic-recovery-09">Since draft-ietf-quic-recovery-09</a>
</h2>
<p id="rfc.section.C.13.p.1">No significant changes.</p>
<h2 id="rfc.appendix.C.14">
<a href="#rfc.appendix.C.14">C.14.</a> <a href="#since-draft-ietf-quic-recovery-08" id="since-draft-ietf-quic-recovery-08">Since draft-ietf-quic-recovery-08</a>
</h2>
<p></p>

<ul><li>Clarified pacing and RTO (#967, #977)</li></ul>
<h2 id="rfc.appendix.C.15">
<a href="#rfc.appendix.C.15">C.15.</a> <a href="#since-draft-ietf-quic-recovery-07" id="since-draft-ietf-quic-recovery-07">Since draft-ietf-quic-recovery-07</a>
</h2>
<p></p>

<ul>
<li>Include Ack Delay in RTO(and TLP) computations (#981)</li>
<li>Ack Delay in SRTT computation (#961)</li>
<li>Default RTT and Slow Start (#590)</li>
<li>Many editorial fixes.</li>
</ul>
<h2 id="rfc.appendix.C.16">
<a href="#rfc.appendix.C.16">C.16.</a> <a href="#since-draft-ietf-quic-recovery-06" id="since-draft-ietf-quic-recovery-06">Since draft-ietf-quic-recovery-06</a>
</h2>
<p id="rfc.section.C.16.p.1">No significant changes.</p>
<h2 id="rfc.appendix.C.17">
<a href="#rfc.appendix.C.17">C.17.</a> <a href="#since-draft-ietf-quic-recovery-05" id="since-draft-ietf-quic-recovery-05">Since draft-ietf-quic-recovery-05</a>
</h2>
<p></p>

<ul><li>Add more congestion control text (#776)</li></ul>
<h2 id="rfc.appendix.C.18">
<a href="#rfc.appendix.C.18">C.18.</a> <a href="#since-draft-ietf-quic-recovery-04" id="since-draft-ietf-quic-recovery-04">Since draft-ietf-quic-recovery-04</a>
</h2>
<p id="rfc.section.C.18.p.1">No significant changes.</p>
<h2 id="rfc.appendix.C.19">
<a href="#rfc.appendix.C.19">C.19.</a> <a href="#since-draft-ietf-quic-recovery-03" id="since-draft-ietf-quic-recovery-03">Since draft-ietf-quic-recovery-03</a>
</h2>
<p id="rfc.section.C.19.p.1">No significant changes.</p>
<h2 id="rfc.appendix.C.20">
<a href="#rfc.appendix.C.20">C.20.</a> <a href="#since-draft-ietf-quic-recovery-02" id="since-draft-ietf-quic-recovery-02">Since draft-ietf-quic-recovery-02</a>
</h2>
<p></p>

<ul>
<li>Integrate F-RTO (#544, #409)</li>
<li>Add congestion control (#545, #395)</li>
<li>Require connection abort if a skipped packet was acknowledged (#415)</li>
<li>Simplify RTO calculations (#142, #417)</li>
</ul>
<h2 id="rfc.appendix.C.21">
<a href="#rfc.appendix.C.21">C.21.</a> <a href="#since-draft-ietf-quic-recovery-01" id="since-draft-ietf-quic-recovery-01">Since draft-ietf-quic-recovery-01</a>
</h2>
<p></p>

<ul>
<li>Overview added to loss detection</li>
<li>Changes initial default RTT to 100ms</li>
<li>Added time-based loss detection and fixes early retransmit</li>
<li>Clarified loss recovery for handshake packets</li>
<li>Fixed references and made TCP references informative</li>
</ul>
<h2 id="rfc.appendix.C.22">
<a href="#rfc.appendix.C.22">C.22.</a> <a href="#since-draft-ietf-quic-recovery-00" id="since-draft-ietf-quic-recovery-00">Since draft-ietf-quic-recovery-00</a>
</h2>
<p></p>

<ul><li>Improved description of constants and ACK behavior</li></ul>
<h2 id="rfc.appendix.C.23">
<a href="#rfc.appendix.C.23">C.23.</a> <a href="#since-draft-iyengar-quic-loss-recovery-01" id="since-draft-iyengar-quic-loss-recovery-01">Since draft-iyengar-quic-loss-recovery-01</a>
</h2>
<p></p>

<ul>
<li>Adopted as base for draft-ietf-quic-recovery</li>
<li>Updated authors/editors list</li>
<li>Added table of contents</li>
</ul>
<h1 id="rfc.acknowledgments"><a href="#rfc.acknowledgments">Acknowledgments</a></h1>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jana Iyengar</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Iyengar</span>
	  </span>
	</span>
	<span class="org vcardline">Fastly</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jri.ietf@gmail.com">jri.ietf@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ian Swett</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Swett</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ianswett@google.com">ianswett@google.com</a></span>

  </address>
</div>

</body>
</html>

