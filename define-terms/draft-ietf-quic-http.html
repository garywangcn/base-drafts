<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Hypertext Transfer Protocol Version 3 (HTTP/3)</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Prior versions of HTTP">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Delegation to QUIC">
<link href="#rfc.section.2" rel="Chapter" title="2 HTTP/3 Protocol Overview">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Document Organization">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Conventions and Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Connection Setup and Management">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Draft Version Identification">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Discovering an HTTP/3 Endpoint">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 QUIC Version Hints">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Connection Establishment">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Connection Reuse">
<link href="#rfc.section.4" rel="Chapter" title="4 HTTP Request Lifecycle">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 HTTP Message Exchanges">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Header Formatting and Compression">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Request Cancellation and Rejection">
<link href="#rfc.section.4.1.3" rel="Chapter" title="4.1.3 Malformed Requests and Responses">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 The CONNECT Method">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Prioritization">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Placeholders">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Priority Tree Maintenance">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Server Push">
<link href="#rfc.section.5" rel="Chapter" title="5 Connection Closure">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Idle Connections">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Connection Shutdown">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Immediate Application Closure">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Transport Closure">
<link href="#rfc.section.6" rel="Chapter" title="6 Stream Mapping and Usage">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Bidirectional Streams">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Unidirectional Streams">
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 Control Streams">
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 Push Streams">
<link href="#rfc.section.6.2.3" rel="Chapter" title="6.2.3 Reserved Stream Types">
<link href="#rfc.section.7" rel="Chapter" title="7 HTTP Framing Layer">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Frame Layout">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Frame Definitions">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 DATA">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 HEADERS">
<link href="#rfc.section.7.2.3" rel="Chapter" title="7.2.3 PRIORITY">
<link href="#rfc.section.7.2.4" rel="Chapter" title="7.2.4 CANCEL_PUSH">
<link href="#rfc.section.7.2.5" rel="Chapter" title="7.2.5 SETTINGS">
<link href="#rfc.section.7.2.6" rel="Chapter" title="7.2.6 PUSH_PROMISE">
<link href="#rfc.section.7.2.7" rel="Chapter" title="7.2.7 GOAWAY">
<link href="#rfc.section.7.2.8" rel="Chapter" title="7.2.8 MAX_PUSH_ID">
<link href="#rfc.section.7.2.9" rel="Chapter" title="7.2.9 DUPLICATE_PUSH">
<link href="#rfc.section.7.2.10" rel="Chapter" title="7.2.10 Reserved Frame Types">
<link href="#rfc.section.8" rel="Chapter" title="8 Error Handling">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 HTTP/3 Error Codes">
<link href="#rfc.section.9" rel="Chapter" title="9 Extensions to HTTP/3">
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 Registration of HTTP/3 Identification String">
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 Registration of QUIC Version Hint Alt-Svc Parameter">
<link href="#rfc.section.11.3" rel="Chapter" title="11.3 Frame Types">
<link href="#rfc.section.11.4" rel="Chapter" title="11.4 Settings Parameters">
<link href="#rfc.section.11.5" rel="Chapter" title="11.5 Error Codes">
<link href="#rfc.section.11.6" rel="Chapter" title="11.6 Stream Types">
<link href="#rfc.references" rel="Chapter" title="12 References">
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Considerations for Transitioning from HTTP/2">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Streams">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 HTTP Frame Types">
<link href="#rfc.appendix.A.2.1" rel="Chapter" title="A.2.1 Prioritization Differences">
<link href="#rfc.appendix.A.2.2" rel="Chapter" title="A.2.2 Header Compression Differences">
<link href="#rfc.appendix.A.2.3" rel="Chapter" title="A.2.3 Guidance for New Frame Type Definitions">
<link href="#rfc.appendix.A.2.4" rel="Chapter" title="A.2.4 Mapping Between HTTP/2 and HTTP/3 Frame Types">
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 HTTP/2 SETTINGS Parameters">
<link href="#rfc.appendix.A.4" rel="Chapter" title="A.4 HTTP/2 Error Codes">
<link href="#rfc.appendix.B" rel="Chapter" title="B Change Log">
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Since draft-ietf-quic-http-19">
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Since draft-ietf-quic-http-18">
<link href="#rfc.appendix.B.3" rel="Chapter" title="B.3 Since draft-ietf-quic-http-17">
<link href="#rfc.appendix.B.4" rel="Chapter" title="B.4 Since draft-ietf-quic-http-16">
<link href="#rfc.appendix.B.5" rel="Chapter" title="B.5 Since draft-ietf-quic-http-15">
<link href="#rfc.appendix.B.6" rel="Chapter" title="B.6 Since draft-ietf-quic-http-14">
<link href="#rfc.appendix.B.7" rel="Chapter" title="B.7 Since draft-ietf-quic-http-13">
<link href="#rfc.appendix.B.8" rel="Chapter" title="B.8 Since draft-ietf-quic-http-12">
<link href="#rfc.appendix.B.9" rel="Chapter" title="B.9 Since draft-ietf-quic-http-11">
<link href="#rfc.appendix.B.10" rel="Chapter" title="B.10 Since draft-ietf-quic-http-10">
<link href="#rfc.appendix.B.11" rel="Chapter" title="B.11 Since draft-ietf-quic-http-09">
<link href="#rfc.appendix.B.12" rel="Chapter" title="B.12 Since draft-ietf-quic-http-08">
<link href="#rfc.appendix.B.13" rel="Chapter" title="B.13 Since draft-ietf-quic-http-07">
<link href="#rfc.appendix.B.14" rel="Chapter" title="B.14 Since draft-ietf-quic-http-06">
<link href="#rfc.appendix.B.15" rel="Chapter" title="B.15 Since draft-ietf-quic-http-05">
<link href="#rfc.appendix.B.16" rel="Chapter" title="B.16 Since draft-ietf-quic-http-04">
<link href="#rfc.appendix.B.17" rel="Chapter" title="B.17 Since draft-ietf-quic-http-03">
<link href="#rfc.appendix.B.18" rel="Chapter" title="B.18 Since draft-ietf-quic-http-02">
<link href="#rfc.appendix.B.19" rel="Chapter" title="B.19 Since draft-ietf-quic-http-01">
<link href="#rfc.appendix.B.20" rel="Chapter" title="B.20 Since draft-ietf-quic-http-00">
<link href="#rfc.appendix.B.21" rel="Chapter" title="B.21 Since draft-shade-quic-http2-mapping-00">
<link href="#rfc.acknowledgements" rel="Chapter">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Bishop, M., Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-http-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-08-06" />
  <meta name="dct.abstract" content="The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment.  This document describes a mapping of HTTP semantics over QUIC.  This document also identifies HTTP/2 features that are subsumed by QUIC, and describes how HTTP/2 extensions can be ported to HTTP/3." />
  <meta name="description" content="The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment.  This document describes a mapping of HTTP semantics over QUIC.  This document also identifies HTTP/2 features that are subsumed by QUIC, and describes how HTTP/2 extensions can be ported to HTTP/3." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">M. Bishop, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Akamai</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">August 06, 2019</td>
</tr>
<tr>
<td class="left">Expires: February 7, 2020</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Hypertext Transfer Protocol Version 3 (HTTP/3)<br />
  <span class="filename">draft-ietf-quic-http-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment.  This document describes a mapping of HTTP semantics over QUIC.  This document also identifies HTTP/2 features that are subsumed by QUIC, and describes how HTTP/2 extensions can be ported to HTTP/3.</p>
<h1><a>Note to Readers</a></h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/-http">https://github.com/quicwg/base-drafts/labels/-http</a>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on February 7, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Prior versions of HTTP</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Delegation to QUIC</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">HTTP/3 Protocol Overview</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Document Organization</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Conventions and Terminology</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Connection Setup and Management</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Draft Version Identification</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Discovering an HTTP/3 Endpoint</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">QUIC Version Hints</a>
</li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Connection Establishment</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Connection Reuse</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">HTTP Request Lifecycle</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">HTTP Message Exchanges</a>
</li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">Header Formatting and Compression</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Request Cancellation and Rejection</a>
</li>
<li>4.1.3.   <a href="#rfc.section.4.1.3">Malformed Requests and Responses</a>
</li>
</ul><li>4.2.   <a href="#rfc.section.4.2">The CONNECT Method</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Prioritization</a>
</li>
<ul><li>4.3.1.   <a href="#rfc.section.4.3.1">Placeholders</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Priority Tree Maintenance</a>
</li>
</ul><li>4.4.   <a href="#rfc.section.4.4">Server Push</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Connection Closure</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Idle Connections</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Connection Shutdown</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Immediate Application Closure</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Transport Closure</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Stream Mapping and Usage</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Bidirectional Streams</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Unidirectional Streams</a>
</li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">Control Streams</a>
</li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">Push Streams</a>
</li>
<li>6.2.3.   <a href="#rfc.section.6.2.3">Reserved Stream Types</a>
</li>
</ul></ul><li>7.   <a href="#rfc.section.7">HTTP Framing Layer</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Frame Layout</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Frame Definitions</a>
</li>
<ul><li>7.2.1.   <a href="#rfc.section.7.2.1">DATA</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">HEADERS</a>
</li>
<li>7.2.3.   <a href="#rfc.section.7.2.3">PRIORITY</a>
</li>
<li>7.2.4.   <a href="#rfc.section.7.2.4">CANCEL_PUSH</a>
</li>
<li>7.2.5.   <a href="#rfc.section.7.2.5">SETTINGS</a>
</li>
<li>7.2.6.   <a href="#rfc.section.7.2.6">PUSH_PROMISE</a>
</li>
<li>7.2.7.   <a href="#rfc.section.7.2.7">GOAWAY</a>
</li>
<li>7.2.8.   <a href="#rfc.section.7.2.8">MAX_PUSH_ID</a>
</li>
<li>7.2.9.   <a href="#rfc.section.7.2.9">DUPLICATE_PUSH</a>
</li>
<li>7.2.10.   <a href="#rfc.section.7.2.10">Reserved Frame Types</a>
</li>
</ul></ul><li>8.   <a href="#rfc.section.8">Error Handling</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">HTTP/3 Error Codes</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Extensions to HTTP/3</a>
</li>
<li>10.   <a href="#rfc.section.10">Security Considerations</a>
</li>
<li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<ul><li>11.1.   <a href="#rfc.section.11.1">Registration of HTTP/3 Identification String</a>
</li>
<li>11.2.   <a href="#rfc.section.11.2">Registration of QUIC Version Hint Alt-Svc Parameter</a>
</li>
<li>11.3.   <a href="#rfc.section.11.3">Frame Types</a>
</li>
<li>11.4.   <a href="#rfc.section.11.4">Settings Parameters</a>
</li>
<li>11.5.   <a href="#rfc.section.11.5">Error Codes</a>
</li>
<li>11.6.   <a href="#rfc.section.11.6">Stream Types</a>
</li>
</ul><li>12.   <a href="#rfc.references">References</a>
</li>
<ul><li>12.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Considerations for Transitioning from HTTP/2</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Streams</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">HTTP Frame Types</a>
</li>
<ul><li>A.2.1.   <a href="#rfc.appendix.A.2.1">Prioritization Differences</a>
</li>
<li>A.2.2.   <a href="#rfc.appendix.A.2.2">Header Compression Differences</a>
</li>
<li>A.2.3.   <a href="#rfc.appendix.A.2.3">Guidance for New Frame Type Definitions</a>
</li>
<li>A.2.4.   <a href="#rfc.appendix.A.2.4">Mapping Between HTTP/2 and HTTP/3 Frame Types</a>
</li>
</ul><li>A.3.   <a href="#rfc.appendix.A.3">HTTP/2 SETTINGS Parameters</a>
</li>
<li>A.4.   <a href="#rfc.appendix.A.4">HTTP/2 Error Codes</a>
</li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">Change Log</a>
</li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Since draft-ietf-quic-http-19</a>
</li>
<li>B.2.   <a href="#rfc.appendix.B.2">Since draft-ietf-quic-http-18</a>
</li>
<li>B.3.   <a href="#rfc.appendix.B.3">Since draft-ietf-quic-http-17</a>
</li>
<li>B.4.   <a href="#rfc.appendix.B.4">Since draft-ietf-quic-http-16</a>
</li>
<li>B.5.   <a href="#rfc.appendix.B.5">Since draft-ietf-quic-http-15</a>
</li>
<li>B.6.   <a href="#rfc.appendix.B.6">Since draft-ietf-quic-http-14</a>
</li>
<li>B.7.   <a href="#rfc.appendix.B.7">Since draft-ietf-quic-http-13</a>
</li>
<li>B.8.   <a href="#rfc.appendix.B.8">Since draft-ietf-quic-http-12</a>
</li>
<li>B.9.   <a href="#rfc.appendix.B.9">Since draft-ietf-quic-http-11</a>
</li>
<li>B.10.   <a href="#rfc.appendix.B.10">Since draft-ietf-quic-http-10</a>
</li>
<li>B.11.   <a href="#rfc.appendix.B.11">Since draft-ietf-quic-http-09</a>
</li>
<li>B.12.   <a href="#rfc.appendix.B.12">Since draft-ietf-quic-http-08</a>
</li>
<li>B.13.   <a href="#rfc.appendix.B.13">Since draft-ietf-quic-http-07</a>
</li>
<li>B.14.   <a href="#rfc.appendix.B.14">Since draft-ietf-quic-http-06</a>
</li>
<li>B.15.   <a href="#rfc.appendix.B.15">Since draft-ietf-quic-http-05</a>
</li>
<li>B.16.   <a href="#rfc.appendix.B.16">Since draft-ietf-quic-http-04</a>
</li>
<li>B.17.   <a href="#rfc.appendix.B.17">Since draft-ietf-quic-http-03</a>
</li>
<li>B.18.   <a href="#rfc.appendix.B.18">Since draft-ietf-quic-http-02</a>
</li>
<li>B.19.   <a href="#rfc.appendix.B.19">Since draft-ietf-quic-http-01</a>
</li>
<li>B.20.   <a href="#rfc.appendix.B.20">Since draft-ietf-quic-http-00</a>
</li>
<li>B.21.   <a href="#rfc.appendix.B.21">Since draft-shade-quic-http2-mapping-00</a>
</li>
</ul><li><a href="#rfc.acknowledgements">Acknowledgements</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">HTTP semantics are used for a broad range of services on the Internet. These semantics have commonly been used with two different TCP mappings, HTTP/1.1 and HTTP/2.  HTTP/3 supports the same semantics over a new transport protocol, QUIC.</p>
<h2 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#prior-versions-of-http" id="prior-versions-of-http">Prior versions of HTTP</a>
</h2>
<p id="rfc.section.1.1.p.1">HTTP/1.1 is a TCP mapping which uses whitespace-delimited text fields to convey HTTP messages.  While these exchanges are human-readable, using whitespace for message formatting leads to parsing difficulties and workarounds to be tolerant of variant behavior. Because each connection can transfer only a single HTTP request or response at a time in each direction, multiple parallel TCP connections are often used, reducing the ability of the congestion controller to accurately manage traffic between endpoints.</p>
<p id="rfc.section.1.1.p.2">HTTP/2 introduced a binary framing and multiplexing layer to improve latency without modifying the transport layer.  However, because the parallel nature of HTTP/2&#8217;s multiplexing is not visible to TCP&#8217;s loss recovery mechanisms, a lost or reordered packet causes all active transactions to experience a stall regardless of whether that transaction was impacted by the lost packet.</p>
<h2 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#delegation-to-quic" id="delegation-to-quic">Delegation to QUIC</a>
</h2>
<p id="rfc.section.1.2.p.1">The QUIC transport protocol incorporates stream multiplexing and per-stream flow control, similar to that provided by the HTTP/2 framing layer. By providing reliability at the stream level and congestion control across the entire connection, it has the capability to improve the performance of HTTP compared to a TCP mapping.  QUIC also incorporates TLS 1.3 at the transport layer, offering comparable security to running TLS over TCP, with the improved connection setup latency of TCP Fast Open <a href="#RFC7413" class="xref">[RFC7413]</a>}.</p>
<p id="rfc.section.1.2.p.2">This document defines a mapping of HTTP semantics over the QUIC transport protocol, drawing heavily on the design of HTTP/2.  While delegating stream lifetime and flow control issues to QUIC, a similar binary framing is used on each stream. Some HTTP/2 features are subsumed by QUIC, while other features are implemented atop QUIC.</p>
<p id="rfc.section.1.2.p.3">QUIC is described in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.  For a full description of HTTP/2, see <a href="#HTTP2" class="xref">[HTTP2]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#http3-protocol-overview" id="http3-protocol-overview">HTTP/3 Protocol Overview</a>
</h1>
<p id="rfc.section.2.p.1">HTTP/3 provides a transport for HTTP semantics using the QUIC transport protocol and an internal framing layer similar to HTTP/2.</p>
<p id="rfc.section.2.p.2">Once a client knows that an HTTP/3 server exists at a certain endpoint, it opens a QUIC connection. QUIC provides protocol negotiation, stream-based multiplexing, and flow control. An HTTP/3 endpoint can be discovered using HTTP Alternative Services; this process is described in greater detail in <a href="#discovery" class="xref">Section 3.2</a>.</p>
<p id="rfc.section.2.p.3">Within each stream, the basic unit of HTTP/3 communication is a frame (<a href="#frames" class="xref">Section 7.2</a>).  Each frame type serves a different purpose.  For example, HEADERS and DATA frames form the basis of HTTP requests and responses (<a href="#request-response" class="xref">Section 4.1</a>).  Other frame types like SETTINGS, PRIORITY, and GOAWAY are used to manage the overall connection and relationships between streams.</p>
<p id="rfc.section.2.p.4">Multiplexing of requests is performed using the QUIC stream abstraction, described in Section 2 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.  Each request and response consumes a single QUIC stream.  Streams are independent of each other, so one stream that is blocked or suffers packet loss does not prevent progress on other streams.</p>
<p id="rfc.section.2.p.5">Server push is an interaction mode introduced in HTTP/2 <a href="#HTTP2" class="xref">[HTTP2]</a> which permits a server to push a request-response exchange to a client in anticipation of the client making the indicated request.  This trades off network usage against a potential latency gain.  Several HTTP/3 frames are used to manage server push, such as PUSH_PROMISE, DUPLICATE_PUSH, MAX_PUSH_ID, and CANCEL_PUSH.</p>
<p id="rfc.section.2.p.6">As in HTTP/2, request and response headers are compressed for transmission.  Because HPACK <a href="#HPACK" class="xref">[HPACK]</a> relies on in-order transmission of compressed header blocks (a guarantee not provided by QUIC), HTTP/3 replaces HPACK with QPACK <a href="#QPACK" class="xref">[QPACK]</a>.  QPACK uses separate unidirectional streams to modify and track header table state, while header blocks refer to the state of the table without modifying it.</p>
<h2 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#document-organization" id="document-organization">Document Organization</a>
</h2>
<p id="rfc.section.2.1.p.1">The HTTP/3 specification is split into seven parts.  The document begins with a detailed overview of the connection lifecycle and key concepts:</p>
<p></p>

<ul>
<li>Connection Setup and Management (<a href="#connection-setup" class="xref">Section 3</a>) covers how an HTTP/3 endpoint is discovered and a connection is established.</li>
<li>HTTP Request Lifecycle (<a href="#http-request-lifecycle" class="xref">Section 4</a>) describes how HTTP semantics are expressed using frames.</li>
<li>Connection Closure (<a href="#connection-closure" class="xref">Section 5</a>) describes how connections are terminated, either gracefully or abruptly.</li>
</ul>
<p id="rfc.section.2.1.p.3">The details of the wire protocol and interactions with the transport are described in subsequent sections:</p>
<p></p>

<ul>
<li>Stream Mapping and Usage (<a href="#stream-mapping" class="xref">Section 6</a>) describes the way QUIC streams are used.</li>
<li>HTTP Framing Layer (<a href="#http-framing-layer" class="xref">Section 7</a>) describes the frames used on most streams.</li>
<li>Error Handling (<a href="#errors" class="xref">Section 8</a>) describes how error conditions are handled and expressed, either on a particular stream or for the connection as a whole.</li>
</ul>
<p id="rfc.section.2.1.p.5">Additional resources are provided in the final sections:</p>
<p></p>

<ul>
<li>Extensions to HTTP/3 (<a href="#extensions" class="xref">Section 9</a>) describes how new capabilities can be added in future documents.</li>
<li>A more detailed comparison between HTTP/2 and HTTP/3 can be found in <a href="#h2-considerations" class="xref">Appendix A</a>.</li>
</ul>
<h2 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#conventions-and-terminology" id="conventions-and-terminology">Conventions and Terminology</a>
</h2>
<p id="rfc.section.2.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.2.2.p.2">Field definitions are given in Augmented Backus-Naur Form (ABNF), as defined in <a href="#RFC5234" class="xref">[RFC5234]</a>.</p>
<p id="rfc.section.2.2.p.3">This document uses the variable-length integer encoding from <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.</p>
<p id="rfc.section.2.2.p.4">The following terms are used:</p>
<p></p>

<dl>
<dt>abort:</dt>
<dd style="margin-left: 8">An abrupt termination of a connection or stream, possibly due to an error condition.</dd>
<dt>client:</dt>
<dd style="margin-left: 8">The endpoint that initiates an HTTP/3 connection.  Clients send HTTP requests and receive HTTP responses.</dd>
<dt>connection:</dt>
<dd style="margin-left: 8">A transport-layer connection between two endpoints, using QUIC as the transport protocol.</dd>
<dt>connection error:</dt>
<dd style="margin-left: 8">An error that affects the entire HTTP/3 connection.</dd>
<dt>endpoint:</dt>
<dd style="margin-left: 8">Either the client or server of the connection.</dd>
<dt>frame:</dt>
<dd style="margin-left: 8">The smallest unit of communication on a stream in HTTP/3, consisting of a header and a variable-length sequence of octets structured according to the frame type.  Protocol elements called &#8220;frames&#8221; exist in both this document and <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>. Where frames from <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a> are referenced, the frame name will be prefaced with &#8220;QUIC.&#8221;  For example, &#8220;QUIC CONNECTION_CLOSE frames.&#8221;  References without this preface refer to frames defined in <a href="#frames" class="xref">Section 7.2</a>.</dd>
<dt>peer:</dt>
<dd style="margin-left: 8">An endpoint.  When discussing a particular endpoint, &#8220;peer&#8221; refers to the endpoint that is remote to the primary subject of discussion.</dd>
<dt>receiver:</dt>
<dd style="margin-left: 8">An endpoint that is receiving frames.</dd>
<dt>sender:</dt>
<dd style="margin-left: 8">An endpoint that is transmitting frames.</dd>
<dt>server:</dt>
<dd style="margin-left: 8">The endpoint that accepts an HTTP/3 connection.  Servers receive HTTP requests and send HTTP responses.</dd>
<dt>stream:</dt>
<dd style="margin-left: 8">A bidirectional or unidirectional bytestream provided by the QUIC transport.</dd>
<dt>stream error:</dt>
<dd style="margin-left: 8">An error on the individual HTTP/3 stream.</dd>
</dl>
<p id="rfc.section.2.2.p.6">The term &#8220;payload body&#8221; is defined in Section 3.3 of <a href="#RFC7230" class="xref">[RFC7230]</a>.</p>
<p id="rfc.section.2.2.p.7">Finally, the terms &#8220;gateway&#8221;, &#8220;intermediary&#8221;, &#8220;proxy&#8221;, and &#8220;tunnel&#8221; are defined in Section 2.3 of <a href="#RFC7230" class="xref">[RFC7230]</a>.  Intermediaries act as both client and server at different times.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#connection-setup" id="connection-setup">Connection Setup and Management</a>
</h1>
<h2 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#draft-version-identification" id="draft-version-identification">Draft Version Identification</a>
</h2>
<p></p>

<ul class="empty"><li>
<strong>RFC Editor&#8217;s Note:</strong>  Please remove this section prior to publication of a final version of this document.</li></ul>
<p id="rfc.section.3.1.p.2">HTTP/3 uses the token &#8220;h3&#8221; to identify itself in ALPN and Alt-Svc.  Only implementations of the final, published RFC can identify themselves as &#8220;h3&#8221;.  Until such an RFC exists, implementations MUST NOT identify themselves using this string.</p>
<p id="rfc.section.3.1.p.3">Implementations of draft versions of the protocol MUST add the string &#8220;-&#8220; and the corresponding draft number to the identifier. For example, draft-ietf-quic-http-01 is identified using the string &#8220;h3-01&#8221;.</p>
<p id="rfc.section.3.1.p.4">Non-compatible experiments that are based on these draft versions MUST append the string &#8220;-&#8220; and an experiment name to the identifier. For example, an experimental implementation based on draft-ietf-quic-http-09 which reserves an extra stream for unsolicited transmission of 1980s pop music might identify itself as &#8220;h3-09-rickroll&#8221;. Note that any label MUST conform to the &#8220;token&#8221; syntax defined in Section 3.2.6 of <a href="#RFC7230" class="xref">[RFC7230]</a>. Experimenters are encouraged to coordinate their experiments on the quic@ietf.org mailing list.</p>
<h2 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#discovery" id="discovery">Discovering an HTTP/3 Endpoint</a>
</h2>
<p id="rfc.section.3.2.p.1">An HTTP origin advertises the availability of an equivalent HTTP/3 endpoint via the Alt-Svc HTTP response header field or the HTTP/2 ALTSVC frame (<a href="#ALTSVC" class="xref">[ALTSVC]</a>), using the ALPN token defined in <a href="#connection-establishment" class="xref">Section 3.3</a>.</p>
<p id="rfc.section.3.2.p.2">For example, an origin could indicate in an HTTP response that HTTP/3 was available on UDP port 50781 at the same hostname by including the following header field:</p>
<pre>
Alt-Svc: h3=":50781"
</pre>
<p id="rfc.section.3.2.p.3">On receipt of an Alt-Svc record indicating HTTP/3 support, a client MAY attempt to establish a QUIC connection to the indicated host and port and, if successful, send HTTP requests using the mapping described in this document.</p>
<p id="rfc.section.3.2.p.4">Connectivity problems (e.g. firewall blocking UDP) can result in QUIC connection establishment failure, in which case the client SHOULD continue using the existing connection or try another alternative endpoint offered by the origin.</p>
<p id="rfc.section.3.2.p.5">Servers MAY serve HTTP/3 on any UDP port, since an alternative always includes an explicit port.</p>
<h3 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#alt-svc-version-hint" id="alt-svc-version-hint">QUIC Version Hints</a>
</h3>
<p id="rfc.section.3.2.1.p.1">This document defines the &#8220;quic&#8221; parameter for Alt-Svc, which MAY be used to provide version-negotiation hints to HTTP/3 clients. QUIC versions are four-byte sequences with no additional constraints on format. Leading zeros SHOULD be omitted for brevity.</p>
<p id="rfc.section.3.2.1.p.2">Syntax:</p>
<pre>
quic = DQUOTE version-number [ "," version-number ] * DQUOTE
version-number = 1*8HEXDIG; hex-encoded QUIC version
</pre>
<p id="rfc.section.3.2.1.p.3">Where multiple versions are listed, the order of the values reflects the server&#8217;s preference (with the first value being the most preferred version).  Reserved versions MAY be listed, but unreserved versions which are not supported by the alternative SHOULD NOT be present in the list. Origins MAY omit supported versions for any reason.</p>
<p id="rfc.section.3.2.1.p.4">Clients MUST ignore any included versions which they do not support.  The &#8220;quic&#8221; parameter MUST NOT occur more than once; clients SHOULD process only the first occurrence.</p>
<p id="rfc.section.3.2.1.p.5">For example, suppose a server supported both version 0x00000001 and the version rendered in ASCII as &#8220;Q034&#8221;.  If it also opted to include the reserved version (from Section 15 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>) 0x1abadaba, it could specify the following header field:</p>
<pre>
Alt-Svc: h3=":49288";quic="1,1abadaba,51303334"
</pre>
<p id="rfc.section.3.2.1.p.6">A client acting on this header field would drop the reserved version (not supported), then attempt to connect to the alternative using the first version in the list which it does support, if any.</p>
<h2 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#connection-establishment" id="connection-establishment">Connection Establishment</a>
</h2>
<p id="rfc.section.3.3.p.1">HTTP/3 relies on QUIC as the underlying transport.  The QUIC version being used MUST use TLS version 1.3 or greater as its handshake protocol.  HTTP/3 clients MUST indicate the target domain name during the TLS handshake. This may be done using the Server Name Indication (SNI) <a href="#RFC6066" class="xref">[RFC6066]</a> extension to TLS or using some other mechanism.</p>
<p id="rfc.section.3.3.p.2">QUIC connections are established as described in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>. During connection establishment, HTTP/3 support is indicated by selecting the ALPN token &#8220;h3&#8221; in the TLS handshake.  Support for other application-layer protocols MAY be offered in the same handshake.</p>
<p id="rfc.section.3.3.p.3">While connection-level options pertaining to the core QUIC protocol are set in the initial crypto handshake, HTTP/3-specific settings are conveyed in the SETTINGS frame. After the QUIC connection is established, a SETTINGS frame (<a href="#frame-settings" class="xref">Section 7.2.5</a>) MUST be sent by each endpoint as the initial frame of their respective HTTP control stream (see <a href="#control-streams" class="xref">Section 6.2.1</a>).</p>
<h2 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#connection-reuse" id="connection-reuse">Connection Reuse</a>
</h2>
<p id="rfc.section.3.4.p.1">Once a connection exists to a server endpoint, this connection MAY be reused for requests with multiple different URI authority components.  The client MAY send any requests for which the client considers the server authoritative.</p>
<p id="rfc.section.3.4.p.2">An authoritative HTTP/3 endpoint is typically discovered because the client has received an Alt-Svc record from the request&#8217;s origin which nominates the endpoint as a valid HTTP Alternative Service for that origin.  As required by <a href="#RFC7838" class="xref">[RFC7838]</a>, clients MUST check that the nominated server can present a valid certificate for the origin before considering it authoritative. Clients MUST NOT assume that an HTTP/3 endpoint is authoritative for other origins without an explicit signal.</p>
<p id="rfc.section.3.4.p.3">A server that does not wish clients to reuse connections for a particular origin can indicate that it is not authoritative for a request by sending a 421 (Misdirected Request) status code in response to the request (see Section 9.1.2 of <a href="#HTTP2" class="xref">[HTTP2]</a>).</p>
<p id="rfc.section.3.4.p.4">The considerations discussed in Section 9.1 of <a href="#HTTP2" class="xref">[HTTP2]</a> also apply to the management of HTTP/3 connections.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#http-request-lifecycle" id="http-request-lifecycle">HTTP Request Lifecycle</a>
</h1>
<h2 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#request-response" id="request-response">HTTP Message Exchanges</a>
</h2>
<p id="rfc.section.4.1.p.1">A client sends an HTTP request on a client-initiated bidirectional QUIC stream.  A client MUST send only a single request on a given stream. A server sends zero or more non-final HTTP responses on the same stream as the request, followed by a single final HTTP response, as detailed below.</p>
<p id="rfc.section.4.1.p.2">An HTTP message (request or response) consists of:</p>
<p></p>

<ol>
<li>the message header (see <a href="#RFC7230" class="xref">[RFC7230]</a>, Section 3.2), sent as a single HEADERS frame (see <a href="#frame-headers" class="xref">Section 7.2.2</a>),</li>
<li>the payload body (see <a href="#RFC7230" class="xref">[RFC7230]</a>, Section 3.3), sent as a series of DATA frames (see <a href="#frame-data" class="xref">Section 7.2.1</a>),</li>
<li>optionally, one HEADERS frame containing the trailer-part, if present (see <a href="#RFC7230" class="xref">[RFC7230]</a>, Section 4.1.2).</li>
</ol>
<p id="rfc.section.4.1.p.4">A server MAY send one or more PUSH_PROMISE frames (see <a href="#frame-push-promise" class="xref">Section 7.2.6</a>) before, after, or interleaved with the frames of a response message. These PUSH_PROMISE frames are not part of the response; see <a href="#server-push" class="xref">Section 4.4</a> for more details.</p>
<p id="rfc.section.4.1.p.5">The HEADERS and PUSH_PROMISE frames might reference updates to the QPACK dynamic table. While these updates are not directly part of the message exchange, they must be received and processed before the message can be consumed.  See <a href="#header-formatting" class="xref">Section 4.1.1</a> for more details.</p>
<p id="rfc.section.4.1.p.6">The &#8220;chunked&#8221; transfer encoding defined in Section 4.1 of <a href="#RFC7230" class="xref">[RFC7230]</a> MUST NOT be used.</p>
<p id="rfc.section.4.1.p.7">If a DATA frame is received before a HEADERS frame on a either a request or push stream, the recipient MUST respond with a connection error of type HTTP_UNEXPECTED_FRAME (<a href="#errors" class="xref">Section 8</a>).</p>
<p id="rfc.section.4.1.p.8">Trailing header fields are carried in an additional HEADERS frame following the body. Senders MUST send only one HEADERS frame in the trailers section; receivers MUST discard any subsequent HEADERS frames.</p>
<p id="rfc.section.4.1.p.9">A response MAY consist of multiple messages when and only when one or more informational responses (1xx; see <a href="#RFC7231" class="xref">[RFC7231]</a>, Section 6.2) precede a final response to the same request.  Non-final responses do not contain a payload body or trailers.</p>
<p id="rfc.section.4.1.p.10">An HTTP request/response exchange fully consumes a bidirectional QUIC stream.  After sending a request, a client MUST close the stream for sending.  Unless using the CONNECT method (see <a href="#the-connect-method" class="xref">Section 4.2</a>), clients MUST NOT make stream closure dependent on receiving a response to their request. After sending a final response, the server MUST close the stream for sending. At this point, the QUIC stream is fully closed.</p>
<p id="rfc.section.4.1.p.11">When a stream is closed, this indicates the end of an HTTP message. Because some messages are large or unbounded, endpoints SHOULD begin processing partial HTTP messages once enough of the message has been received to make progress.  If a client stream terminates without enough of the HTTP message to provide a complete response, the server SHOULD abort its response with the error code HTTP_INCOMPLETE_REQUEST.</p>
<p id="rfc.section.4.1.p.12">A server can send a complete response prior to the client sending an entire request if the response does not depend on any portion of the request that has not been sent and received. When this is true, a server MAY abort reading the request stream with error code HTTP_EARLY_RESPONSE, send a complete response, and cleanly close the sending part of the stream. Clients MUST NOT discard complete responses as a result of having their request terminated abruptly, though clients can always discard responses at their discretion for other reasons.</p>
<h3 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#header-formatting" id="header-formatting">Header Formatting and Compression</a>
</h3>
<p id="rfc.section.4.1.1.p.1">HTTP message headers carry information as a series of key-value pairs, called header fields. For a listing of registered HTTP header fields, see the &#8220;Message Header Field&#8221; registry maintained at <a href="https://www.iana.org/assignments/message-headers">https://www.iana.org/assignments/message-headers</a>.</p>
<p id="rfc.section.4.1.1.p.2">Just as in previous versions of HTTP, header field names are strings of ASCII characters that are compared in a case-insensitive fashion.  Properties of HTTP header field names and values are discussed in more detail in Section 3.2 of <a href="#RFC7230" class="xref">[RFC7230]</a>, though the wire rendering in HTTP/3 differs.  As in HTTP/2, header field names MUST be converted to lowercase prior to their encoding.  A request or response containing uppercase header field names MUST be treated as malformed (<a href="#malformed" class="xref">Section 4.1.3</a>).</p>
<p id="rfc.section.4.1.1.p.3">As in HTTP/2, HTTP/3 uses special pseudo-header fields beginning with the &#8216;:&#8217; character (ASCII 0x3a) to convey the target URI, the method of the request, and the status code for the response.  These pseudo-header fields are defined in Section 8.1.2.3 and 8.1.2.4 of <a href="#HTTP2" class="xref">[HTTP2]</a>. Pseudo-header fields are not HTTP header fields.  Endpoints MUST NOT generate pseudo-header fields other than those defined in <a href="#HTTP2" class="xref">[HTTP2]</a>.  The restrictions on the use of pseudo-header fields in Section 8.1.2.1 of <a href="#HTTP2" class="xref">[HTTP2]</a> also apply to HTTP/3.</p>
<p id="rfc.section.4.1.1.p.4">HTTP/3 uses QPACK header compression as described in <a href="#QPACK" class="xref">[QPACK]</a>, a variation of HPACK which allows the flexibility to avoid header-compression-induced head-of-line blocking.  See that document for additional details.</p>
<p id="rfc.section.4.1.1.p.5">An HTTP/3 implementation MAY impose a limit on the maximum size of the message header it will accept on an individual HTTP message.  A server that receives a larger header field list than it is willing to handle can send an HTTP 431 (Request Header Fields Too Large) status code <a href="#RFC6585" class="xref">[RFC6585]</a>.  A client can discard responses that it cannot process.  The size of a header field list is calculated based on the uncompressed size of header fields, including the length of the name and value in bytes plus an overhead of 32 bytes for each header field.</p>
<p id="rfc.section.4.1.1.p.6">If an implementation wishes to advise its peer of this limit, it can be conveyed as a number of bytes in the <samp>SETTINGS_MAX_HEADER_LIST_SIZE</samp> parameter. An implementation which has received this parameter SHOULD NOT send an HTTP message header which exceeds the indicated size, as the peer will likely refuse to process it.  However, because this limit is applied at each hop, messages below this limit are not guaranteed to be accepted.</p>
<h3 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#request-cancellation" id="request-cancellation">Request Cancellation and Rejection</a>
</h3>
<p id="rfc.section.4.1.2.p.1">Clients can cancel requests by resetting and aborting the request stream with an error code of HTTP_REQUEST_CANCELLED (<a href="#http-error-codes" class="xref">Section 8.1</a>).  When the client aborts reading a response, it indicates that this response is no longer of interest. Implementations SHOULD cancel requests by abruptly terminating any directions of a stream that are still open.</p>
<p id="rfc.section.4.1.2.p.2">When the server rejects a request without performing any application processing, it SHOULD abort its response stream with the error code HTTP_REQUEST_REJECTED.  In this context, &#8220;processed&#8221; means that some data from the stream was passed to some higher layer of software that might have taken some action as a result. The client can treat requests rejected by the server as though they had never been sent at all, thereby allowing them to be retried later on a new connection.  Servers MUST NOT use the HTTP_REQUEST_REJECTED error code for requests which were partially or fully processed.  When a server abandons a response after partial processing, it SHOULD abort its response stream with the error code HTTP_REQUEST_CANCELLED.</p>
<p id="rfc.section.4.1.2.p.3">When a client resets a request with the error code HTTP_REQUEST_CANCELLED, a server MAY abruptly terminate the response using the error code HTTP_REQUEST_REJECTED if no processing was performed.  Clients MUST NOT use the HTTP_REQUEST_REJECTED error code, except when a server has requested closure of the request stream with this error code.</p>
<p id="rfc.section.4.1.2.p.4">If a stream is cancelled after receiving a complete response, the client MAY ignore the cancellation and use the response.  However, if a stream is cancelled after receiving a partial response, the response SHOULD NOT be used.  Automatically retrying such requests is not possible, unless this is otherwise permitted (e.g., idempotent actions like GET, PUT, or DELETE).</p>
<h3 id="rfc.section.4.1.3">
<a href="#rfc.section.4.1.3">4.1.3.</a> <a href="#malformed" id="malformed">Malformed Requests and Responses</a>
</h3>
<p id="rfc.section.4.1.3.p.1">A malformed request or response is one that is an otherwise valid sequence of frames but is invalid due to the presence of extraneous frames, prohibited header fields, the absence of mandatory header fields, or the inclusion of uppercase header field names.</p>
<p id="rfc.section.4.1.3.p.2">A request or response that includes a payload body can include a <samp>content-length</samp> header field.  A request or response is also malformed if the value of a content-length header field does not equal the sum of the DATA frame payload lengths that form the body.  A response that is defined to have no payload, as described in Section 3.3.2 of <a href="#RFC7230" class="xref">[RFC7230]</a> can have a non-zero content-length header field, even though no content is included in DATA frames.</p>
<p id="rfc.section.4.1.3.p.3">Intermediaries that process HTTP requests or responses (i.e., any intermediary not acting as a tunnel) MUST NOT forward a malformed request or response.  Malformed requests or responses that are detected MUST be treated as a stream error (<a href="#errors" class="xref">Section 8</a>) of type HTTP_GENERAL_PROTOCOL_ERROR.</p>
<p id="rfc.section.4.1.3.p.4">For malformed requests, a server MAY send an HTTP response prior to closing or resetting the stream.  Clients MUST NOT accept a malformed response.  Note that these requirements are intended to protect against several types of common attacks against HTTP; they are deliberately strict because being permissive can expose implementations to these vulnerabilities.</p>
<h2 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#the-connect-method" id="the-connect-method">The CONNECT Method</a>
</h2>
<p id="rfc.section.4.2.p.1">The pseudo-method CONNECT (<a href="#RFC7231" class="xref">[RFC7231]</a>, Section 4.3.6) is primarily used with HTTP proxies to establish a TLS session with an origin server for the purposes of interacting with &#8220;https&#8221; resources. In HTTP/1.x, CONNECT is used to convert an entire HTTP connection into a tunnel to a remote host. In HTTP/2, the CONNECT method is used to establish a tunnel over a single HTTP/2 stream to a remote host for similar purposes.</p>
<p id="rfc.section.4.2.p.2">A CONNECT request in HTTP/3 functions in the same manner as in HTTP/2. The request MUST be formatted as described in <a href="#HTTP2" class="xref">[HTTP2]</a>, Section 8.3. A CONNECT request that does not conform to these restrictions is malformed (see <a href="#malformed" class="xref">Section 4.1.3</a>). The request stream MUST NOT be closed at the end of the request.</p>
<p id="rfc.section.4.2.p.3">A proxy that supports CONNECT establishes a TCP connection (<a href="#RFC0793" class="xref">[RFC0793]</a>) to the server identified in the &#8220;:authority&#8221; pseudo-header field. Once this connection is successfully established, the proxy sends a HEADERS frame containing a 2xx series status code to the client, as defined in <a href="#RFC7231" class="xref">[RFC7231]</a>, Section 4.3.6.</p>
<p id="rfc.section.4.2.p.4">All DATA frames on the stream correspond to data sent or received on the TCP connection. Any DATA frame sent by the client is transmitted by the proxy to the TCP server; data received from the TCP server is packaged into DATA frames by the proxy. Note that the size and number of TCP segments is not guaranteed to map predictably to the size and number of HTTP DATA or QUIC STREAM frames.</p>
<p id="rfc.section.4.2.p.5">Once the CONNECT method has completed, only DATA frames are permitted to be sent on the stream.  Extension frames MAY be used if specifically permitted by the definition of the extension.  Receipt of any other frame type MUST be treated as a connection error of type HTTP_UNEXPECTED_FRAME.</p>
<p id="rfc.section.4.2.p.6">The TCP connection can be closed by either peer. When the client ends the request stream (that is, the receive stream at the proxy enters the &#8220;Data Recvd&#8221; state), the proxy will set the FIN bit on its connection to the TCP server. When the proxy receives a packet with the FIN bit set, it will terminate the send stream that it sends to the client. TCP connections which remain half-closed in a single direction are not invalid, but are often handled poorly by servers, so clients SHOULD NOT close a stream for sending while they still expect to receive data from the target of the CONNECT.</p>
<p id="rfc.section.4.2.p.7">A TCP connection error is signaled by abruptly terminating the stream. A proxy treats any error in the TCP connection, which includes receiving a TCP segment with the RST bit set, as a stream error of type HTTP_CONNECT_ERROR (<a href="#http-error-codes" class="xref">Section 8.1</a>).  Correspondingly, if a proxy detects an error with the stream or the QUIC connection, it MUST close the TCP connection.  If the underlying TCP implementation permits it, the proxy SHOULD send a TCP segment with the RST bit set.</p>
<h2 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#priority" id="priority">Prioritization</a>
</h2>
<p id="rfc.section.4.3.p.1">The purpose of prioritization is to allow a client to express how it would prefer the server to allocate resources when managing concurrent streams.  Most importantly, priority can be used to select streams for transmitting frames when there is limited capacity for sending.</p>
<p id="rfc.section.4.3.p.2">HTTP/3 uses a priority scheme similar to that described in <a href="#RFC7540" class="xref">[RFC7540]</a>, Section 5.3. In this priority scheme, a given element can be designated as dependent upon another element.  Each dependency is assigned a relative weight, a number that is used to determine the relative proportion of available resources that are assigned to streams dependent on the same stream. This information is expressed in the PRIORITY frame <a href="#frame-priority" class="xref">Section 7.2.3</a> which identifies the element and the dependency. The elements that can be prioritized are:</p>
<p></p>

<ul>
<li>Requests, identified by the ID of the request stream</li>
<li>Pushes, identified by the Push ID of the promised resource (<a href="#frame-push-promise" class="xref">Section 7.2.6</a>)</li>
<li>Placeholders, identified by a Placeholder ID</li>
</ul>
<p id="rfc.section.4.3.p.4">Taken together, the dependencies across all prioritized elements in a connection form a dependency tree. An element can depend on another element or on the root of the tree.  The tree also contains an orphan placeholder.  This placeholder cannot be reprioritized, and no resources should be allocated to descendants of the orphan placeholder if progress can be made on descendants of the root.  The structure of the dependency tree changes as PRIORITY frames modify the dependency links between other prioritized elements.</p>
<p id="rfc.section.4.3.p.5">An exclusive flag allows for the insertion of a new level of dependencies.  The exclusive flag causes the prioritized element to become the sole dependency of its parent, causing other dependencies to become dependent on the exclusive element.</p>
<p id="rfc.section.4.3.p.6">All dependent streams are allocated an integer weight between 1 and 256 (inclusive), derived by adding one to the weight expressed in the PRIORITY frame.</p>
<p id="rfc.section.4.3.p.7">Streams with the same parent SHOULD be allocated resources proportionally based on their weight.  Thus, if stream B depends on stream A with weight 4, stream C depends on stream A with weight 12, and no progress can be made on stream A, stream B ideally receives one-third of the resources allocated to stream C.</p>
<p id="rfc.section.4.3.p.8">A reference to an element which is no longer in the tree is treated as a reference to the orphan placeholder. Due to reordering between streams, an element can also be prioritized which is not yet in the tree. Such elements are added to the tree with the requested priority.  If a prioritized element depends on another element which is not yet in the tree, the requested parent is first added to the tree with the default priority.</p>
<p id="rfc.section.4.3.p.9">When a prioritized element is first created, it has a default initial weight of 16 and a default dependency. Requests and placeholders are dependent on the orphan placeholder; pushes are dependent on the client request on which the PUSH_PROMISE frame was sent.</p>
<p id="rfc.section.4.3.p.10">Priorities can be updated by sending a PRIORITY frame (see <a href="#frame-priority" class="xref">Section 7.2.3</a>) on the control stream.</p>
<h3 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#placeholders" id="placeholders">Placeholders</a>
</h3>
<p id="rfc.section.4.3.1.p.1">In HTTP/2, certain implementations used closed or unused streams as placeholders in describing the relative priority of requests.  This created confusion as servers could not reliably identify which elements of the priority tree could be discarded safely. Clients could potentially reference closed streams long after the server had discarded state, leading to disparate views of the prioritization the client had attempted to express.</p>
<p id="rfc.section.4.3.1.p.2">In HTTP/3, a number of placeholders are explicitly permitted by the server using the <samp>SETTINGS_NUM_PLACEHOLDERS</samp> setting. Because the server commits to maintaining these placeholders in the prioritization tree, clients can use them with confidence that the server will not have discarded the state. Clients MUST NOT send the <samp>SETTINGS_NUM_PLACEHOLDERS</samp> setting; receipt of this setting by a server MUST be treated as a connection error of type <samp>HTTP_SETTINGS_ERROR</samp>.</p>
<p id="rfc.section.4.3.1.p.3">Client-controlled placeholders are identified by an ID between zero and one less than the number of placeholders the server has permitted.  The orphan placeholder cannot be prioritized or referenced by the client.</p>
<p id="rfc.section.4.3.1.p.4">Like streams, client-controlled placeholders have priority information associated with them.</p>
<h3 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> <a href="#priority-tree-maintenance" id="priority-tree-maintenance">Priority Tree Maintenance</a>
</h3>
<p id="rfc.section.4.3.2.p.1">Because placeholders will be used to &#8220;root&#8221; any persistent structure of the tree which the client cares about retaining, servers can aggressively prune inactive regions from the priority tree. For prioritization purposes, a node in the tree is considered &#8220;inactive&#8221; when the corresponding stream has been closed for at least two round-trip times (using any reasonable estimate available on the server).  This delay helps mitigate race conditions where the server has pruned a node the client believed was still active and used as a Stream Dependency.</p>
<p id="rfc.section.4.3.2.p.2">Specifically, the server MAY at any time:</p>
<p></p>

<ul>
<li>Identify and discard branches of the tree containing only inactive nodes (i.e. a node with only other inactive nodes as descendants, along with those descendants)</li>
<li>Identify and condense interior regions of the tree containing only inactive nodes, allocating weight appropriately</li>
</ul>
<div id="rfc.figure.1"></div>
<div id="fig-pruning"></div>
<pre>
    x                x                 x
    |                |                 |
    P                P                 P
   / \               |                 |
  I   I     ==&gt;      I      ==&gt;        A
     / \             |                 |
    A   I            A                 A
    |                |
    A                A
</pre>
<p class="figure">Figure 1: Example of Priority Tree Pruning</p>
<p id="rfc.section.4.3.2.p.4">In the example in <a href="#fig-pruning" class="xref">Figure 1</a>, <samp>P</samp> represents a Placeholder, <samp>A</samp> represents an active node, and <samp>I</samp> represents an inactive node.  In the first step, the server discards two inactive branches (each a single node).  In the second step, the server condenses an interior inactive node.  Note that these transformations will result in no change in the resources allocated to a particular active stream.</p>
<p id="rfc.section.4.3.2.p.5">Clients SHOULD assume the server is actively performing such pruning and SHOULD NOT declare a dependency on a stream it knows to have been closed.</p>
<h2 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#server-push" id="server-push">Server Push</a>
</h2>
<p id="rfc.section.4.4.p.1">Server push is an interaction mode introduced in HTTP/2 <a href="#HTTP2" class="xref">[HTTP2]</a> which permits a server to push a request-response exchange to a client in anticipation of the client making the indicated request.  This trades off network usage against a potential latency gain.  HTTP/3 server push is similar to what is described in HTTP/2 <a href="#HTTP2" class="xref">[HTTP2]</a>, but uses different mechanisms.</p>
<p id="rfc.section.4.4.p.2">Each server push is identified by a unique Push ID. This Push ID is used in a single PUSH_PROMISE frame (see <a href="#frame-push-promise" class="xref">Section 7.2.6</a>) which carries the request headers, possibly included in one or more DUPLICATE_PUSH frames (see <a href="#frame-duplicate-push" class="xref">Section 7.2.9</a>), then included with the push stream which ultimately fulfills those promises.</p>
<p id="rfc.section.4.4.p.3">Server push is only enabled on a connection when a client sends a MAX_PUSH_ID frame (see <a href="#frame-max-push-id" class="xref">Section 7.2.8</a>). A server cannot use server push until it receives a MAX_PUSH_ID frame. A client sends additional MAX_PUSH_ID frames to control the number of pushes that a server can promise. A server SHOULD use Push IDs sequentially, starting at 0. A client MUST treat receipt of a push stream with a Push ID that is greater than the maximum Push ID as a connection error of type HTTP_ID_ERROR.</p>
<p id="rfc.section.4.4.p.4">The header of the request message is carried by a PUSH_PROMISE frame (see <a href="#frame-push-promise" class="xref">Section 7.2.6</a>) on the request stream which generated the push. This allows the server push to be associated with a client request.  Promised requests MUST conform to the requirements in Section 8.2 of <a href="#HTTP2" class="xref">[HTTP2]</a>.</p>
<p id="rfc.section.4.4.p.5">The same server push can be associated with additional client requests using a DUPLICATE_PUSH frame (see <a href="#frame-duplicate-push" class="xref">Section 7.2.9</a>).</p>
<p id="rfc.section.4.4.p.6">Ordering of a PUSH_PROMISE or DUPLICATE_PUSH in relation to certain parts of the response is important. The server SHOULD send PUSH_PROMISE or DUPLICATE_PUSH frames prior to sending HEADERS or DATA frames that reference the promised responses.  This reduces the chance that a client requests a resource that will be pushed by the server.</p>
<p id="rfc.section.4.4.p.7">When a server later fulfills a promise, the server push response is conveyed on a push stream (see <a href="#push-streams" class="xref">Section 6.2.2</a>). The push stream identifies the Push ID of the promise that it fulfills, then contains a response to the promised request using the same format described for responses in <a href="#request-response" class="xref">Section 4.1</a>.</p>
<p id="rfc.section.4.4.p.8">Due to reordering, DUPLICATE_PUSH frames or push stream data can arrive before the corresponding PUSH_PROMISE frame.  When a client receives a DUPLICATE_PUSH frame for an as-yet-unknown Push ID, the request headers of the push are not immediately available.  The client can either delay generating new requests for content referenced following the DUPLICATE_PUSH frame until the request headers become available, or can initiate requests for discovered resources and cancel the requests if the requested resource is already being pushed. When a client receives a new push stream with an as-yet-unknown Push ID, both the associated client request and the pushed request headers are unknown.  The client can buffer the stream data in expectation of the matching PUSH_PROMISE. The client can use stream flow control (see section 4.1 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>) to limit the amount of data a server may commit to the pushed stream.</p>
<p id="rfc.section.4.4.p.9">If a promised server push is not needed by the client, the client SHOULD send a CANCEL_PUSH frame. If the push stream is already open or opens after sending the CANCEL_PUSH frame, the client can abort reading the stream with an error code of HTTP_REQUEST_CANCELLED. This asks the server not to transfer additional data and indicates that it will be discarded upon receipt.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#connection-closure" id="connection-closure">Connection Closure</a>
</h1>
<p id="rfc.section.5.p.1">Once established, an HTTP/3 connection can be used for many requests and responses over time until the connection is closed.  Connection closure can happen in any of several different ways.</p>
<h2 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#idle-connections" id="idle-connections">Idle Connections</a>
</h2>
<p id="rfc.section.5.1.p.1">Each QUIC endpoint declares an idle timeout during the handshake.  If the connection remains idle (no packets received) for longer than this duration, the peer will assume that the connection has been closed.  HTTP/3 implementations will need to open a new connection for new requests if the existing connection has been idle for longer than the server&#8217;s advertised idle timeout, and SHOULD do so if approaching the idle timeout.</p>
<p id="rfc.section.5.1.p.2">HTTP clients are expected to request that the transport keep connections open while there are responses outstanding for requests or server pushes, as described in Section 19.2 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>. If the client is not expecting a response from the server, allowing an idle connection to time out is preferred over expending effort maintaining a connection that might not be needed.  A gateway MAY maintain connections in anticipation of need rather than incur the latency cost of connection establishment to servers. Servers SHOULD NOT actively keep connections open.</p>
<h2 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#connection-shutdown" id="connection-shutdown">Connection Shutdown</a>
</h2>
<p id="rfc.section.5.2.p.1">Even when a connection is not idle, either endpoint can decide to stop using the connection and let the connection close gracefully.  Since clients drive request generation, clients perform a connection shutdown by not sending additional requests on the connection; responses and pushed responses associated to previous requests will continue to completion.  Servers perform the same function by communicating with clients.</p>
<p id="rfc.section.5.2.p.2">Servers initiate the shutdown of a connection by sending a GOAWAY frame (<a href="#frame-goaway" class="xref">Section 7.2.7</a>).  The GOAWAY frame indicates that client-initiated requests on lower stream IDs were or might be processed in this connection, while requests on the indicated stream ID and greater were rejected. This enables client and server to agree on which requests were accepted prior to the connection shutdown.  This identifier MAY be zero if no requests were processed.  Servers SHOULD NOT permit additional QUIC streams after sending a GOAWAY frame.</p>
<p id="rfc.section.5.2.p.3">Clients MUST NOT send new requests on the connection after receiving GOAWAY; a new connection MAY be established to send additional requests.</p>
<p id="rfc.section.5.2.p.4">Some requests might already be in transit. If the client has already sent requests on streams with a Stream ID greater than or equal to that indicated in the GOAWAY frame, those requests will not be processed and MAY be retried by the client on a different connection.  The client MAY cancel these requests.  It is RECOMMENDED that the server explicitly reject such requests (see <a href="#request-cancellation" class="xref">Section 4.1.2</a>) in order to clean up transport state for the affected streams.</p>
<p id="rfc.section.5.2.p.5">Requests on Stream IDs less than the Stream ID in the GOAWAY frame might have been processed; their status cannot be known until a response is received, the stream is reset individually, or the connection terminates.  Servers MAY reject individual requests on streams below the indicated ID if these requests were not processed.</p>
<p id="rfc.section.5.2.p.6">Servers SHOULD send a GOAWAY frame when the closing of a connection is known in advance, even if the advance notice is small, so that the remote peer can know whether a request has been partially processed or not.  For example, if an HTTP client sends a POST at the same time that a server closes a QUIC connection, the client cannot know if the server started to process that POST request if the server does not send a GOAWAY frame to indicate what streams it might have acted on.</p>
<p id="rfc.section.5.2.p.7">A client that is unable to retry requests loses all requests that are in flight when the server closes the connection.  A server MAY send multiple GOAWAY frames indicating different stream IDs, but MUST NOT increase the value they send in the last Stream ID, since clients might already have retried unprocessed requests on another connection.  A server that is attempting to gracefully shut down a connection SHOULD send an initial GOAWAY frame with the last Stream ID set to the maximum value allowed by QUIC&#8217;s MAX_STREAMS and SHOULD NOT increase the MAX_STREAMS limit thereafter.  This signals to the client that a shutdown is imminent and that initiating further requests is prohibited.  After allowing time for any in-flight requests (at least one round-trip time), the server MAY send another GOAWAY frame with an updated last Stream ID.  This ensures that a connection can be cleanly shut down without losing requests.</p>
<p id="rfc.section.5.2.p.8">Once all accepted requests have been processed, the server can permit the connection to become idle, or MAY initiate an immediate closure of the connection.  An endpoint that completes a graceful shutdown SHOULD use the HTTP_NO_ERROR code when closing the connection.</p>
<p id="rfc.section.5.2.p.9">If a client has consumed all available bidirectional stream IDs with requests, the server need not send a GOAWAY frame, since the client is unable to make further requests.</p>
<h2 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#immediate-application-closure" id="immediate-application-closure">Immediate Application Closure</a>
</h2>
<p id="rfc.section.5.3.p.1">An HTTP/3 implementation can immediately close the QUIC connection at any time.  This results in sending a QUIC CONNECTION_CLOSE frame to the peer; the error code in this frame indicates to the peer why the connection is being closed.  See <a href="#errors" class="xref">Section 8</a> for error codes which can be used when closing a connection.</p>
<p id="rfc.section.5.3.p.2">Before closing the connection, a GOAWAY MAY be sent to allow the client to retry some requests.  Including the GOAWAY frame in the same packet as the QUIC CONNECTION_CLOSE frame improves the chances of the frame being received by clients.</p>
<h2 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#transport-closure" id="transport-closure">Transport Closure</a>
</h2>
<p id="rfc.section.5.4.p.1">For various reasons, the QUIC transport could indicate to the application layer that the connection has terminated.  This might be due to an explicit closure by the peer, a transport-level error, or a change in network topology which interrupts connectivity.</p>
<p id="rfc.section.5.4.p.2">If a connection terminates without a GOAWAY frame, clients MUST assume that any request which was sent, whether in whole or in part, might have been processed.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#stream-mapping" id="stream-mapping">Stream Mapping and Usage</a>
</h1>
<p id="rfc.section.6.p.1">A QUIC stream provides reliable in-order delivery of bytes, but makes no guarantees about order of delivery with regard to bytes on other streams. On the wire, data is framed into QUIC STREAM frames, but this framing is invisible to the HTTP framing layer. The transport layer buffers and orders received QUIC STREAM frames, exposing the data contained within as a reliable byte stream to the application. Although QUIC permits out-of-order delivery within a stream, HTTP/3 does not make use of this feature.</p>
<p id="rfc.section.6.p.2">QUIC streams can be either unidirectional, carrying data only from initiator to receiver, or bidirectional.  Streams can be initiated by either the client or the server.  For more detail on QUIC streams, see Section 2 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.</p>
<p id="rfc.section.6.p.3">When HTTP headers and data are sent over QUIC, the QUIC layer handles most of the stream management.  HTTP does not need to do any separate multiplexing when using QUIC - data sent over a QUIC stream always maps to a particular HTTP transaction or connection context.</p>
<h2 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#bidirectional-streams" id="bidirectional-streams">Bidirectional Streams</a>
</h2>
<p id="rfc.section.6.1.p.1">All client-initiated bidirectional streams are used for HTTP requests and responses.  A bidirectional stream ensures that the response can be readily correlated with the request. This means that the client&#8217;s first request occurs on QUIC stream 0, with subsequent requests on stream 4, 8, and so on. In order to permit these streams to open, an HTTP/3 server SHOULD configure non-zero minimum values for the number of permitted streams and the initial stream flow control window.  It is RECOMMENDED that at least 100 requests be permitted at a time, so as to not unnecessarily limit parallelism.</p>
<p id="rfc.section.6.1.p.2">HTTP/3 does not use server-initiated bidirectional streams, though an extension could define a use for these streams.  Clients MUST treat receipt of a server-initiated bidirectional stream as a connection error of type HTTP_STREAM_CREATION_ERROR unless such an extension has been negotiated.</p>
<h2 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#unidirectional-streams" id="unidirectional-streams">Unidirectional Streams</a>
</h2>
<p id="rfc.section.6.2.p.1">Unidirectional streams, in either direction, are used for a range of purposes.  The purpose is indicated by a stream type, which is sent as a variable-length integer at the start of the stream. The format and structure of data that follows this integer is determined by the stream type.</p>
<div id="rfc.figure.2"></div>
<div id="fig-stream-header"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream Type (i)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 2: Unidirectional Stream Header</p>
<p id="rfc.section.6.2.p.2">Some stream types are reserved (<a href="#stream-grease" class="xref">Section 6.2.3</a>).  Two stream types are defined in this document: control streams (<a href="#control-streams" class="xref">Section 6.2.1</a>) and push streams (<a href="#push-streams" class="xref">Section 6.2.2</a>).  Other stream types can be defined by extensions to HTTP/3; see <a href="#extensions" class="xref">Section 9</a> for more details.</p>
<p id="rfc.section.6.2.p.3">The performance of HTTP/3 connections in the early phase of their lifetime is sensitive to the creation and exchange of data on unidirectional streams.  Endpoints that excessively restrict the number of streams or the flow control window of these streams will increase the chance that the remote peer reaches the limit early and becomes blocked. In particular, implementations should consider that remote peers may wish to exercise reserved stream behavior (<a href="#stream-grease" class="xref">Section 6.2.3</a>) with some of the unidirectional streams they are permitted to use. To avoid blocking, the transport parameters sent by both clients and servers MUST allow the peer to create at least one unidirectional stream for the HTTP control stream plus the number of unidirectional streams required by mandatory extensions (three being the minimum number required for the base HTTP/3 protocol and QPACK), and SHOULD provide at least 1,024 bytes of flow control credit to each stream.</p>
<p id="rfc.section.6.2.p.4">Note that an endpoint is not required to grant additional credits to create more unidirectional streams if its peer consumes all the initial credits before creating the critical unidirectional streams. Endpoints SHOULD create the HTTP control stream as well as the unidirectional streams required by mandatory extensions (such as the QPACK encoder and decoder streams) first, and then create additional streams as allowed by their peer.</p>
<p id="rfc.section.6.2.p.5">If the stream header indicates a stream type which is not supported by the recipient, the remainder of the stream cannot be consumed as the semantics are unknown. Recipients of unknown stream types MAY abort reading of the stream with an error code of HTTP_STREAM_CREATION_ERROR, but MUST NOT consider such streams to be a connection error of any kind.</p>
<p id="rfc.section.6.2.p.6">Implementations MAY send stream types before knowing whether the peer supports them.  However, stream types which could modify the state or semantics of existing protocol components, including QPACK or other extensions, MUST NOT be sent until the peer is known to support them.</p>
<p id="rfc.section.6.2.p.7">A sender can close or reset a unidirectional stream unless otherwise specified.  A receiver MUST tolerate unidirectional streams being closed or reset prior to the reception of the unidirectional stream header.</p>
<h3 id="rfc.section.6.2.1">
<a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#control-streams" id="control-streams">Control Streams</a>
</h3>
<p id="rfc.section.6.2.1.p.1">A control stream is indicated by a stream type of <samp>0x00</samp>.  Data on this stream consists of HTTP/3 frames, as defined in <a href="#frames" class="xref">Section 7.2</a>.</p>
<p id="rfc.section.6.2.1.p.2">Each side MUST initiate a single control stream at the beginning of the connection and send its SETTINGS frame as the first frame on this stream.  If the first frame of the control stream is any other frame type, this MUST be treated as a connection error of type HTTP_MISSING_SETTINGS. Only one control stream per peer is permitted; receipt of a second stream which claims to be a control stream MUST be treated as a connection error of type HTTP_STREAM_CREATION_ERROR.  The sender MUST NOT close the control stream, and the receiver MUST NOT request that the sender close the control stream.  If either control stream is closed at any point, this MUST be treated as a connection error of type HTTP_CLOSED_CRITICAL_STREAM.</p>
<p id="rfc.section.6.2.1.p.3">A pair of unidirectional streams is used rather than a single bidirectional stream.  This allows either peer to send data as soon as it is able.  Depending on whether 0-RTT is enabled on the connection, either client or server might be able to send stream data first after the cryptographic handshake completes.</p>
<h3 id="rfc.section.6.2.2">
<a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#push-streams" id="push-streams">Push Streams</a>
</h3>
<p id="rfc.section.6.2.2.p.1">Server push is an optional feature introduced in HTTP/2 that allows a server to initiate a response before a request has been made.  See <a href="#server-push" class="xref">Section 4.4</a> for more details.</p>
<p id="rfc.section.6.2.2.p.2">A push stream is indicated by a stream type of <samp>0x01</samp>, followed by the Push ID of the promise that it fulfills, encoded as a variable-length integer. The remaining data on this stream consists of HTTP/3 frames, as defined in <a href="#frames" class="xref">Section 7.2</a>, and fulfills a promised server push.  Server push and Push IDs are described in <a href="#server-push" class="xref">Section 4.4</a>.</p>
<p id="rfc.section.6.2.2.p.3">Only servers can push; if a server receives a client-initiated push stream, this MUST be treated as a connection error of type HTTP_STREAM_CREATION_ERROR.</p>
<div id="rfc.figure.3"></div>
<div id="fig-push-stream-header"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           0x01 (i)                          ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Push ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 3: Push Stream Header</p>
<p id="rfc.section.6.2.2.p.4">Each Push ID MUST only be used once in a push stream header. If a push stream header includes a Push ID that was used in another push stream header, the client MUST treat this as a connection error of type HTTP_ID_ERROR.</p>
<h3 id="rfc.section.6.2.3">
<a href="#rfc.section.6.2.3">6.2.3.</a> <a href="#stream-grease" id="stream-grease">Reserved Stream Types</a>
</h3>
<p id="rfc.section.6.2.3.p.1">Stream types of the format <samp>0x1f * N + 0x21</samp> for integer values of N are reserved to exercise the requirement that unknown types be ignored. These streams have no semantics, and can be sent when application-layer padding is desired. They MAY also be sent on connections where no data is currently being transferred. Endpoints MUST NOT consider these streams to have any meaning upon receipt.</p>
<p id="rfc.section.6.2.3.p.2">The payload and length of the stream are selected in any manner the implementation chooses.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#http-framing-layer" id="http-framing-layer">HTTP Framing Layer</a>
</h1>
<p id="rfc.section.7.p.1">HTTP frames are carried on QUIC streams, as described in <a href="#stream-mapping" class="xref">Section 6</a>.  HTTP/3 defines three stream types: control stream, request stream, and push stream. This section describes HTTP/3 frame formats and the streams types on which they are permitted; see <a href="#stream-frame-mapping" class="xref">Table 1</a> for an overview.  A comparison between HTTP/2 and HTTP/3 frames is provided in <a href="#h2-frames" class="xref">Appendix A.2</a>.</p>
<div id="rfc.table.1"></div>
<div id="stream-frame-mapping"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>HTTP/3 frames and stream type overview</caption>
<thead><tr>
<th class="left">Frame</th>
<th class="left">Control Stream</th>
<th class="left">Request Stream</th>
<th class="left">Push Stream</th>
<th class="left">Section</th>
</tr></thead>
<tbody>
<tr>
<td class="left">DATA</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left"><a href="#frame-data" class="xref">Section 7.2.1</a></td>
</tr>
<tr>
<td class="left">HEADERS</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left"><a href="#frame-headers" class="xref">Section 7.2.2</a></td>
</tr>
<tr>
<td class="left">PRIORITY</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left"><a href="#frame-priority" class="xref">Section 7.2.3</a></td>
</tr>
<tr>
<td class="left">CANCEL_PUSH</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left"><a href="#frame-cancel-push" class="xref">Section 7.2.4</a></td>
</tr>
<tr>
<td class="left">SETTINGS</td>
<td class="left">Yes (1)</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left"><a href="#frame-settings" class="xref">Section 7.2.5</a></td>
</tr>
<tr>
<td class="left">PUSH_PROMISE</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left"><a href="#frame-push-promise" class="xref">Section 7.2.6</a></td>
</tr>
<tr>
<td class="left">GOAWAY</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left"><a href="#frame-goaway" class="xref">Section 7.2.7</a></td>
</tr>
<tr>
<td class="left">MAX_PUSH_ID</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left"><a href="#frame-max-push-id" class="xref">Section 7.2.8</a></td>
</tr>
<tr>
<td class="left">DUPLICATE_PUSH</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left"><a href="#frame-duplicate-push" class="xref">Section 7.2.9</a></td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.p.2">Certain frames can only occur as the first frame of a particular stream type; these are indicated in <a href="#stream-frame-mapping" class="xref">Table 1</a> with a (1).  Specific guidance is provided in the relevant section.</p>
<p id="rfc.section.7.p.3">Note that, unlike QUIC frames, HTTP/3 frames can span multiple packets.</p>
<h2 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#frame-layout" id="frame-layout">Frame Layout</a>
</h2>
<p id="rfc.section.7.1.p.1">All frames have the following format:</p>
<div id="rfc.figure.4"></div>
<div id="fig-frame"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Type (i)                          ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Length (i)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Frame Payload (*)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 4: HTTP/3 frame format</p>
<p id="rfc.section.7.1.p.2">A frame includes the following fields:</p>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">A variable-length integer that identifies the frame type.</dd>
<dt>Length:</dt>
<dd style="margin-left: 8">A variable-length integer that describes the length of the Frame Payload.</dd>
<dt>Frame Payload:</dt>
<dd style="margin-left: 8">A payload, the semantics of which are determined by the Type field.</dd>
</dl>
<p id="rfc.section.7.1.p.4">Each frame&#8217;s payload MUST contain exactly the fields identified in its description.  A frame payload that contains additional bytes after the identified fields or a frame payload that terminates before the end of the identified fields MUST be treated as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.7.1.p.5">When a stream terminates cleanly, if the last frame on the stream was truncated, this MUST be treated as a connection error (<a href="#errors" class="xref">Section 8</a>) of type HTTP_MALFORMED_FRAME. Streams which terminate abruptly may be reset at any point in a frame.</p>
<h2 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#frames" id="frames">Frame Definitions</a>
</h2>
<h3 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> <a href="#frame-data" id="frame-data">DATA</a>
</h3>
<p id="rfc.section.7.2.1.p.1">DATA frames (type=0x0) convey arbitrary, variable-length sequences of bytes associated with an HTTP request or response payload.</p>
<p id="rfc.section.7.2.1.p.2">DATA frames MUST be associated with an HTTP request or response.  If a DATA frame is received on a control stream, the recipient MUST respond with a connection error (<a href="#errors" class="xref">Section 8</a>) of type HTTP_WRONG_STREAM.</p>
<div id="rfc.figure.5"></div>
<div id="fig-data"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Payload (*)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 5: DATA frame payload</p>
<h3 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> <a href="#frame-headers" id="frame-headers">HEADERS</a>
</h3>
<p id="rfc.section.7.2.2.p.1">The HEADERS frame (type=0x1) is used to carry a header block, compressed using QPACK. See <a href="#QPACK" class="xref">[QPACK]</a> for more details.</p>
<div id="rfc.figure.6"></div>
<div id="fig-headers"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Header Block (*)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 6: HEADERS frame payload</p>
<p id="rfc.section.7.2.2.p.2">HEADERS frames can only be sent on request / push streams.  If a HEADERS frame is received on a control stream, the recipient MUST respond with a connection error (<a href="#errors" class="xref">Section 8</a>) of type HTTP_WRONG_STREAM.</p>
<h3 id="rfc.section.7.2.3">
<a href="#rfc.section.7.2.3">7.2.3.</a> <a href="#frame-priority" id="frame-priority">PRIORITY</a>
</h3>
<p id="rfc.section.7.2.3.p.1">The PRIORITY (type=0x2) frame specifies the client-advised priority of a request, server push or placeholder.</p>
<p id="rfc.section.7.2.3.p.2">A PRIORITY frame identifies an element to prioritize, and an element upon which it depends.  A Prioritized ID or Dependency ID identifies a client-initiated request using the corresponding stream ID, a server push using a Push ID (see <a href="#frame-push-promise" class="xref">Section 7.2.6</a>), or a placeholder using a Placeholder ID (see <a href="#placeholders" class="xref">Section 4.3.1</a>).</p>
<p id="rfc.section.7.2.3.p.3">In order to ensure that prioritization is processed in a consistent order, PRIORITY frames MUST be sent on the control stream.</p>
<div id="rfc.figure.7"></div>
<div id="fig-priority"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|PT |DT |X|Empty|          Prioritized Element ID (i)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                [Element Dependency ID (i)]                  ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Weight (8)  |
+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 7: PRIORITY frame payload</p>
<p id="rfc.section.7.2.3.p.4">The PRIORITY frame payload has the following fields:</p>
<p></p>

<dl>
<dt>PT (Prioritized Element Type):</dt>
<dd style="margin-left: 8">A two-bit field indicating the type of element being prioritized (see <a href="#priority-element-types" class="xref">Table 2</a>).  This MUST NOT be set to <samp>11</samp>.</dd>
<dt>DT (Element Dependency Type):</dt>
<dd style="margin-left: 8">A two-bit field indicating the type of element being depended on (see <a href="#priority-element-types" class="xref">Table 2</a>).</dd>
<dt>X (Exclusive Flag):</dt>
<dd style="margin-left: 8">A single-bit flag indicating that the dependency is exclusive (see <a href="#priority" class="xref">Section 4.3</a>).</dd>
<dt>Empty:</dt>
<dd style="margin-left: 8">A three-bit field which MUST be zero when sent and has no semantic value on receipt.</dd>
<dt>Prioritized Element ID:</dt>
<dd style="margin-left: 8">A variable-length integer that identifies the element being prioritized.  Depending on the value of Prioritized Type, this contains the Stream ID of a request stream, the Push ID of a promised resource, or a Placeholder ID of a placeholder.</dd>
<dt>Element Dependency ID:</dt>
<dd style="margin-left: 8">A variable-length integer that identifies the element on which a dependency is being expressed. Depending on the value of Dependency Type, this contains the Stream ID of a request stream, the Push ID of a promised resource, the Placeholder ID of a placeholder, or is absent.  For details of dependencies, see <a href="#priority" class="xref">Section 4.3</a> and <a href="#HTTP2" class="xref">[HTTP2]</a>, Section 5.3.</dd>
<dt>Weight:</dt>
<dd style="margin-left: 8">An unsigned 8-bit integer representing a priority weight for the prioritized element (see <a href="#HTTP2" class="xref">[HTTP2]</a>, Section 5.3). Add one to the value to obtain a weight between 1 and 256.</dd>
</dl>
<p id="rfc.section.7.2.3.p.6">The values for the Prioritized Element Type and Element Dependency Type (<a href="#priority-element-types" class="xref">Table 2</a>) imply the interpretation of the associated Element ID fields.</p>
<div id="rfc.table.2"></div>
<div id="priority-element-types"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Element Types of a PRIORITY frame</caption>
<thead><tr>
<th class="left">Type Bits</th>
<th class="left">Type Description</th>
<th class="left">Element ID Contents</th>
</tr></thead>
<tbody>
<tr>
<td class="left">00</td>
<td class="left">Request stream</td>
<td class="left">Stream ID</td>
</tr>
<tr>
<td class="left">01</td>
<td class="left">Push stream</td>
<td class="left">Push ID</td>
</tr>
<tr>
<td class="left">10</td>
<td class="left">Placeholder</td>
<td class="left">Placeholder ID</td>
</tr>
<tr>
<td class="left">11</td>
<td class="left">Root of the tree</td>
<td class="left">Absent</td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.2.3.p.7">Note that unlike in <a href="#HTTP2" class="xref">[HTTP2]</a>, the root of the tree cannot be referenced using a Stream ID of 0, as in QUIC stream 0 carries a valid HTTP request.  The root of the tree cannot be reprioritized.</p>
<p id="rfc.section.7.2.3.p.8">The PRIORITY frame can express relationships which might not be permitted based on the stream on which it is sent or its position in the stream. These situations MUST be treated as a connection error of type HTTP_MALFORMED_FRAME.  The following situations are examples of invalid PRIORITY frames:</p>
<p></p>

<ul>
<li>A PRIORITY frame with the Prioritized Element Type set to <samp>11</samp>.</li>
<li>A PRIORITY frame which claims to reference a request, but the associated ID does not identify a client-initiated bidirectional stream</li>
</ul>
<p id="rfc.section.7.2.3.p.10">A PRIORITY frame with Empty bits not set to zero MAY be treated as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.7.2.3.p.11">A PRIORITY frame that references a non-existent Push ID, a Placeholder ID greater than the server&#8217;s limit, or a Stream ID the client is not yet permitted to open MUST be treated as a connection error of type HTTP_ID_ERROR.</p>
<p id="rfc.section.7.2.3.p.12">A PRIORITY frame received on any stream other than the control stream MUST be treated as a connection error of type HTTP_WRONG_STREAM.</p>
<p id="rfc.section.7.2.3.p.13">PRIORITY frames received by a client MUST be treated as a connection error of type HTTP_UNEXPECTED_FRAME.</p>
<h3 id="rfc.section.7.2.4">
<a href="#rfc.section.7.2.4">7.2.4.</a> <a href="#frame-cancel-push" id="frame-cancel-push">CANCEL_PUSH</a>
</h3>
<p id="rfc.section.7.2.4.p.1">The CANCEL_PUSH frame (type=0x3) is used to request cancellation of a server push prior to the push stream being received.  The CANCEL_PUSH frame identifies a server push by Push ID (see <a href="#frame-push-promise" class="xref">Section 7.2.6</a>), encoded as a variable-length integer.</p>
<p id="rfc.section.7.2.4.p.2">When a server receives this frame, it aborts sending the response for the identified server push.  If the server has not yet started to send the server push, it can use the receipt of a CANCEL_PUSH frame to avoid opening a push stream.  If the push stream has been opened by the server, the server SHOULD abruptly terminate that stream.</p>
<p id="rfc.section.7.2.4.p.3">A server can send the CANCEL_PUSH frame to indicate that it will not be fulfilling a promise prior to creation of a push stream.  Once the push stream has been created, sending CANCEL_PUSH has no effect on the state of the push stream.  The server SHOULD abruptly terminate the push stream instead.</p>
<p id="rfc.section.7.2.4.p.4">A CANCEL_PUSH frame is sent on the control stream.  Receiving a CANCEL_PUSH frame on a stream other than the control stream MUST be treated as a connection error of type HTTP_WRONG_STREAM.</p>
<div id="rfc.figure.8"></div>
<div id="fig-cancel-push"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Push ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 8: CANCEL_PUSH frame payload</p>
<p id="rfc.section.7.2.4.p.5">The CANCEL_PUSH frame carries a Push ID encoded as a variable-length integer.  The Push ID identifies the server push that is being cancelled (see <a href="#frame-push-promise" class="xref">Section 7.2.6</a>).</p>
<p id="rfc.section.7.2.4.p.6">If the client receives a CANCEL_PUSH frame, that frame might identify a Push ID that has not yet been mentioned by a PUSH_PROMISE frame.</p>
<h3 id="rfc.section.7.2.5">
<a href="#rfc.section.7.2.5">7.2.5.</a> <a href="#frame-settings" id="frame-settings">SETTINGS</a>
</h3>
<p id="rfc.section.7.2.5.p.1">The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior.  Individually, a SETTINGS parameter can also be referred to as a &#8220;setting&#8221;; the identifier and value of each setting parameter can be referred to as a &#8220;setting identifier&#8221; and a &#8220;setting value&#8221;.</p>
<p id="rfc.section.7.2.5.p.2">SETTINGS frames always apply to a connection, never a single stream.  A SETTINGS frame MUST be sent as the first frame of each control stream (see <a href="#control-streams" class="xref">Section 6.2.1</a>) by each peer, and MUST NOT be sent subsequently. If an endpoint receives a second SETTINGS frame on the control stream, the endpoint MUST respond with a connection error of type HTTP_UNEXPECTED_FRAME.</p>
<p id="rfc.section.7.2.5.p.3">SETTINGS frames MUST NOT be sent on any stream other than the control stream.  If an endpoint receives a SETTINGS frame on a different stream, the endpoint MUST respond with a connection error of type HTTP_WRONG_STREAM.</p>
<p id="rfc.section.7.2.5.p.4">SETTINGS parameters are not negotiated; they describe characteristics of the sending peer, which can be used by the receiving peer. However, a negotiation can be implied by the use of SETTINGS - each peer uses SETTINGS to advertise a set of supported values. The definition of the setting would describe how each peer combines the two sets to conclude which choice will be used.  SETTINGS does not provide a mechanism to identify when the choice takes effect.</p>
<p id="rfc.section.7.2.5.p.5">Different values for the same parameter can be advertised by each peer. For example, a client might be willing to consume a very large response header, while servers are more cautious about request size.</p>
<p id="rfc.section.7.2.5.p.6">Parameters MUST NOT occur more than once in the SETTINGS frame.  A receiver MAY treat the presence of the same parameter more than once as a connection error of type HTTP_SETTINGS_ERROR.</p>
<p id="rfc.section.7.2.5.p.7">The payload of a SETTINGS frame consists of zero or more parameters.  Each parameter consists of a setting identifier and a value, both encoded as QUIC variable-length integers.</p>
<div id="rfc.figure.9"></div>
<div id="fig-ext-settings"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Identifier (i)                       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Value (i)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 9: SETTINGS parameter format</p>
<p id="rfc.section.7.2.5.p.8">An implementation MUST ignore the contents for any SETTINGS identifier it does not understand.</p>
<h4 id="rfc.section.7.2.5.1">
<a href="#rfc.section.7.2.5.1">7.2.5.1.</a> <a href="#settings-parameters" id="settings-parameters">Defined SETTINGS Parameters</a>
</h4>
<p id="rfc.section.7.2.5.1.p.1">The following settings are defined in HTTP/3:</p>
<p></p>

<dl>
<dt>SETTINGS_MAX_HEADER_LIST_SIZE (0x6):</dt>
<dd style="margin-left: 8">The default value is unlimited.  See <a href="#header-formatting" class="xref">Section 4.1.1</a> for usage.</dd>
<dt>SETTINGS_NUM_PLACEHOLDERS (0x9):</dt>
<dd style="margin-left: 8">The default value is 0.  However, this value SHOULD be set to a non-zero value by servers.  See <a href="#placeholders" class="xref">Section 4.3.1</a> for usage.</dd>
</dl>
<p id="rfc.section.7.2.5.1.p.3">Setting identifiers of the format <samp>0x1f * N + 0x21</samp> for integer values of N are reserved to exercise the requirement that unknown identifiers be ignored.  Such settings have no defined meaning. Endpoints SHOULD include at least one such setting in their SETTINGS frame. Endpoints MUST NOT consider such settings to have any meaning upon receipt.</p>
<p id="rfc.section.7.2.5.1.p.4">Because the setting has no defined meaning, the value of the setting can be any value the implementation selects.</p>
<p id="rfc.section.7.2.5.1.p.5">Additional settings can be defined by extensions to HTTP/3; see <a href="#extensions" class="xref">Section 9</a> for more details.</p>
<h4 id="rfc.section.7.2.5.2">
<a href="#rfc.section.7.2.5.2">7.2.5.2.</a> <a href="#initialization" id="initialization">Initialization</a>
</h4>
<p id="rfc.section.7.2.5.2.p.1">An HTTP implementation MUST NOT send frames or requests which would be invalid based on its current understanding of the peer&#8217;s settings.  All settings begin at an initial value, and are updated upon receipt of a SETTINGS frame.  For servers, the initial value of each client setting is the default value.</p>
<p id="rfc.section.7.2.5.2.p.2">For clients using a 1-RTT QUIC connection, the initial value of each server setting is the default value. When a 0-RTT QUIC connection is being used, the initial value of each server setting is the value used in the previous session.  Clients MUST store the settings the server provided in the session being resumed and MUST comply with stored settings until the current server settings are received.  A client can use these initial values to send requests before the server&#8217;s SETTINGS frame has arrived.  This removes the need for a client to wait for the SETTINGS frame before sending requests.</p>
<p id="rfc.section.7.2.5.2.p.3">A server can remember the settings that it advertised, or store an integrity-protected copy of the values in the ticket and recover the information when accepting 0-RTT data. A server uses the HTTP/3 settings values in determining whether to accept 0-RTT data.</p>
<p id="rfc.section.7.2.5.2.p.4">A server MAY accept 0-RTT and subsequently provide different settings in its SETTINGS frame. If 0-RTT data is accepted by the server, its SETTINGS frame MUST NOT reduce any limits or alter any values that might be violated by the client with its 0-RTT data.  The server MAY omit settings from its SETTINGS frame which are unchanged from the initial value.</p>
<h3 id="rfc.section.7.2.6">
<a href="#rfc.section.7.2.6">7.2.6.</a> <a href="#frame-push-promise" id="frame-push-promise">PUSH_PROMISE</a>
</h3>
<p id="rfc.section.7.2.6.p.1">The PUSH_PROMISE frame (type=0x5) is used to carry a promised request header set from server to client on a request stream, as in HTTP/2.</p>
<div id="rfc.figure.10"></div>
<div id="fig-push-promise"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Push ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Header Block (*)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 10: PUSH_PROMISE frame payload</p>
<p id="rfc.section.7.2.6.p.2">The payload consists of:</p>
<p></p>

<dl>
<dt>Push ID:</dt>
<dd style="margin-left: 8">A variable-length integer that identifies the server push operation.  A Push ID is used in push stream headers (<a href="#server-push" class="xref">Section 4.4</a>), CANCEL_PUSH frames (<a href="#frame-cancel-push" class="xref">Section 7.2.4</a>), DUPLICATE_PUSH frames (<a href="#frame-duplicate-push" class="xref">Section 7.2.9</a>), and PRIORITY frames (<a href="#frame-priority" class="xref">Section 7.2.3</a>).</dd>
<dt>Header Block:</dt>
<dd style="margin-left: 8">QPACK-compressed request header fields for the promised response.  See <a href="#QPACK" class="xref">[QPACK]</a> for more details.</dd>
</dl>
<p id="rfc.section.7.2.6.p.4">A server MUST NOT use a Push ID that is larger than the client has provided in a MAX_PUSH_ID frame (<a href="#frame-max-push-id" class="xref">Section 7.2.8</a>). A client MUST treat receipt of a PUSH_PROMISE frame that contains a larger Push ID than the client has advertised as a connection error of HTTP_ID_ERROR.</p>
<p id="rfc.section.7.2.6.p.5">A server MUST NOT use the same Push ID in multiple PUSH_PROMISE frames. A client MUST treat receipt of a Push ID which has already been promised as a connection error of type HTTP_ID_ERROR.</p>
<p id="rfc.section.7.2.6.p.6">If a PUSH_PROMISE frame is received on the control stream, the client MUST respond with a connection error (<a href="#errors" class="xref">Section 8</a>) of type HTTP_WRONG_STREAM.</p>
<p id="rfc.section.7.2.6.p.7">A client MUST NOT send a PUSH_PROMISE frame.  A server MUST treat the receipt of a PUSH_PROMISE frame as a connection error of type HTTP_UNEXPECTED_FRAME.</p>
<p id="rfc.section.7.2.6.p.8">See <a href="#server-push" class="xref">Section 4.4</a> for a description of the overall server push mechanism.</p>
<h3 id="rfc.section.7.2.7">
<a href="#rfc.section.7.2.7">7.2.7.</a> <a href="#frame-goaway" id="frame-goaway">GOAWAY</a>
</h3>
<p id="rfc.section.7.2.7.p.1">The GOAWAY frame (type=0x7) is used to initiate graceful shutdown of a connection by a server.  GOAWAY allows a server to stop accepting new requests while still finishing processing of previously received requests.  This enables administrative actions, like server maintenance.  GOAWAY by itself does not close a connection.</p>
<div id="rfc.figure.11"></div>
<div id="fig-goaway"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Stream ID (i)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 11: GOAWAY frame payload</p>
<p id="rfc.section.7.2.7.p.2">The GOAWAY frame is always sent on the control stream. It carries a QUIC Stream ID for a client-initiated bidirectional stream encoded as a variable-length integer.  A client MUST treat receipt of a GOAWAY frame containing a Stream ID of any other type as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.7.2.7.p.3">Clients do not need to send GOAWAY to initiate a graceful shutdown; they simply stop making new requests.  A server MUST treat receipt of a GOAWAY frame on any stream as a connection error (<a href="#errors" class="xref">Section 8</a>) of type HTTP_UNEXPECTED_FRAME.</p>
<p id="rfc.section.7.2.7.p.4">The GOAWAY frame applies to the connection, not a specific stream.  A client MUST treat a GOAWAY frame on a stream other than the control stream as a connection error (<a href="#errors" class="xref">Section 8</a>) of type HTTP_WRONG_STREAM.</p>
<p id="rfc.section.7.2.7.p.5">See <a href="#connection-shutdown" class="xref">Section 5.2</a> for more information on the use of the GOAWAY frame.</p>
<h3 id="rfc.section.7.2.8">
<a href="#rfc.section.7.2.8">7.2.8.</a> <a href="#frame-max-push-id" id="frame-max-push-id">MAX_PUSH_ID</a>
</h3>
<p id="rfc.section.7.2.8.p.1">The MAX_PUSH_ID frame (type=0xD) is used by clients to control the number of server pushes that the server can initiate.  This sets the maximum value for a Push ID that the server can use in a PUSH_PROMISE frame.  Consequently, this also limits the number of push streams that the server can initiate in addition to the limit maintained by the QUIC transport.</p>
<p id="rfc.section.7.2.8.p.2">The MAX_PUSH_ID frame is always sent on the control stream.  Receipt of a MAX_PUSH_ID frame on any other stream MUST be treated as a connection error of type HTTP_WRONG_STREAM.</p>
<p id="rfc.section.7.2.8.p.3">A server MUST NOT send a MAX_PUSH_ID frame.  A client MUST treat the receipt of a MAX_PUSH_ID frame as a connection error of type HTTP_UNEXPECTED_FRAME.</p>
<p id="rfc.section.7.2.8.p.4">The maximum Push ID is unset when a connection is created, meaning that a server cannot push until it receives a MAX_PUSH_ID frame.  A client that wishes to manage the number of promised server pushes can increase the maximum Push ID by sending MAX_PUSH_ID frames as the server fulfills or cancels server pushes.</p>
<div id="rfc.figure.12"></div>
<div id="fig-max-push"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Push ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 12: MAX_PUSH_ID frame payload</p>
<p id="rfc.section.7.2.8.p.5">The MAX_PUSH_ID frame carries a single variable-length integer that identifies the maximum value for a Push ID that the server can use (see <a href="#frame-push-promise" class="xref">Section 7.2.6</a>).  A MAX_PUSH_ID frame cannot reduce the maximum Push ID; receipt of a MAX_PUSH_ID that contains a smaller value than previously received MUST be treated as a connection error of type HTTP_ID_ERROR.</p>
<h3 id="rfc.section.7.2.9">
<a href="#rfc.section.7.2.9">7.2.9.</a> <a href="#frame-duplicate-push" id="frame-duplicate-push">DUPLICATE_PUSH</a>
</h3>
<p id="rfc.section.7.2.9.p.1">The DUPLICATE_PUSH frame (type=0xE) is used by servers to indicate that an existing pushed resource is related to multiple client requests.</p>
<p id="rfc.section.7.2.9.p.2">The DUPLICATE_PUSH frame is always sent on a request stream.  Receipt of a DUPLICATE_PUSH frame on any other stream MUST be treated as a connection error of type HTTP_WRONG_STREAM.</p>
<p id="rfc.section.7.2.9.p.3">A client MUST NOT send a DUPLICATE_PUSH frame.  A server MUST treat the receipt of a DUPLICATE_PUSH frame as a connection error of type HTTP_UNEXPECTED_FRAME.</p>
<div id="rfc.figure.13"></div>
<div id="fig-duplicate-push"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Push ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 13: DUPLICATE_PUSH frame payload</p>
<p id="rfc.section.7.2.9.p.4">The DUPLICATE_PUSH frame carries a single variable-length integer that identifies the Push ID of a resource that the server has previously promised (see <a href="#frame-push-promise" class="xref">Section 7.2.6</a>), though that promise might not be received before this frame.  A server MUST NOT use a Push ID that is larger than the client has provided in a MAX_PUSH_ID frame (<a href="#frame-max-push-id" class="xref">Section 7.2.8</a>).  A client MUST treat receipt of a DUPLICATE_PUSH that contains a larger Push ID than the client has advertised as a connection error of type HTTP_ID_ERROR.</p>
<p id="rfc.section.7.2.9.p.5">This frame allows the server to use the same server push in response to multiple concurrent requests.  Referencing the same server push ensures that a promise can be made in relation to every response in which server push might be needed without duplicating request headers or pushed responses.</p>
<p id="rfc.section.7.2.9.p.6">Allowing duplicate references to the same Push ID is primarily to reduce duplication caused by concurrent requests.  A server SHOULD avoid reusing a Push ID over a long period.  Clients are likely to consume server push responses and not retain them for reuse over time.  Clients that see a DUPLICATE_PUSH that uses a Push ID that they have since consumed and discarded are forced to ignore the DUPLICATE_PUSH.</p>
<h3 id="rfc.section.7.2.10">
<a href="#rfc.section.7.2.10">7.2.10.</a> <a href="#frame-grease" id="frame-grease">Reserved Frame Types</a>
</h3>
<p id="rfc.section.7.2.10.p.1">Frame types of the format <samp>0x1f * N + 0x21</samp> for integer values of N are reserved to exercise the requirement that unknown types be ignored (<a href="#extensions" class="xref">Section 9</a>).  These frames have no semantics, and can be sent when application-layer padding is desired. They MAY also be sent on connections where no data is currently being transferred. Endpoints MUST NOT consider these frames to have any meaning upon receipt.</p>
<p id="rfc.section.7.2.10.p.2">The payload and length of the frames are selected in any manner the implementation chooses.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#errors" id="errors">Error Handling</a>
</h1>
<p id="rfc.section.8.p.1">QUIC allows the application to abruptly terminate (reset) individual streams or the entire connection when an error is encountered.  These are referred to as &#8220;stream errors&#8221; or &#8220;connection errors&#8221; and are described in more detail in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.  An endpoint MAY choose to treat a stream error as a connection error.</p>
<p id="rfc.section.8.p.2">This section describes HTTP/3-specific error codes which can be used to express the cause of a connection or stream error.</p>
<h2 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#http-error-codes" id="http-error-codes">HTTP/3 Error Codes</a>
</h2>
<p id="rfc.section.8.1.p.1">The following error codes are defined for use when abruptly terminating streams, aborting reading of streams, or immediately closing connections.</p>
<p></p>

<dl>
<dt>HTTP_NO_ERROR (0x00):</dt>
<dd style="margin-left: 8">No error.  This is used when the connection or stream needs to be closed, but there is no error to signal.</dd>
<dt>HTTP_GENERAL_PROTOCOL_ERROR (0x01):</dt>
<dd style="margin-left: 8">Peer violated protocol requirements in a way which doesn&#8217;t match a more specific error code, or endpoint declines to use the more specific error code.</dd>
<dt>Reserved (0x02):</dt>
<dd style="margin-left: 8">This code is reserved and has no meaning.</dd>
<dt>HTTP_INTERNAL_ERROR (0x03):</dt>
<dd style="margin-left: 8">An internal error has occurred in the HTTP stack.</dd>
<dt>Reserved (0x04):</dt>
<dd style="margin-left: 8">This code is reserved and has no meaning.</dd>
<dt>HTTP_REQUEST_CANCELLED (0x05):</dt>
<dd style="margin-left: 8">The request or its response (including pushed response) is cancelled.</dd>
<dt>HTTP_INCOMPLETE_REQUEST (0x06):</dt>
<dd style="margin-left: 8">The client&#8217;s stream terminated without containing a fully-formed request.</dd>
<dt>HTTP_CONNECT_ERROR (0x07):</dt>
<dd style="margin-left: 8">The connection established in response to a CONNECT request was reset or abnormally closed.</dd>
<dt>HTTP_EXCESSIVE_LOAD (0x08):</dt>
<dd style="margin-left: 8">The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.</dd>
<dt>HTTP_VERSION_FALLBACK (0x09):</dt>
<dd style="margin-left: 8">The requested operation cannot be served over HTTP/3.  The peer should retry over HTTP/1.1.</dd>
<dt>HTTP_WRONG_STREAM (0x0A):</dt>
<dd style="margin-left: 8">A frame was received on a stream where it is not permitted.</dd>
<dt>HTTP_ID_ERROR (0x0B):</dt>
<dd style="margin-left: 8">A Stream ID, Push ID, or Placeholder ID was used incorrectly, such as exceeding a limit, reducing a limit, or being reused.</dd>
<dt>Reserved (0x0C):</dt>
<dd style="margin-left: 8">N/A</dd>
<dt>HTTP_STREAM_CREATION_ERROR (0x0D):</dt>
<dd style="margin-left: 8">The endpoint detected that its peer created a stream that it will not accept.</dd>
<dt>Reserved (0x0E):</dt>
<dd style="margin-left: 8">N/A</dd>
<dt>HTTP_CLOSED_CRITICAL_STREAM (0x0F):</dt>
<dd style="margin-left: 8">A stream required by the connection was closed or reset.</dd>
<dt>Reserved (0x0010):</dt>
<dd style="margin-left: 8">N/A</dd>
<dt>HTTP_EARLY_RESPONSE (0x0011):</dt>
<dd style="margin-left: 8">The remainder of the client&#8217;s request is not needed to produce a response.  For use in STOP_SENDING only.</dd>
<dt>HTTP_MISSING_SETTINGS (0x0012):</dt>
<dd style="margin-left: 8">No SETTINGS frame was received at the beginning of the control stream.</dd>
<dt>HTTP_UNEXPECTED_FRAME (0x0013):</dt>
<dd style="margin-left: 8">A frame was received which was not permitted in the current state.</dd>
<dt>HTTP_REQUEST_REJECTED (0x0014):</dt>
<dd style="margin-left: 8">A server rejected a request without performing any application processing.</dd>
<dt>HTTP_SETTINGS_ERROR (0x00FF):</dt>
<dd style="margin-left: 8">An endpoint detected an error in the payload of a SETTINGS frame: a duplicate setting was detected, a client-only setting was sent by a server, or a server-only setting by a client.</dd>
<dt>HTTP_MALFORMED_FRAME (0x01XX):</dt>
<dd style="margin-left: 8">An error in a specific frame type.  If the frame type is <samp>0xfe</samp> or less, the type is included as the last byte of the error code.  For example, an error in a MAX_PUSH_ID frame would be indicated with the code (0x10D).  The last byte <samp>0xff</samp> is used to indicate any frame type greater than <samp>0xfe</samp>.</dd>
</dl>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#extensions" id="extensions">Extensions to HTTP/3</a>
</h1>
<p id="rfc.section.9.p.1">HTTP/3 permits extension of the protocol.  Within the limitations described in this section, protocol extensions can be used to provide additional services or alter any aspect of the protocol.  Extensions are effective only within the scope of a single HTTP/3 connection.</p>
<p id="rfc.section.9.p.2">This applies to the protocol elements defined in this document.  This does not affect the existing options for extending HTTP, such as defining new methods, status codes, or header fields.</p>
<p id="rfc.section.9.p.3">Extensions are permitted to use new frame types (<a href="#frames" class="xref">Section 7.2</a>), new settings (<a href="#settings-parameters" class="xref">Section 7.2.5.1</a>), new error codes (<a href="#errors" class="xref">Section 8</a>), or new unidirectional stream types (<a href="#unidirectional-streams" class="xref">Section 6.2</a>).  Registries are established for managing these extension points: frame types (<a href="#iana-frames" class="xref">Section 11.3</a>), settings (<a href="#iana-settings" class="xref">Section 11.4</a>), error codes (<a href="#iana-error-codes" class="xref">Section 11.5</a>), and stream types (<a href="#iana-stream-types" class="xref">Section 11.6</a>).</p>
<p id="rfc.section.9.p.4">Implementations MUST ignore unknown or unsupported values in all extensible protocol elements.  Implementations MUST discard frames and unidirectional streams that have unknown or unsupported types.  This means that any of these extension points can be safely used by extensions without prior arrangement or negotiation.</p>
<p id="rfc.section.9.p.5">Extensions that could change the semantics of existing protocol components MUST be negotiated before being used.  For example, an extension that changes the layout of the HEADERS frame cannot be used until the peer has given a positive signal that this is acceptable. In this case, it could also be necessary to coordinate when the revised layout comes into effect.</p>
<p id="rfc.section.9.p.6">This document doesn&#8217;t mandate a specific method for negotiating the use of an extension but notes that a setting (<a href="#settings-parameters" class="xref">Section 7.2.5.1</a>) could be used for that purpose.  If both peers set a value that indicates willingness to use the extension, then the extension can be used.  If a setting is used for extension negotiation, the default value MUST be defined in such a fashion that the extension is disabled if the setting is omitted.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.10.p.1">The security considerations of HTTP/3 should be comparable to those of HTTP/2 with TLS.  Note that where HTTP/2 employs PADDING frames and Padding fields in other frames to make a connection more resistant to traffic analysis, HTTP/3 can either rely on transport-layer padding or employ the reserved frame and stream types discussed in <a href="#frame-grease" class="xref">Section 7.2.10</a> and <a href="#stream-grease" class="xref">Section 6.2.3</a>.</p>
<p id="rfc.section.10.p.2">When HTTP Alternative Services is used for discovery for HTTP/3 endpoints, the security considerations of <a href="#ALTSVC" class="xref">[ALTSVC]</a> also apply.</p>
<p id="rfc.section.10.p.3">Several protocol elements contain nested length elements, typically in the form of frames with an explicit length containing variable-length integers.  This could pose a security risk to an incautious implementer.  An implementation MUST ensure that the length of a frame exactly matches the length of the fields it contains.</p>
<p id="rfc.section.10.p.4">The use of 0-RTT with HTTP/3 creates an exposure to replay attack.  The anti-replay mitigations in <a href="#HTTP-REPLAY" class="xref">[HTTP-REPLAY]</a> MUST be applied when using HTTP/3 with 0-RTT.</p>
<p id="rfc.section.10.p.5">Certain HTTP implementations use the client address for logging or access-control purposes.  Since a QUIC client&#8217;s address might change during a connection (and future versions might support simultaneous use of multiple addresses), such implementations will need to either actively retrieve the client&#8217;s current address or addresses when they are relevant or explicitly accept that the original address might change.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<h2 id="rfc.section.11.1">
<a href="#rfc.section.11.1">11.1.</a> <a href="#registration-of-http3-identification-string" id="registration-of-http3-identification-string">Registration of HTTP/3 Identification String</a>
</h2>
<p id="rfc.section.11.1.p.1">This document creates a new registration for the identification of HTTP/3 in the &#8220;Application Layer Protocol Negotiation (ALPN) Protocol IDs&#8221; registry established in <a href="#RFC7301" class="xref">[RFC7301]</a>.</p>
<p id="rfc.section.11.1.p.2">The &#8220;h3&#8221; string identifies HTTP/3:</p>
<p></p>

<dl>
<dt>Protocol:</dt>
<dd style="margin-left: 8">HTTP/3</dd>
<dt>Identification Sequence:</dt>
<dd style="margin-left: 8">0x68 0x33 (&#8220;h3&#8221;)</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">This document</dd>
</dl>
<h2 id="rfc.section.11.2">
<a href="#rfc.section.11.2">11.2.</a> <a href="#registration-of-quic-version-hint-alt-svc-parameter" id="registration-of-quic-version-hint-alt-svc-parameter">Registration of QUIC Version Hint Alt-Svc Parameter</a>
</h2>
<p id="rfc.section.11.2.p.1">This document creates a new registration for version-negotiation hints in the &#8220;Hypertext Transfer Protocol (HTTP) Alt-Svc Parameter&#8221; registry established in <a href="#RFC7838" class="xref">[RFC7838]</a>.</p>
<p></p>

<dl>
<dt>Parameter:</dt>
<dd style="margin-left: 8">&#8220;quic&#8221;</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">This document, <a href="#alt-svc-version-hint" class="xref">Section 3.2.1</a>
</dd>
</dl>
<h2 id="rfc.section.11.3">
<a href="#rfc.section.11.3">11.3.</a> <a href="#iana-frames" id="iana-frames">Frame Types</a>
</h2>
<p id="rfc.section.11.3.p.1">This document establishes a registry for HTTP/3 frame type codes. The &#8220;HTTP/3 Frame Type&#8221; registry governs a 62-bit space. This space is split into three spaces that are governed by different policies. Values between <samp>0x00</samp> and <samp>0x3f</samp> (in hexadecimal) are assigned via the Standards Action or IESG Review policies <a href="#RFC8126" class="xref">[RFC8126]</a>. Values from <samp>0x40</samp> to <samp>0x3fff</samp> operate on the Specification Required policy <a href="#RFC8126" class="xref">[RFC8126]</a>. All other values are assigned to Private Use <a href="#RFC8126" class="xref">[RFC8126]</a>.</p>
<p id="rfc.section.11.3.p.2">While this registry is separate from the &#8220;HTTP/2 Frame Type&#8221; registry defined in <a href="#HTTP2" class="xref">[HTTP2]</a>, it is preferable that the assignments parallel each other where the code spaces overlap.  If an entry is present in only one registry, every effort SHOULD be made to avoid assigning the corresponding value to an unrelated operation.</p>
<p id="rfc.section.11.3.p.3">New entries in this registry require the following information:</p>
<p></p>

<dl>
<dt>Frame Type:</dt>
<dd style="margin-left: 8">A name or label for the frame type.</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">The 62-bit code assigned to the frame type.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">A reference to a specification that includes a description of the frame layout and its semantics, including any parts of the frame that are conditionally present.</dd>
</dl>
<p id="rfc.section.11.3.p.5">The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Frame Type</th>
<th class="center">Code</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">DATA</td>
<td class="center">0x0</td>
<td class="left"><a href="#frame-data" class="xref">Section 7.2.1</a></td>
</tr>
<tr>
<td class="left">HEADERS</td>
<td class="center">0x1</td>
<td class="left"><a href="#frame-headers" class="xref">Section 7.2.2</a></td>
</tr>
<tr>
<td class="left">PRIORITY</td>
<td class="center">0x2</td>
<td class="left"><a href="#frame-priority" class="xref">Section 7.2.3</a></td>
</tr>
<tr>
<td class="left">CANCEL_PUSH</td>
<td class="center">0x3</td>
<td class="left"><a href="#frame-cancel-push" class="xref">Section 7.2.4</a></td>
</tr>
<tr>
<td class="left">SETTINGS</td>
<td class="center">0x4</td>
<td class="left"><a href="#frame-settings" class="xref">Section 7.2.5</a></td>
</tr>
<tr>
<td class="left">PUSH_PROMISE</td>
<td class="center">0x5</td>
<td class="left"><a href="#frame-push-promise" class="xref">Section 7.2.6</a></td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x6</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">GOAWAY</td>
<td class="center">0x7</td>
<td class="left"><a href="#frame-goaway" class="xref">Section 7.2.7</a></td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x8</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x9</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">MAX_PUSH_ID</td>
<td class="center">0xD</td>
<td class="left"><a href="#frame-max-push-id" class="xref">Section 7.2.8</a></td>
</tr>
<tr>
<td class="left">DUPLICATE_PUSH</td>
<td class="center">0xE</td>
<td class="left"><a href="#frame-duplicate-push" class="xref">Section 7.2.9</a></td>
</tr>
</tbody>
</table>
<p id="rfc.section.11.3.p.6">Additionally, each code of the format <samp>0x1f * N + 0x21</samp> for integer values of N (that is, <samp>0x21</samp>, <samp>0x40</samp>, &#8230;, through <samp>0x3FFFFFFFFFFFFFFE</samp>) MUST NOT be assigned by IANA.</p>
<h2 id="rfc.section.11.4">
<a href="#rfc.section.11.4">11.4.</a> <a href="#iana-settings" id="iana-settings">Settings Parameters</a>
</h2>
<p id="rfc.section.11.4.p.1">This document establishes a registry for HTTP/3 settings.  The &#8220;HTTP/3 Settings&#8221; registry governs a 62-bit space. This space is split into three spaces that are governed by different policies. Values between <samp>0x00</samp> and <samp>0x3f</samp> (in hexadecimal) are assigned via the Standards Action or IESG Review policies <a href="#RFC8126" class="xref">[RFC8126]</a>. Values from <samp>0x40</samp> to <samp>0x3fff</samp> operate on the Specification Required policy <a href="#RFC8126" class="xref">[RFC8126]</a>. All other values are assigned to Private Use <a href="#RFC8126" class="xref">[RFC8126]</a>.  The designated experts are the same as those for the &#8220;HTTP/2 Settings&#8221; registry defined in <a href="#HTTP2" class="xref">[HTTP2]</a>.</p>
<p id="rfc.section.11.4.p.2">While this registry is separate from the &#8220;HTTP/2 Settings&#8221; registry defined in <a href="#HTTP2" class="xref">[HTTP2]</a>, it is preferable that the assignments parallel each other.  If an entry is present in only one registry, every effort SHOULD be made to avoid assigning the corresponding value to an unrelated operation.</p>
<p id="rfc.section.11.4.p.3">New registrations are advised to provide the following information:</p>
<p></p>

<dl>
<dt>Name:</dt>
<dd style="margin-left: 8">A symbolic name for the setting.  Specifying a setting name is optional.</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">The 62-bit code assigned to the setting.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">An optional reference to a specification that describes the use of the setting.</dd>
</dl>
<p id="rfc.section.11.4.p.5">The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Setting Name</th>
<th class="center">Code</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Reserved</td>
<td class="center">0x2</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x3</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x4</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x5</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">MAX_HEADER_LIST_SIZE</td>
<td class="center">0x6</td>
<td class="left"><a href="#settings-parameters" class="xref">Section 7.2.5.1</a></td>
</tr>
<tr>
<td class="left">NUM_PLACEHOLDERS</td>
<td class="center">0x9</td>
<td class="left"><a href="#settings-parameters" class="xref">Section 7.2.5.1</a></td>
</tr>
</tbody>
</table>
<p id="rfc.section.11.4.p.6">Additionally, each code of the format <samp>0x1f * N + 0x21</samp> for integer values of N (that is, <samp>0x21</samp>, <samp>0x40</samp>, &#8230;, through <samp>0x3FFFFFFFFFFFFFFE</samp>) MUST NOT be assigned by IANA.</p>
<h2 id="rfc.section.11.5">
<a href="#rfc.section.11.5">11.5.</a> <a href="#iana-error-codes" id="iana-error-codes">Error Codes</a>
</h2>
<p id="rfc.section.11.5.p.1">This document establishes a registry for HTTP/3 error codes. The &#8220;HTTP/3 Error Code&#8221; registry manages a 62-bit space.  The &#8220;HTTP/3 Error Code&#8221; registry operates under the &#8220;Expert Review&#8221; policy <a href="#RFC8126" class="xref">[RFC8126]</a>.</p>
<p id="rfc.section.11.5.p.2">Registrations for error codes are required to include a description of the error code.  An expert reviewer is advised to examine new registrations for possible duplication with existing error codes.  Use of existing registrations is to be encouraged, but not mandated.</p>
<p id="rfc.section.11.5.p.3">New registrations are advised to provide the following information:</p>
<p></p>

<dl>
<dt>Name:</dt>
<dd style="margin-left: 8">A name for the error code.  Specifying an error code name is optional.</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">The 62-bit error code value.</dd>
<dt>Description:</dt>
<dd style="margin-left: 8">A brief description of the error code semantics, longer if no detailed specification is provided.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">An optional reference for a specification that defines the error code.</dd>
</dl>
<p id="rfc.section.11.5.p.5">The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Name</th>
<th class="left">Code</th>
<th class="left">Description</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">HTTP_NO_ERROR</td>
<td class="left">0x0000</td>
<td class="left">No error</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_GENERAL_PROTOCOL_ERROR</td>
<td class="left">0x0001</td>
<td class="left">General protocol error</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="left">0x0002</td>
<td class="left">N/A</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">HTTP_INTERNAL_ERROR</td>
<td class="left">0x0003</td>
<td class="left">Internal error</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="left">0x0004</td>
<td class="left">N/A</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">HTTP_REQUEST_CANCELLED</td>
<td class="left">0x0005</td>
<td class="left">Data no longer needed</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_INCOMPLETE_REQUEST</td>
<td class="left">0x0006</td>
<td class="left">Stream terminated early</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_CONNECT_ERROR</td>
<td class="left">0x0007</td>
<td class="left">TCP reset or error on CONNECT request</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_EXCESSIVE_LOAD</td>
<td class="left">0x0008</td>
<td class="left">Peer generating excessive load</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_VERSION_FALLBACK</td>
<td class="left">0x0009</td>
<td class="left">Retry over HTTP/1.1</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_WRONG_STREAM</td>
<td class="left">0x000A</td>
<td class="left">A frame was sent on the wrong stream</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_ID_ERROR</td>
<td class="left">0x000B</td>
<td class="left">An identifier was used incorrectly</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="left">0x000C</td>
<td class="left">N/A</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">HTTP_STREAM_CREATION_ERROR</td>
<td class="left">0x000D</td>
<td class="left">Stream creation error</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="left">0x000E</td>
<td class="left">N/A</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">HTTP_CLOSED_CRITICAL_STREAM</td>
<td class="left">0x000F</td>
<td class="left">Critical stream was closed</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="left">0x000E</td>
<td class="left">N/A</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">HTTP_EARLY_RESPONSE</td>
<td class="left">0x0011</td>
<td class="left">Remainder of request not needed</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_MISSING_SETTINGS</td>
<td class="left">0x0012</td>
<td class="left">No SETTINGS frame received</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_UNEXPECTED_FRAME</td>
<td class="left">0x0013</td>
<td class="left">Frame not permitted in the current state</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_REQUEST_REJECTED</td>
<td class="left">0x0014</td>
<td class="left">Request not processed</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_MALFORMED_FRAME</td>
<td class="left">0x01XX</td>
<td class="left">Error in frame formatting</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
<tr>
<td class="left">HTTP_SETTINGS_ERROR</td>
<td class="left">0x00FF</td>
<td class="left">SETTINGS frame contained invalid values</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 8.1</a></td>
</tr>
</tbody>
</table>
<h2 id="rfc.section.11.6">
<a href="#rfc.section.11.6">11.6.</a> <a href="#iana-stream-types" id="iana-stream-types">Stream Types</a>
</h2>
<p id="rfc.section.11.6.p.1">This document establishes a registry for HTTP/3 unidirectional stream types. The &#8220;HTTP/3 Stream Type&#8221; registry governs a 62-bit space. This space is split into three spaces that are governed by different policies. Values between <samp>0x00</samp> and 0x3f (in hexadecimal) are assigned via the Standards Action or IESG Review policies <a href="#RFC8126" class="xref">[RFC8126]</a>. Values from <samp>0x40</samp> to <samp>0x3fff</samp> operate on the Specification Required policy <a href="#RFC8126" class="xref">[RFC8126]</a>. All other values are assigned to Private Use <a href="#RFC8126" class="xref">[RFC8126]</a>.</p>
<p id="rfc.section.11.6.p.2">New entries in this registry require the following information:</p>
<p></p>

<dl>
<dt>Stream Type:</dt>
<dd style="margin-left: 8">A name or label for the stream type.</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">The 62-bit code assigned to the stream type.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">A reference to a specification that includes a description of the stream type, including the layout semantics of its payload.</dd>
<dt>Sender:</dt>
<dd style="margin-left: 8">Which endpoint on a connection may initiate a stream of this type. Values are &#8220;Client&#8221;, &#8220;Server&#8221;, or &#8220;Both&#8221;.</dd>
</dl>
<p id="rfc.section.11.6.p.4">The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Stream Type</th>
<th class="center">Code</th>
<th class="left">Specification</th>
<th class="left">Sender</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Control Stream</td>
<td class="center">0x00</td>
<td class="left"><a href="#control-streams" class="xref">Section 6.2.1</a></td>
<td class="left">Both</td>
</tr>
<tr>
<td class="left">Push Stream</td>
<td class="center">0x01</td>
<td class="left"><a href="#server-push" class="xref">Section 4.4</a></td>
<td class="left">Server</td>
</tr>
</tbody>
</table>
<p id="rfc.section.11.6.p.5">Additionally, each code of the format <samp>0x1f * N + 0x21</samp> for integer values of N (that is, <samp>0x21</samp>, <samp>0x40</samp>, &#8230;, through <samp>0x3FFFFFFFFFFFFFFE</samp>) MUST NOT be assigned by IANA.</p>
<h1 id="rfc.references">
<a href="#rfc.references">12.</a> References</h1>
<h2 id="rfc.references.1">
<a href="#rfc.references.1">12.1.</a> Normative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="ALTSVC">[ALTSVC]</b></td>
<td class="top">
<a>Nottingham, M.</a>, <a>McManus, P.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7838">HTTP Alternative Services</a>", RFC 7838, DOI 10.17487/RFC7838, April 2016.</td>
</tr>
<tr>
<td class="reference"><b id="HTTP-REPLAY">[HTTP-REPLAY]</b></td>
<td class="top">
<a>Thomson, M.</a>, <a>Nottingham, M.</a> and <a>W. Tarreau</a>, "<a href="https://tools.ietf.org/html/rfc8470">Using Early Data in HTTP</a>", RFC 8470, DOI 10.17487/RFC8470, September 2018.</td>
</tr>
<tr>
<td class="reference"><b id="HTTP2">[HTTP2]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="QPACK">[QPACK]</b></td>
<td class="top">
<a title="Google, Inc">Krasic, C.</a>, <a title="Akamai Technologies">Bishop, M.</a> and <a title="Facebook">A. Frindell</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-qpack">QPACK: Header Compression for HTTP over QUIC</a>", Internet-Draft draft-ietf-quic-qpack, August 2019.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</b></td>
<td class="top">
<a title="Fastly">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport, August 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a>Postel, J.</a>, "<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6066">[RFC6066]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a>, "<a href="https://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, DOI 10.17487/RFC6066, January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7230">[RFC7230]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7231">[RFC7231]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7540">[RFC7540]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7838">[RFC7838]</b></td>
<td class="top">
<a>Nottingham, M.</a>, <a>McManus, P.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7838">HTTP Alternative Services</a>", RFC 7838, DOI 10.17487/RFC7838, April 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8126">[RFC8126]</b></td>
<td class="top">
<a>Cotton, M.</a>, <a>Leiba, B.</a> and <a>T. Narten</a>, "<a href="https://tools.ietf.org/html/rfc8126">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h2 id="rfc.references.2">
<a href="#rfc.references.2">12.2.</a> Informative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="HPACK">[HPACK]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6585">[RFC6585]</b></td>
<td class="top">
<a>Nottingham, M.</a> and <a>R. Fielding</a>, "<a href="https://tools.ietf.org/html/rfc6585">Additional HTTP Status Codes</a>", RFC 6585, DOI 10.17487/RFC6585, April 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7301">[RFC7301]</b></td>
<td class="top">
<a>Friedl, S.</a>, <a>Popov, A.</a>, <a>Langley, A.</a> and <a>E. Stephan</a>, "<a href="https://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>", RFC 7301, DOI 10.17487/RFC7301, July 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7413">[RFC7413]</b></td>
<td class="top">
<a>Cheng, Y.</a>, <a>Chu, J.</a>, <a>Radhakrishnan, S.</a> and <a>A. Jain</a>, "<a href="https://tools.ietf.org/html/rfc7413">TCP Fast Open</a>", RFC 7413, DOI 10.17487/RFC7413, December 2014.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#h2-considerations" id="h2-considerations">Considerations for Transitioning from HTTP/2</a>
</h1>
<p id="rfc.section.A.p.1">HTTP/3 is strongly informed by HTTP/2, and bears many similarities.  This section describes the approach taken to design HTTP/3, points out important differences from HTTP/2, and describes how to map HTTP/2 extensions into HTTP/3.</p>
<p id="rfc.section.A.p.2">HTTP/3 begins from the premise that similarity to HTTP/2 is preferable, but not a hard requirement.  HTTP/3 departs from HTTP/2 where QUIC differs from TCP, either to take advantage of QUIC features (like streams) or to accommodate important shortcomings (such as a lack of total ordering). These differences make HTTP/3 similar to HTTP/2 in key aspects, such as the relationship of requests and responses to streams. However, the details of the HTTP/3 design are substantially different than HTTP/2.</p>
<p id="rfc.section.A.p.3">These departures are noted in this section.</p>
<h2 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#h2-streams" id="h2-streams">Streams</a>
</h2>
<p id="rfc.section.A.1.p.1">HTTP/3 permits use of a larger number of streams (2^62-1) than HTTP/2.  The considerations about exhaustion of stream identifier space apply, though the space is significantly larger such that it is likely that other limits in QUIC are reached first, such as the limit on the connection flow control window.</p>
<h2 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#h2-frames" id="h2-frames">HTTP Frame Types</a>
</h2>
<p id="rfc.section.A.2.p.1">Many framing concepts from HTTP/2 can be elided on QUIC, because the transport deals with them. Because frames are already on a stream, they can omit the stream number. Because frames do not block multiplexing (QUIC&#8217;s multiplexing occurs below this layer), the support for variable-maximum-length packets can be removed. Because stream termination is handled by QUIC, an END_STREAM flag is not required.  This permits the removal of the Flags field from the generic frame layout.</p>
<p id="rfc.section.A.2.p.2">Frame payloads are largely drawn from <a href="#HTTP2" class="xref">[HTTP2]</a>. However, QUIC includes many features (e.g., flow control) which are also present in HTTP/2. In these cases, the HTTP mapping does not re-implement them. As a result, several HTTP/2 frame types are not required in HTTP/3. Where an HTTP/2-defined frame is no longer used, the frame ID has been reserved in order to maximize portability between HTTP/2 and HTTP/3 implementations. However, even equivalent frames between the two mappings are not identical.</p>
<p id="rfc.section.A.2.p.3">Many of the differences arise from the fact that HTTP/2 provides an absolute ordering between frames across all streams, while QUIC provides this guarantee on each stream only.  As a result, if a frame type makes assumptions that frames from different streams will still be received in the order sent, HTTP/3 will break them.</p>
<p id="rfc.section.A.2.p.4">Some examples of feature adaptations are described below, as well as general guidance to extension frame implementors converting an HTTP/2 extension to HTTP/3.</p>
<h3 id="rfc.appendix.A.2.1">
<a href="#rfc.appendix.A.2.1">A.2.1.</a> <a href="#prioritization-differences" id="prioritization-differences">Prioritization Differences</a>
</h3>
<p id="rfc.section.A.2.1.p.1">HTTP/2 specifies priority assignments in PRIORITY frames and (optionally) in HEADERS frames. Implicit in the HTTP/2 prioritization scheme is the notion of in-order delivery of priority changes (i.e., dependency tree mutations). Since operations on the dependency tree such as reparenting a subtree are not commutative, both sender and receiver must apply them in the same order to ensure that both sides have a consistent view of the stream dependency tree.</p>
<p id="rfc.section.A.2.1.p.2">To achieve in-order delivery of priority changes in HTTP/3, PRIORITY frames are sent on the control stream.  HTTP/3 permits the prioritization of requests, pushes and placeholders that each exist in separate identifier spaces. The HTTP/3 PRIORITY frame replaces the stream dependency field with fields that can identify the element of interest and its dependency.</p>
<h3 id="rfc.appendix.A.2.2">
<a href="#rfc.appendix.A.2.2">A.2.2.</a> <a href="#header-compression-differences" id="header-compression-differences">Header Compression Differences</a>
</h3>
<p id="rfc.section.A.2.2.p.1">HPACK was designed with the assumption of in-order delivery. A sequence of encoded header blocks must arrive (and be decoded) at an endpoint in the same order in which they were encoded. This ensures that the dynamic state at the two endpoints remains in sync.</p>
<p id="rfc.section.A.2.2.p.2">Because this total ordering is not provided by QUIC, HTTP/3 uses a modified version of HPACK, called QPACK.  QPACK uses a single unidirectional stream to make all modifications to the dynamic table, ensuring a total order of updates.  All frames which contain encoded headers merely reference the table state at a given time without modifying it.</p>
<p><a href="#QPACK" class="xref">[QPACK]</a> provides additional details.</p>
<h3 id="rfc.appendix.A.2.3">
<a href="#rfc.appendix.A.2.3">A.2.3.</a> <a href="#guidance-for-new-frame-type-definitions" id="guidance-for-new-frame-type-definitions">Guidance for New Frame Type Definitions</a>
</h3>
<p id="rfc.section.A.2.3.p.1">Frame type definitions in HTTP/3 often use the QUIC variable-length integer encoding.  In particular, Stream IDs use this encoding, which allows for a larger range of possible values than the encoding used in HTTP/2.  Some frames in HTTP/3 use an identifier rather than a Stream ID (e.g. Push IDs in PRIORITY frames). Redefinition of the encoding of extension frame types might be necessary if the encoding includes a Stream ID.</p>
<p id="rfc.section.A.2.3.p.2">Because the Flags field is not present in generic HTTP/3 frames, those frames which depend on the presence of flags need to allocate space for flags as part of their frame payload.</p>
<p id="rfc.section.A.2.3.p.3">Other than this issue, frame type HTTP/2 extensions are typically portable to QUIC simply by replacing Stream 0 in HTTP/2 with a control stream in HTTP/3.  HTTP/3 extensions will not assume ordering, but would not be harmed by ordering, and would be portable to HTTP/2 in the same manner.</p>
<h3 id="rfc.appendix.A.2.4">
<a href="#rfc.appendix.A.2.4">A.2.4.</a> <a href="#mapping-between-http2-and-http3-frame-types" id="mapping-between-http2-and-http3-frame-types">Mapping Between HTTP/2 and HTTP/3 Frame Types</a>
</h3>
<p></p>

<dl>
<dt>DATA (0x0):</dt>
<dd style="margin-left: 8">Padding is not defined in HTTP/3 frames.  See <a href="#frame-data" class="xref">Section 7.2.1</a>.</dd>
<dt>HEADERS (0x1):</dt>
<dd style="margin-left: 8">The PRIORITY region of HEADERS is not defined in HTTP/3 frames. A separate PRIORITY frame is used in all cases. Padding is not defined in HTTP/3 frames.  See <a href="#frame-headers" class="xref">Section 7.2.2</a>.</dd>
<dt>PRIORITY (0x2):</dt>
<dd style="margin-left: 8">As described above, the PRIORITY frame references a variety of identifiers. It is sent as the first frame on a request streams or on the control stream. See <a href="#frame-priority" class="xref">Section 7.2.3</a>.</dd>
<dt>RST_STREAM (0x3):</dt>
<dd style="margin-left: 8">RST_STREAM frames do not exist, since QUIC provides stream lifecycle management.  The same code point is used for the CANCEL_PUSH frame (<a href="#frame-cancel-push" class="xref">Section 7.2.4</a>).</dd>
<dt>SETTINGS (0x4):</dt>
<dd style="margin-left: 8">SETTINGS frames are sent only at the beginning of the connection.  See <a href="#frame-settings" class="xref">Section 7.2.5</a> and <a href="#h2-settings" class="xref">Appendix A.3</a>.</dd>
<dt>PUSH_PROMISE (0x5):</dt>
<dd style="margin-left: 8">The PUSH_PROMISE does not reference a stream; instead the push stream references the PUSH_PROMISE frame using a Push ID.  See <a href="#frame-push-promise" class="xref">Section 7.2.6</a>.</dd>
<dt>PING (0x6):</dt>
<dd style="margin-left: 8">PING frames do not exist, since QUIC provides equivalent functionality.</dd>
<dt>GOAWAY (0x7):</dt>
<dd style="margin-left: 8">GOAWAY is sent only from server to client and does not contain an error code.  See <a href="#frame-goaway" class="xref">Section 7.2.7</a>.</dd>
<dt>WINDOW_UPDATE (0x8):</dt>
<dd style="margin-left: 8">WINDOW_UPDATE frames do not exist, since QUIC provides flow control.</dd>
<dt>CONTINUATION (0x9):</dt>
<dd style="margin-left: 8">CONTINUATION frames do not exist; instead, larger HEADERS/PUSH_PROMISE frames than HTTP/2 are permitted.</dd>
</dl>
<p id="rfc.section.A.2.4.p.2">Frame types defined by extensions to HTTP/2 need to be separately registered for HTTP/3 if still applicable.  The IDs of frames defined in <a href="#HTTP2" class="xref">[HTTP2]</a> have been reserved for simplicity.  Note that the frame type space in HTTP/3 is substantially larger (62 bits versus 8 bits), so many HTTP/3 frame types have no equivalent HTTP/2 code points.  See <a href="#iana-frames" class="xref">Section 11.3</a>.</p>
<h2 id="rfc.appendix.A.3">
<a href="#rfc.appendix.A.3">A.3.</a> <a href="#h2-settings" id="h2-settings">HTTP/2 SETTINGS Parameters</a>
</h2>
<p id="rfc.section.A.3.p.1">An important difference from HTTP/2 is that settings are sent once, at the beginning of the connection, and thereafter cannot change.  This eliminates many corner cases around synchronization of changes.</p>
<p id="rfc.section.A.3.p.2">Some transport-level options that HTTP/2 specifies via the SETTINGS frame are superseded by QUIC transport parameters in HTTP/3. The HTTP-level options that are retained in HTTP/3 have the same value as in HTTP/2.</p>
<p id="rfc.section.A.3.p.3">Below is a listing of how each HTTP/2 SETTINGS parameter is mapped:</p>
<p></p>

<dl>
<dt>SETTINGS_HEADER_TABLE_SIZE:</dt>
<dd style="margin-left: 8">See <a href="#QPACK" class="xref">[QPACK]</a>.</dd>
<dt>SETTINGS_ENABLE_PUSH:</dt>
<dd style="margin-left: 8">This is removed in favor of the MAX_PUSH_ID which provides a more granular control over server push.</dd>
<dt>SETTINGS_MAX_CONCURRENT_STREAMS:</dt>
<dd style="margin-left: 8">QUIC controls the largest open Stream ID as part of its flow control logic.  Specifying SETTINGS_MAX_CONCURRENT_STREAMS in the SETTINGS frame is an error.</dd>
<dt>SETTINGS_INITIAL_WINDOW_SIZE:</dt>
<dd style="margin-left: 8">QUIC requires both stream and connection flow control window sizes to be specified in the initial transport handshake.  Specifying SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS frame is an error.</dd>
<dt>SETTINGS_MAX_FRAME_SIZE:</dt>
<dd style="margin-left: 8">This setting has no equivalent in HTTP/3.  Specifying it in the SETTINGS frame is an error.</dd>
<dt>SETTINGS_MAX_HEADER_LIST_SIZE:</dt>
<dd style="margin-left: 8">See <a href="#settings-parameters" class="xref">Section 7.2.5.1</a>.</dd>
</dl>
<p id="rfc.section.A.3.p.5">In HTTP/3, setting values are variable-length integers (6, 14, 30, or 62 bits long) rather than fixed-length 32-bit fields as in HTTP/2.  This will often produce a shorter encoding, but can produce a longer encoding for settings which use the full 32-bit space.  Settings ported from HTTP/2 might choose to redefine the format of their settings to avoid using the 62-bit encoding.</p>
<p id="rfc.section.A.3.p.6">Settings need to be defined separately for HTTP/2 and HTTP/3. The IDs of settings defined in <a href="#HTTP2" class="xref">[HTTP2]</a> have been reserved for simplicity.  Note that the settings identifier space in HTTP/3 is substantially larger (62 bits versus 16 bits), so many HTTP/3 settings have no equivalent HTTP/2 code point. See <a href="#iana-settings" class="xref">Section 11.4</a>.</p>
<h2 id="rfc.appendix.A.4">
<a href="#rfc.appendix.A.4">A.4.</a> <a href="#http2-error-codes" id="http2-error-codes">HTTP/2 Error Codes</a>
</h2>
<p id="rfc.section.A.4.p.1">QUIC has the same concepts of &#8220;stream&#8221; and &#8220;connection&#8221; errors that HTTP/2 provides. However, there is no direct portability of HTTP/2 error codes.</p>
<p id="rfc.section.A.4.p.2">The HTTP/2 error codes defined in Section 7 of <a href="#HTTP2" class="xref">[HTTP2]</a> map to the HTTP/3 error codes as follows:</p>
<p></p>

<dl>
<dt>NO_ERROR (0x0):</dt>
<dd style="margin-left: 8">HTTP_NO_ERROR in <a href="#http-error-codes" class="xref">Section 8.1</a>.</dd>
<dt>PROTOCOL_ERROR (0x1):</dt>
<dd style="margin-left: 8">This is mapped to HTTP_GENERAL_PROTOCOL_ERROR except in cases where more specific error codes have been defined. This includes HTTP_MALFORMED_FRAME, HTTP_WRONG_STREAM, HTTP_UNEXPECTED_FRAME and HTTP_CLOSED_CRITICAL_STREAM defined in <a href="#http-error-codes" class="xref">Section 8.1</a>.</dd>
<dt>INTERNAL_ERROR (0x2):</dt>
<dd style="margin-left: 8">HTTP_INTERNAL_ERROR in <a href="#http-error-codes" class="xref">Section 8.1</a>.</dd>
<dt>FLOW_CONTROL_ERROR (0x3):</dt>
<dd style="margin-left: 8">Not applicable, since QUIC handles flow control.  Would provoke a QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA from the QUIC layer.</dd>
<dt>SETTINGS_TIMEOUT (0x4):</dt>
<dd style="margin-left: 8">Not applicable, since no acknowledgement of SETTINGS is defined.</dd>
<dt>STREAM_CLOSED (0x5):</dt>
<dd style="margin-left: 8">Not applicable, since QUIC handles stream management.  Would provoke a QUIC_STREAM_DATA_AFTER_TERMINATION from the QUIC layer.</dd>
<dt>FRAME_SIZE_ERROR (0x6):</dt>
<dd style="margin-left: 8">HTTP_MALFORMED_FRAME error codes defined in <a href="#http-error-codes" class="xref">Section 8.1</a>.</dd>
<dt>REFUSED_STREAM (0x7):</dt>
<dd style="margin-left: 8">HTTP_REQUEST_REJECTED (in <a href="#http-error-codes" class="xref">Section 8.1</a>) is used to indicate that a request was not processed. Otherwise, not applicable because QUIC handles stream management.  A STREAM_ID_ERROR at the QUIC layer is used for streams that are improperly opened.</dd>
<dt>CANCEL (0x8):</dt>
<dd style="margin-left: 8">HTTP_REQUEST_CANCELLED in <a href="#http-error-codes" class="xref">Section 8.1</a>.</dd>
<dt>COMPRESSION_ERROR (0x9):</dt>
<dd style="margin-left: 8">Multiple error codes are defined in <a href="#QPACK" class="xref">[QPACK]</a>.</dd>
<dt>CONNECT_ERROR (0xa):</dt>
<dd style="margin-left: 8">HTTP_CONNECT_ERROR in <a href="#http-error-codes" class="xref">Section 8.1</a>.</dd>
<dt>ENHANCE_YOUR_CALM (0xb):</dt>
<dd style="margin-left: 8">HTTP_EXCESSIVE_LOAD in <a href="#http-error-codes" class="xref">Section 8.1</a>.</dd>
<dt>INADEQUATE_SECURITY (0xc):</dt>
<dd style="margin-left: 8">Not applicable, since QUIC is assumed to provide sufficient security on all connections.</dd>
<dt>HTTP_1_1_REQUIRED (0xd):</dt>
<dd style="margin-left: 8">HTTP_VERSION_FALLBACK in <a href="#http-error-codes" class="xref">Section 8.1</a>.</dd>
</dl>
<p id="rfc.section.A.4.p.4">Error codes need to be defined for HTTP/2 and HTTP/3 separately.  See <a href="#iana-error-codes" class="xref">Section 11.5</a>.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#change-log" id="change-log">Change Log</a>
</h1>
<p></p>

<ul class="empty"><li>
<strong>RFC Editor&#8217;s Note:</strong>  Please remove this section prior to publication of a final version of this document.</li></ul>
<h2 id="rfc.appendix.B.1">
<a href="#rfc.appendix.B.1">B.1.</a> <a href="#since-draft-ietf-quic-http-19" id="since-draft-ietf-quic-http-19">Since draft-ietf-quic-http-19</a>
</h2>
<p></p>

<ul>
<li>SETTINGS_NUM_PLACEHOLDERS is 0x9 (#2443,#2530)</li>
<li>Non-zero bits in the Empty field of the PRIORITY frame MAY be treated as an error (#2501)</li>
</ul>
<h2 id="rfc.appendix.B.2">
<a href="#rfc.appendix.B.2">B.2.</a> <a href="#since-draft-ietf-quic-http-18" id="since-draft-ietf-quic-http-18">Since draft-ietf-quic-http-18</a>
</h2>
<p></p>

<ul>
<li>Resetting streams following a GOAWAY is recommended, but not required (#2256,#2457)</li>
<li>Use variable-length integers throughout (#2437,#2233,#2253,#2275) <ul>
<li>Variable-length frame types, stream types, and settings identifiers</li>
<li>Renumbered stream type assignments</li>
<li>Modified associated reserved values</li>
</ul>
</li>
<li>Frame layout switched from Length-Type-Value to Type-Length-Value (#2395,#2235)</li>
<li>Specified error code for servers receiving DUPLICATE_PUSH (#2497)</li>
<li>Use connection error for invalid PRIORITY (#2507, #2508)</li>
</ul>
<h2 id="rfc.appendix.B.3">
<a href="#rfc.appendix.B.3">B.3.</a> <a href="#since-draft-ietf-quic-http-17" id="since-draft-ietf-quic-http-17">Since draft-ietf-quic-http-17</a>
</h2>
<p></p>

<ul>
<li>HTTP_REQUEST_REJECTED is used to indicate a request can be retried (#2106, #2325)</li>
<li>Changed error code for GOAWAY on the wrong stream (#2231, #2343)</li>
</ul>
<h2 id="rfc.appendix.B.4">
<a href="#rfc.appendix.B.4">B.4.</a> <a href="#since-draft-ietf-quic-http-16" id="since-draft-ietf-quic-http-16">Since draft-ietf-quic-http-16</a>
</h2>
<p></p>

<ul>
<li>Rename &#8220;HTTP/QUIC&#8221; to &#8220;HTTP/3&#8221; (#1973)</li>
<li>Changes to PRIORITY frame (#1865, #2075) <ul>
<li>Permitted as first frame of request streams</li>
<li>Remove exclusive reprioritization</li>
<li>Changes to Prioritized Element Type bits</li>
</ul>
</li>
<li>Define DUPLICATE_PUSH frame to refer to another PUSH_PROMISE (#2072)</li>
<li>Set defaults for settings, allow request before receiving SETTINGS (#1809, #1846, #2038)</li>
<li>Clarify message processing rules for streams that aren&#8217;t closed (#1972, #2003)</li>
<li>Removed reservation of error code 0 and moved HTTP_NO_ERROR to this value (#1922)</li>
<li>Removed prohibition of zero-length DATA frames (#2098)</li>
</ul>
<h2 id="rfc.appendix.B.5">
<a href="#rfc.appendix.B.5">B.5.</a> <a href="#since-draft-ietf-quic-http-15" id="since-draft-ietf-quic-http-15">Since draft-ietf-quic-http-15</a>
</h2>
<p id="rfc.section.B.5.p.1">Substantial editorial reorganization; no technical changes.</p>
<h2 id="rfc.appendix.B.6">
<a href="#rfc.appendix.B.6">B.6.</a> <a href="#since-draft-ietf-quic-http-14" id="since-draft-ietf-quic-http-14">Since draft-ietf-quic-http-14</a>
</h2>
<p></p>

<ul>
<li>Recommend sensible values for QUIC transport parameters (#1720,#1806)</li>
<li>Define error for missing SETTINGS frame (#1697,#1808)</li>
<li>Setting values are variable-length integers (#1556,#1807) and do not have separate maximum values (#1820)</li>
<li>Expanded discussion of connection closure (#1599,#1717,#1712)</li>
<li>HTTP_VERSION_FALLBACK falls back to HTTP/1.1 (#1677,#1685)</li>
</ul>
<h2 id="rfc.appendix.B.7">
<a href="#rfc.appendix.B.7">B.7.</a> <a href="#since-draft-ietf-quic-http-13" id="since-draft-ietf-quic-http-13">Since draft-ietf-quic-http-13</a>
</h2>
<p></p>

<ul>
<li>Reserved some frame types for grease (#1333, #1446)</li>
<li>Unknown unidirectional stream types are tolerated, not errors; some reserved for grease (#1490, #1525)</li>
<li>Require settings to be remembered for 0-RTT, prohibit reductions (#1541, #1641)</li>
<li>Specify behavior for truncated requests (#1596, #1643)</li>
</ul>
<h2 id="rfc.appendix.B.8">
<a href="#rfc.appendix.B.8">B.8.</a> <a href="#since-draft-ietf-quic-http-12" id="since-draft-ietf-quic-http-12">Since draft-ietf-quic-http-12</a>
</h2>
<p></p>

<ul>
<li>TLS SNI extension isn&#8217;t mandatory if an alternative method is used (#1459, #1462, #1466)</li>
<li>Removed flags from HTTP/3 frames (#1388, #1398)</li>
<li>Reserved frame types and settings for use in preserving extensibility (#1333, #1446)</li>
<li>Added general error code (#1391, #1397)</li>
<li>Unidirectional streams carry a type byte and are extensible (#910,#1359)</li>
<li>Priority mechanism now uses explicit placeholders to enable persistent structure in the tree (#441,#1421,#1422)</li>
</ul>
<h2 id="rfc.appendix.B.9">
<a href="#rfc.appendix.B.9">B.9.</a> <a href="#since-draft-ietf-quic-http-11" id="since-draft-ietf-quic-http-11">Since draft-ietf-quic-http-11</a>
</h2>
<p></p>

<ul><li>Moved QPACK table updates and acknowledgments to dedicated streams (#1121, #1122, #1238)</li></ul>
<h2 id="rfc.appendix.B.10">
<a href="#rfc.appendix.B.10">B.10.</a> <a href="#since-draft-ietf-quic-http-10" id="since-draft-ietf-quic-http-10">Since draft-ietf-quic-http-10</a>
</h2>
<p></p>

<ul><li>Settings need to be remembered when attempting and accepting 0-RTT (#1157, #1207)</li></ul>
<h2 id="rfc.appendix.B.11">
<a href="#rfc.appendix.B.11">B.11.</a> <a href="#since-draft-ietf-quic-http-09" id="since-draft-ietf-quic-http-09">Since draft-ietf-quic-http-09</a>
</h2>
<p></p>

<ul>
<li>Selected QCRAM for header compression (#228, #1117)</li>
<li>The server_name TLS extension is now mandatory (#296, #495)</li>
<li>Specified handling of unsupported versions in Alt-Svc (#1093, #1097)</li>
</ul>
<h2 id="rfc.appendix.B.12">
<a href="#rfc.appendix.B.12">B.12.</a> <a href="#since-draft-ietf-quic-http-08" id="since-draft-ietf-quic-http-08">Since draft-ietf-quic-http-08</a>
</h2>
<p></p>

<ul><li>Clarified connection coalescing rules (#940, #1024)</li></ul>
<h2 id="rfc.appendix.B.13">
<a href="#rfc.appendix.B.13">B.13.</a> <a href="#since-draft-ietf-quic-http-07" id="since-draft-ietf-quic-http-07">Since draft-ietf-quic-http-07</a>
</h2>
<p></p>

<ul>
<li>Changes for integer encodings in QUIC (#595,#905)</li>
<li>Use unidirectional streams as appropriate (#515, #240, #281, #886)</li>
<li>Improvement to the description of GOAWAY (#604, #898)</li>
<li>Improve description of server push usage (#947, #950, #957)</li>
</ul>
<h2 id="rfc.appendix.B.14">
<a href="#rfc.appendix.B.14">B.14.</a> <a href="#since-draft-ietf-quic-http-06" id="since-draft-ietf-quic-http-06">Since draft-ietf-quic-http-06</a>
</h2>
<p></p>

<ul><li>Track changes in QUIC error code usage (#485)</li></ul>
<h2 id="rfc.appendix.B.15">
<a href="#rfc.appendix.B.15">B.15.</a> <a href="#since-draft-ietf-quic-http-05" id="since-draft-ietf-quic-http-05">Since draft-ietf-quic-http-05</a>
</h2>
<p></p>

<ul>
<li>Made push ID sequential, add MAX_PUSH_ID, remove SETTINGS_ENABLE_PUSH (#709)</li>
<li>Guidance about keep-alive and QUIC PINGs (#729)</li>
<li>Expanded text on GOAWAY and cancellation (#757)</li>
</ul>
<h2 id="rfc.appendix.B.16">
<a href="#rfc.appendix.B.16">B.16.</a> <a href="#since-draft-ietf-quic-http-04" id="since-draft-ietf-quic-http-04">Since draft-ietf-quic-http-04</a>
</h2>
<p></p>

<ul>
<li>Cite RFC 5234 (#404)</li>
<li>Return to a single stream per request (#245,#557)</li>
<li>Use separate frame type and settings registries from HTTP/2 (#81)</li>
<li>SETTINGS_ENABLE_PUSH instead of SETTINGS_DISABLE_PUSH (#477)</li>
<li>Restored GOAWAY (#696)</li>
<li>Identify server push using Push ID rather than a stream ID (#702,#281)</li>
<li>DATA frames cannot be empty (#700)</li>
</ul>
<h2 id="rfc.appendix.B.17">
<a href="#rfc.appendix.B.17">B.17.</a> <a href="#since-draft-ietf-quic-http-03" id="since-draft-ietf-quic-http-03">Since draft-ietf-quic-http-03</a>
</h2>
<p id="rfc.section.B.17.p.1">None.</p>
<h2 id="rfc.appendix.B.18">
<a href="#rfc.appendix.B.18">B.18.</a> <a href="#since-draft-ietf-quic-http-02" id="since-draft-ietf-quic-http-02">Since draft-ietf-quic-http-02</a>
</h2>
<p></p>

<ul><li>Track changes in transport draft</li></ul>
<h2 id="rfc.appendix.B.19">
<a href="#rfc.appendix.B.19">B.19.</a> <a href="#since-draft-ietf-quic-http-01" id="since-draft-ietf-quic-http-01">Since draft-ietf-quic-http-01</a>
</h2>
<p></p>

<ul>
<li>SETTINGS changes (#181): <ul>
<li>SETTINGS can be sent only once at the start of a connection; no changes thereafter</li>
<li>SETTINGS_ACK removed</li>
<li>Settings can only occur in the SETTINGS frame a single time</li>
<li>Boolean format updated</li>
</ul>
</li>
<li>Alt-Svc parameter changed from &#8220;v&#8221; to &#8220;quic&#8221;; format updated (#229)</li>
<li>Closing the connection control stream or any message control stream is a fatal error (#176)</li>
<li>HPACK Sequence counter can wrap (#173)</li>
<li>0-RTT guidance added</li>
<li>Guide to differences from HTTP/2 and porting HTTP/2 extensions added (#127,#242)</li>
</ul>
<h2 id="rfc.appendix.B.20">
<a href="#rfc.appendix.B.20">B.20.</a> <a href="#since-draft-ietf-quic-http-00" id="since-draft-ietf-quic-http-00">Since draft-ietf-quic-http-00</a>
</h2>
<p></p>

<ul>
<li>Changed &#8220;HTTP/2-over-QUIC&#8221; to &#8220;HTTP/QUIC&#8221; throughout (#11,#29)</li>
<li>Changed from using HTTP/2 framing within Stream 3 to new framing format and two-stream-per-request model (#71,#72,#73)</li>
<li>Adopted SETTINGS format from draft-bishop-httpbis-extended-settings-01</li>
<li>Reworked SETTINGS_ACK to account for indeterminate inter-stream order (#75)</li>
<li>Described CONNECT pseudo-method (#95)</li>
<li>Updated ALPN token and Alt-Svc guidance (#13,#87)</li>
<li>Application-layer-defined error codes (#19,#74)</li>
</ul>
<h2 id="rfc.appendix.B.21">
<a href="#rfc.appendix.B.21">B.21.</a> <a href="#since-draft-shade-quic-http2-mapping-00" id="since-draft-shade-quic-http2-mapping-00">Since draft-shade-quic-http2-mapping-00</a>
</h2>
<p></p>

<ul>
<li>Adopted as base for draft-ietf-quic-http</li>
<li>Updated authors/editors list</li>
</ul>
<h1 id="rfc.acknowledgements"><a href="#rfc.acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.C.p.1">The original authors of this specification were Robbie Shade and Mike Warres.</p>
<p id="rfc.section.C.p.2">A substantial portion of Mike&#8217;s contribution was supported by Microsoft during his employment there.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Akamai</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mbishop@evequefou.be">mbishop@evequefou.be</a></span>

  </address>
</div>

</body>
</html>

